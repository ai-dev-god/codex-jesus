
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model Insight
 * 
 */
export type Insight = $Result.DefaultSelection<Prisma.$InsightPayload>
/**
 * Model LongevityPlan
 * 
 */
export type LongevityPlan = $Result.DefaultSelection<Prisma.$LongevityPlanPayload>
/**
 * Model Biomarker
 * 
 */
export type Biomarker = $Result.DefaultSelection<Prisma.$BiomarkerPayload>
/**
 * Model BiomarkerLog
 * 
 */
export type BiomarkerLog = $Result.DefaultSelection<Prisma.$BiomarkerLogPayload>
/**
 * Model PanelUpload
 * 
 */
export type PanelUpload = $Result.DefaultSelection<Prisma.$PanelUploadPayload>
/**
 * Model BiomarkerMeasurement
 * 
 */
export type BiomarkerMeasurement = $Result.DefaultSelection<Prisma.$BiomarkerMeasurementPayload>
/**
 * Model AuthProvider
 * 
 */
export type AuthProvider = $Result.DefaultSelection<Prisma.$AuthProviderPayload>
/**
 * Model LoginAudit
 * 
 */
export type LoginAudit = $Result.DefaultSelection<Prisma.$LoginAuditPayload>
/**
 * Model InsightAction
 * 
 */
export type InsightAction = $Result.DefaultSelection<Prisma.$InsightActionPayload>
/**
 * Model InsightGenerationJob
 * 
 */
export type InsightGenerationJob = $Result.DefaultSelection<Prisma.$InsightGenerationJobPayload>
/**
 * Model LongevityPlanJob
 * 
 */
export type LongevityPlanJob = $Result.DefaultSelection<Prisma.$LongevityPlanJobPayload>
/**
 * Model CloudTaskMetadata
 * 
 */
export type CloudTaskMetadata = $Result.DefaultSelection<Prisma.$CloudTaskMetadataPayload>
/**
 * Model WhoopIntegration
 * 
 */
export type WhoopIntegration = $Result.DefaultSelection<Prisma.$WhoopIntegrationPayload>
/**
 * Model WhoopLinkSession
 * 
 */
export type WhoopLinkSession = $Result.DefaultSelection<Prisma.$WhoopLinkSessionPayload>
/**
 * Model FeedPost
 * 
 */
export type FeedPost = $Result.DefaultSelection<Prisma.$FeedPostPayload>
/**
 * Model Comment
 * 
 */
export type Comment = $Result.DefaultSelection<Prisma.$CommentPayload>
/**
 * Model Reaction
 * 
 */
export type Reaction = $Result.DefaultSelection<Prisma.$ReactionPayload>
/**
 * Model EngagementEvent
 * 
 */
export type EngagementEvent = $Result.DefaultSelection<Prisma.$EngagementEventPayload>
/**
 * Model Flag
 * 
 */
export type Flag = $Result.DefaultSelection<Prisma.$FlagPayload>
/**
 * Model AdminAuditLog
 * 
 */
export type AdminAuditLog = $Result.DefaultSelection<Prisma.$AdminAuditLogPayload>
/**
 * Model AiResponseAudit
 * 
 */
export type AiResponseAudit = $Result.DefaultSelection<Prisma.$AiResponseAuditPayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model RoomMembership
 * 
 */
export type RoomMembership = $Result.DefaultSelection<Prisma.$RoomMembershipPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  MEMBER: 'MEMBER',
  COACH: 'COACH',
  MODERATOR: 'MODERATOR',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const UserStatus: {
  PENDING_ONBOARDING: 'PENDING_ONBOARDING',
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus]


export const InsightStatus: {
  DRAFT: 'DRAFT',
  DELIVERED: 'DELIVERED',
  ARCHIVED: 'ARCHIVED'
};

export type InsightStatus = (typeof InsightStatus)[keyof typeof InsightStatus]


export const LongevityPlanStatus: {
  DRAFT: 'DRAFT',
  PROCESSING: 'PROCESSING',
  READY: 'READY',
  FAILED: 'FAILED',
  ARCHIVED: 'ARCHIVED'
};

export type LongevityPlanStatus = (typeof LongevityPlanStatus)[keyof typeof LongevityPlanStatus]


export const BiomarkerSource: {
  WHOOP: 'WHOOP',
  MANUAL: 'MANUAL',
  LAB_UPLOAD: 'LAB_UPLOAD'
};

export type BiomarkerSource = (typeof BiomarkerSource)[keyof typeof BiomarkerSource]


export const PanelUploadStatus: {
  PENDING: 'PENDING',
  NORMALIZED: 'NORMALIZED',
  FAILED: 'FAILED'
};

export type PanelUploadStatus = (typeof PanelUploadStatus)[keyof typeof PanelUploadStatus]


export const PanelUploadSource: {
  LAB_REPORT: 'LAB_REPORT',
  WEARABLE_EXPORT: 'WEARABLE_EXPORT',
  MANUAL_ENTRY: 'MANUAL_ENTRY'
};

export type PanelUploadSource = (typeof PanelUploadSource)[keyof typeof PanelUploadSource]


export const MeasurementStatus: {
  RAW: 'RAW',
  NORMALIZED: 'NORMALIZED',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED'
};

export type MeasurementStatus = (typeof MeasurementStatus)[keyof typeof MeasurementStatus]


export const AuthProviderType: {
  EMAIL_PASSWORD: 'EMAIL_PASSWORD',
  GOOGLE: 'GOOGLE',
  APPLE: 'APPLE',
  WHOOP: 'WHOOP'
};

export type AuthProviderType = (typeof AuthProviderType)[keyof typeof AuthProviderType]


export const InsightActionType: {
  ACCEPTED: 'ACCEPTED',
  DISMISSED: 'DISMISSED',
  RETRY_REQUESTED: 'RETRY_REQUESTED',
  FEEDBACK_LEFT: 'FEEDBACK_LEFT'
};

export type InsightActionType = (typeof InsightActionType)[keyof typeof InsightActionType]


export const InsightGenerationStatus: {
  QUEUED: 'QUEUED',
  RUNNING: 'RUNNING',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED'
};

export type InsightGenerationStatus = (typeof InsightGenerationStatus)[keyof typeof InsightGenerationStatus]


export const LongevityPlanJobStatus: {
  QUEUED: 'QUEUED',
  RUNNING: 'RUNNING',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED'
};

export type LongevityPlanJobStatus = (typeof LongevityPlanJobStatus)[keyof typeof LongevityPlanJobStatus]


export const CloudTaskStatus: {
  PENDING: 'PENDING',
  DISPATCHED: 'DISPATCHED',
  SUCCEEDED: 'SUCCEEDED',
  FAILED: 'FAILED'
};

export type CloudTaskStatus = (typeof CloudTaskStatus)[keyof typeof CloudTaskStatus]


export const WhoopSyncStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE'
};

export type WhoopSyncStatus = (typeof WhoopSyncStatus)[keyof typeof WhoopSyncStatus]


export const PostVisibility: {
  MEMBERS: 'MEMBERS',
  COHORT: 'COHORT',
  PUBLIC: 'PUBLIC'
};

export type PostVisibility = (typeof PostVisibility)[keyof typeof PostVisibility]


export const ReactionType: {
  BOOST: 'BOOST',
  HIGH_FIVE: 'HIGH_FIVE',
  NOTEWORTHY: 'NOTEWORTHY'
};

export type ReactionType = (typeof ReactionType)[keyof typeof ReactionType]


export const EngagementEventType: {
  POST_CREATED: 'POST_CREATED',
  POST_DELETED: 'POST_DELETED',
  COMMENT_CREATED: 'COMMENT_CREATED',
  COMMENT_DELETED: 'COMMENT_DELETED',
  REACTION_ADDED: 'REACTION_ADDED',
  REACTION_REMOVED: 'REACTION_REMOVED'
};

export type EngagementEventType = (typeof EngagementEventType)[keyof typeof EngagementEventType]


export const FlagTargetType: {
  POST: 'POST',
  COMMENT: 'COMMENT',
  INSIGHT: 'INSIGHT',
  BIOMARKER_LOG: 'BIOMARKER_LOG'
};

export type FlagTargetType = (typeof FlagTargetType)[keyof typeof FlagTargetType]


export const FlagStatus: {
  OPEN: 'OPEN',
  TRIAGED: 'TRIAGED',
  RESOLVED: 'RESOLVED'
};

export type FlagStatus = (typeof FlagStatus)[keyof typeof FlagStatus]


export const RoomStatus: {
  LOBBY: 'LOBBY',
  ACTIVE: 'ACTIVE',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type RoomStatus = (typeof RoomStatus)[keyof typeof RoomStatus]


export const RoomMembershipRole: {
  HOST: 'HOST',
  PLAYER: 'PLAYER',
  SPECTATOR: 'SPECTATOR'
};

export type RoomMembershipRole = (typeof RoomMembershipRole)[keyof typeof RoomMembershipRole]


export const RoomMembershipStatus: {
  ACTIVE: 'ACTIVE',
  LEFT: 'LEFT',
  SPECTATOR: 'SPECTATOR'
};

export type RoomMembershipStatus = (typeof RoomMembershipStatus)[keyof typeof RoomMembershipStatus]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type UserStatus = $Enums.UserStatus

export const UserStatus: typeof $Enums.UserStatus

export type InsightStatus = $Enums.InsightStatus

export const InsightStatus: typeof $Enums.InsightStatus

export type LongevityPlanStatus = $Enums.LongevityPlanStatus

export const LongevityPlanStatus: typeof $Enums.LongevityPlanStatus

export type BiomarkerSource = $Enums.BiomarkerSource

export const BiomarkerSource: typeof $Enums.BiomarkerSource

export type PanelUploadStatus = $Enums.PanelUploadStatus

export const PanelUploadStatus: typeof $Enums.PanelUploadStatus

export type PanelUploadSource = $Enums.PanelUploadSource

export const PanelUploadSource: typeof $Enums.PanelUploadSource

export type MeasurementStatus = $Enums.MeasurementStatus

export const MeasurementStatus: typeof $Enums.MeasurementStatus

export type AuthProviderType = $Enums.AuthProviderType

export const AuthProviderType: typeof $Enums.AuthProviderType

export type InsightActionType = $Enums.InsightActionType

export const InsightActionType: typeof $Enums.InsightActionType

export type InsightGenerationStatus = $Enums.InsightGenerationStatus

export const InsightGenerationStatus: typeof $Enums.InsightGenerationStatus

export type LongevityPlanJobStatus = $Enums.LongevityPlanJobStatus

export const LongevityPlanJobStatus: typeof $Enums.LongevityPlanJobStatus

export type CloudTaskStatus = $Enums.CloudTaskStatus

export const CloudTaskStatus: typeof $Enums.CloudTaskStatus

export type WhoopSyncStatus = $Enums.WhoopSyncStatus

export const WhoopSyncStatus: typeof $Enums.WhoopSyncStatus

export type PostVisibility = $Enums.PostVisibility

export const PostVisibility: typeof $Enums.PostVisibility

export type ReactionType = $Enums.ReactionType

export const ReactionType: typeof $Enums.ReactionType

export type EngagementEventType = $Enums.EngagementEventType

export const EngagementEventType: typeof $Enums.EngagementEventType

export type FlagTargetType = $Enums.FlagTargetType

export const FlagTargetType: typeof $Enums.FlagTargetType

export type FlagStatus = $Enums.FlagStatus

export const FlagStatus: typeof $Enums.FlagStatus

export type RoomStatus = $Enums.RoomStatus

export const RoomStatus: typeof $Enums.RoomStatus

export type RoomMembershipRole = $Enums.RoomMembershipRole

export const RoomMembershipRole: typeof $Enums.RoomMembershipRole

export type RoomMembershipStatus = $Enums.RoomMembershipStatus

export const RoomMembershipStatus: typeof $Enums.RoomMembershipStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs>;

  /**
   * `prisma.insight`: Exposes CRUD operations for the **Insight** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Insights
    * const insights = await prisma.insight.findMany()
    * ```
    */
  get insight(): Prisma.InsightDelegate<ExtArgs>;

  /**
   * `prisma.longevityPlan`: Exposes CRUD operations for the **LongevityPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LongevityPlans
    * const longevityPlans = await prisma.longevityPlan.findMany()
    * ```
    */
  get longevityPlan(): Prisma.LongevityPlanDelegate<ExtArgs>;

  /**
   * `prisma.biomarker`: Exposes CRUD operations for the **Biomarker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Biomarkers
    * const biomarkers = await prisma.biomarker.findMany()
    * ```
    */
  get biomarker(): Prisma.BiomarkerDelegate<ExtArgs>;

  /**
   * `prisma.biomarkerLog`: Exposes CRUD operations for the **BiomarkerLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BiomarkerLogs
    * const biomarkerLogs = await prisma.biomarkerLog.findMany()
    * ```
    */
  get biomarkerLog(): Prisma.BiomarkerLogDelegate<ExtArgs>;

  /**
   * `prisma.panelUpload`: Exposes CRUD operations for the **PanelUpload** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PanelUploads
    * const panelUploads = await prisma.panelUpload.findMany()
    * ```
    */
  get panelUpload(): Prisma.PanelUploadDelegate<ExtArgs>;

  /**
   * `prisma.biomarkerMeasurement`: Exposes CRUD operations for the **BiomarkerMeasurement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BiomarkerMeasurements
    * const biomarkerMeasurements = await prisma.biomarkerMeasurement.findMany()
    * ```
    */
  get biomarkerMeasurement(): Prisma.BiomarkerMeasurementDelegate<ExtArgs>;

  /**
   * `prisma.authProvider`: Exposes CRUD operations for the **AuthProvider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuthProviders
    * const authProviders = await prisma.authProvider.findMany()
    * ```
    */
  get authProvider(): Prisma.AuthProviderDelegate<ExtArgs>;

  /**
   * `prisma.loginAudit`: Exposes CRUD operations for the **LoginAudit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LoginAudits
    * const loginAudits = await prisma.loginAudit.findMany()
    * ```
    */
  get loginAudit(): Prisma.LoginAuditDelegate<ExtArgs>;

  /**
   * `prisma.insightAction`: Exposes CRUD operations for the **InsightAction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InsightActions
    * const insightActions = await prisma.insightAction.findMany()
    * ```
    */
  get insightAction(): Prisma.InsightActionDelegate<ExtArgs>;

  /**
   * `prisma.insightGenerationJob`: Exposes CRUD operations for the **InsightGenerationJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InsightGenerationJobs
    * const insightGenerationJobs = await prisma.insightGenerationJob.findMany()
    * ```
    */
  get insightGenerationJob(): Prisma.InsightGenerationJobDelegate<ExtArgs>;

  /**
   * `prisma.longevityPlanJob`: Exposes CRUD operations for the **LongevityPlanJob** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LongevityPlanJobs
    * const longevityPlanJobs = await prisma.longevityPlanJob.findMany()
    * ```
    */
  get longevityPlanJob(): Prisma.LongevityPlanJobDelegate<ExtArgs>;

  /**
   * `prisma.cloudTaskMetadata`: Exposes CRUD operations for the **CloudTaskMetadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CloudTaskMetadata
    * const cloudTaskMetadata = await prisma.cloudTaskMetadata.findMany()
    * ```
    */
  get cloudTaskMetadata(): Prisma.CloudTaskMetadataDelegate<ExtArgs>;

  /**
   * `prisma.whoopIntegration`: Exposes CRUD operations for the **WhoopIntegration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhoopIntegrations
    * const whoopIntegrations = await prisma.whoopIntegration.findMany()
    * ```
    */
  get whoopIntegration(): Prisma.WhoopIntegrationDelegate<ExtArgs>;

  /**
   * `prisma.whoopLinkSession`: Exposes CRUD operations for the **WhoopLinkSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WhoopLinkSessions
    * const whoopLinkSessions = await prisma.whoopLinkSession.findMany()
    * ```
    */
  get whoopLinkSession(): Prisma.WhoopLinkSessionDelegate<ExtArgs>;

  /**
   * `prisma.feedPost`: Exposes CRUD operations for the **FeedPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedPosts
    * const feedPosts = await prisma.feedPost.findMany()
    * ```
    */
  get feedPost(): Prisma.FeedPostDelegate<ExtArgs>;

  /**
   * `prisma.comment`: Exposes CRUD operations for the **Comment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Comments
    * const comments = await prisma.comment.findMany()
    * ```
    */
  get comment(): Prisma.CommentDelegate<ExtArgs>;

  /**
   * `prisma.reaction`: Exposes CRUD operations for the **Reaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reactions
    * const reactions = await prisma.reaction.findMany()
    * ```
    */
  get reaction(): Prisma.ReactionDelegate<ExtArgs>;

  /**
   * `prisma.engagementEvent`: Exposes CRUD operations for the **EngagementEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EngagementEvents
    * const engagementEvents = await prisma.engagementEvent.findMany()
    * ```
    */
  get engagementEvent(): Prisma.EngagementEventDelegate<ExtArgs>;

  /**
   * `prisma.flag`: Exposes CRUD operations for the **Flag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flags
    * const flags = await prisma.flag.findMany()
    * ```
    */
  get flag(): Prisma.FlagDelegate<ExtArgs>;

  /**
   * `prisma.adminAuditLog`: Exposes CRUD operations for the **AdminAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AdminAuditLogs
    * const adminAuditLogs = await prisma.adminAuditLog.findMany()
    * ```
    */
  get adminAuditLog(): Prisma.AdminAuditLogDelegate<ExtArgs>;

  /**
   * `prisma.aiResponseAudit`: Exposes CRUD operations for the **AiResponseAudit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AiResponseAudits
    * const aiResponseAudits = await prisma.aiResponseAudit.findMany()
    * ```
    */
  get aiResponseAudit(): Prisma.AiResponseAuditDelegate<ExtArgs>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs>;

  /**
   * `prisma.roomMembership`: Exposes CRUD operations for the **RoomMembership** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomMemberships
    * const roomMemberships = await prisma.roomMembership.findMany()
    * ```
    */
  get roomMembership(): Prisma.RoomMembershipDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Profile: 'Profile',
    Insight: 'Insight',
    LongevityPlan: 'LongevityPlan',
    Biomarker: 'Biomarker',
    BiomarkerLog: 'BiomarkerLog',
    PanelUpload: 'PanelUpload',
    BiomarkerMeasurement: 'BiomarkerMeasurement',
    AuthProvider: 'AuthProvider',
    LoginAudit: 'LoginAudit',
    InsightAction: 'InsightAction',
    InsightGenerationJob: 'InsightGenerationJob',
    LongevityPlanJob: 'LongevityPlanJob',
    CloudTaskMetadata: 'CloudTaskMetadata',
    WhoopIntegration: 'WhoopIntegration',
    WhoopLinkSession: 'WhoopLinkSession',
    FeedPost: 'FeedPost',
    Comment: 'Comment',
    Reaction: 'Reaction',
    EngagementEvent: 'EngagementEvent',
    Flag: 'Flag',
    AdminAuditLog: 'AdminAuditLog',
    AiResponseAudit: 'AiResponseAudit',
    Room: 'Room',
    RoomMembership: 'RoomMembership'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "profile" | "insight" | "longevityPlan" | "biomarker" | "biomarkerLog" | "panelUpload" | "biomarkerMeasurement" | "authProvider" | "loginAudit" | "insightAction" | "insightGenerationJob" | "longevityPlanJob" | "cloudTaskMetadata" | "whoopIntegration" | "whoopLinkSession" | "feedPost" | "comment" | "reaction" | "engagementEvent" | "flag" | "adminAuditLog" | "aiResponseAudit" | "room" | "roomMembership"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      Insight: {
        payload: Prisma.$InsightPayload<ExtArgs>
        fields: Prisma.InsightFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsightFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsightFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>
          }
          findFirst: {
            args: Prisma.InsightFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsightFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>
          }
          findMany: {
            args: Prisma.InsightFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>[]
          }
          create: {
            args: Prisma.InsightCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>
          }
          createMany: {
            args: Prisma.InsightCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsightCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>[]
          }
          delete: {
            args: Prisma.InsightDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>
          }
          update: {
            args: Prisma.InsightUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>
          }
          deleteMany: {
            args: Prisma.InsightDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsightUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InsightUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightPayload>
          }
          aggregate: {
            args: Prisma.InsightAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsight>
          }
          groupBy: {
            args: Prisma.InsightGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsightGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsightCountArgs<ExtArgs>
            result: $Utils.Optional<InsightCountAggregateOutputType> | number
          }
        }
      }
      LongevityPlan: {
        payload: Prisma.$LongevityPlanPayload<ExtArgs>
        fields: Prisma.LongevityPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LongevityPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LongevityPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanPayload>
          }
          findFirst: {
            args: Prisma.LongevityPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LongevityPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanPayload>
          }
          findMany: {
            args: Prisma.LongevityPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanPayload>[]
          }
          create: {
            args: Prisma.LongevityPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanPayload>
          }
          createMany: {
            args: Prisma.LongevityPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LongevityPlanCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanPayload>[]
          }
          delete: {
            args: Prisma.LongevityPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanPayload>
          }
          update: {
            args: Prisma.LongevityPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanPayload>
          }
          deleteMany: {
            args: Prisma.LongevityPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LongevityPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LongevityPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanPayload>
          }
          aggregate: {
            args: Prisma.LongevityPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLongevityPlan>
          }
          groupBy: {
            args: Prisma.LongevityPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<LongevityPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.LongevityPlanCountArgs<ExtArgs>
            result: $Utils.Optional<LongevityPlanCountAggregateOutputType> | number
          }
        }
      }
      Biomarker: {
        payload: Prisma.$BiomarkerPayload<ExtArgs>
        fields: Prisma.BiomarkerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BiomarkerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BiomarkerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload>
          }
          findFirst: {
            args: Prisma.BiomarkerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BiomarkerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload>
          }
          findMany: {
            args: Prisma.BiomarkerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload>[]
          }
          create: {
            args: Prisma.BiomarkerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload>
          }
          createMany: {
            args: Prisma.BiomarkerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BiomarkerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload>[]
          }
          delete: {
            args: Prisma.BiomarkerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload>
          }
          update: {
            args: Prisma.BiomarkerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload>
          }
          deleteMany: {
            args: Prisma.BiomarkerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BiomarkerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BiomarkerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerPayload>
          }
          aggregate: {
            args: Prisma.BiomarkerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBiomarker>
          }
          groupBy: {
            args: Prisma.BiomarkerGroupByArgs<ExtArgs>
            result: $Utils.Optional<BiomarkerGroupByOutputType>[]
          }
          count: {
            args: Prisma.BiomarkerCountArgs<ExtArgs>
            result: $Utils.Optional<BiomarkerCountAggregateOutputType> | number
          }
        }
      }
      BiomarkerLog: {
        payload: Prisma.$BiomarkerLogPayload<ExtArgs>
        fields: Prisma.BiomarkerLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BiomarkerLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BiomarkerLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerLogPayload>
          }
          findFirst: {
            args: Prisma.BiomarkerLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BiomarkerLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerLogPayload>
          }
          findMany: {
            args: Prisma.BiomarkerLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerLogPayload>[]
          }
          create: {
            args: Prisma.BiomarkerLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerLogPayload>
          }
          createMany: {
            args: Prisma.BiomarkerLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BiomarkerLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerLogPayload>[]
          }
          delete: {
            args: Prisma.BiomarkerLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerLogPayload>
          }
          update: {
            args: Prisma.BiomarkerLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerLogPayload>
          }
          deleteMany: {
            args: Prisma.BiomarkerLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BiomarkerLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BiomarkerLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerLogPayload>
          }
          aggregate: {
            args: Prisma.BiomarkerLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBiomarkerLog>
          }
          groupBy: {
            args: Prisma.BiomarkerLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<BiomarkerLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.BiomarkerLogCountArgs<ExtArgs>
            result: $Utils.Optional<BiomarkerLogCountAggregateOutputType> | number
          }
        }
      }
      PanelUpload: {
        payload: Prisma.$PanelUploadPayload<ExtArgs>
        fields: Prisma.PanelUploadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PanelUploadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanelUploadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PanelUploadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanelUploadPayload>
          }
          findFirst: {
            args: Prisma.PanelUploadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanelUploadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PanelUploadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanelUploadPayload>
          }
          findMany: {
            args: Prisma.PanelUploadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanelUploadPayload>[]
          }
          create: {
            args: Prisma.PanelUploadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanelUploadPayload>
          }
          createMany: {
            args: Prisma.PanelUploadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PanelUploadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanelUploadPayload>[]
          }
          delete: {
            args: Prisma.PanelUploadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanelUploadPayload>
          }
          update: {
            args: Prisma.PanelUploadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanelUploadPayload>
          }
          deleteMany: {
            args: Prisma.PanelUploadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PanelUploadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PanelUploadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PanelUploadPayload>
          }
          aggregate: {
            args: Prisma.PanelUploadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePanelUpload>
          }
          groupBy: {
            args: Prisma.PanelUploadGroupByArgs<ExtArgs>
            result: $Utils.Optional<PanelUploadGroupByOutputType>[]
          }
          count: {
            args: Prisma.PanelUploadCountArgs<ExtArgs>
            result: $Utils.Optional<PanelUploadCountAggregateOutputType> | number
          }
        }
      }
      BiomarkerMeasurement: {
        payload: Prisma.$BiomarkerMeasurementPayload<ExtArgs>
        fields: Prisma.BiomarkerMeasurementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BiomarkerMeasurementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerMeasurementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BiomarkerMeasurementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerMeasurementPayload>
          }
          findFirst: {
            args: Prisma.BiomarkerMeasurementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerMeasurementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BiomarkerMeasurementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerMeasurementPayload>
          }
          findMany: {
            args: Prisma.BiomarkerMeasurementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerMeasurementPayload>[]
          }
          create: {
            args: Prisma.BiomarkerMeasurementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerMeasurementPayload>
          }
          createMany: {
            args: Prisma.BiomarkerMeasurementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BiomarkerMeasurementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerMeasurementPayload>[]
          }
          delete: {
            args: Prisma.BiomarkerMeasurementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerMeasurementPayload>
          }
          update: {
            args: Prisma.BiomarkerMeasurementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerMeasurementPayload>
          }
          deleteMany: {
            args: Prisma.BiomarkerMeasurementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BiomarkerMeasurementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BiomarkerMeasurementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiomarkerMeasurementPayload>
          }
          aggregate: {
            args: Prisma.BiomarkerMeasurementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBiomarkerMeasurement>
          }
          groupBy: {
            args: Prisma.BiomarkerMeasurementGroupByArgs<ExtArgs>
            result: $Utils.Optional<BiomarkerMeasurementGroupByOutputType>[]
          }
          count: {
            args: Prisma.BiomarkerMeasurementCountArgs<ExtArgs>
            result: $Utils.Optional<BiomarkerMeasurementCountAggregateOutputType> | number
          }
        }
      }
      AuthProvider: {
        payload: Prisma.$AuthProviderPayload<ExtArgs>
        fields: Prisma.AuthProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuthProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuthProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload>
          }
          findFirst: {
            args: Prisma.AuthProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuthProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload>
          }
          findMany: {
            args: Prisma.AuthProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload>[]
          }
          create: {
            args: Prisma.AuthProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload>
          }
          createMany: {
            args: Prisma.AuthProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuthProviderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload>[]
          }
          delete: {
            args: Prisma.AuthProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload>
          }
          update: {
            args: Prisma.AuthProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload>
          }
          deleteMany: {
            args: Prisma.AuthProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuthProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuthProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuthProviderPayload>
          }
          aggregate: {
            args: Prisma.AuthProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuthProvider>
          }
          groupBy: {
            args: Prisma.AuthProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuthProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuthProviderCountArgs<ExtArgs>
            result: $Utils.Optional<AuthProviderCountAggregateOutputType> | number
          }
        }
      }
      LoginAudit: {
        payload: Prisma.$LoginAuditPayload<ExtArgs>
        fields: Prisma.LoginAuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LoginAuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LoginAuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload>
          }
          findFirst: {
            args: Prisma.LoginAuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LoginAuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload>
          }
          findMany: {
            args: Prisma.LoginAuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload>[]
          }
          create: {
            args: Prisma.LoginAuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload>
          }
          createMany: {
            args: Prisma.LoginAuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LoginAuditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload>[]
          }
          delete: {
            args: Prisma.LoginAuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload>
          }
          update: {
            args: Prisma.LoginAuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload>
          }
          deleteMany: {
            args: Prisma.LoginAuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LoginAuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LoginAuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LoginAuditPayload>
          }
          aggregate: {
            args: Prisma.LoginAuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLoginAudit>
          }
          groupBy: {
            args: Prisma.LoginAuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<LoginAuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.LoginAuditCountArgs<ExtArgs>
            result: $Utils.Optional<LoginAuditCountAggregateOutputType> | number
          }
        }
      }
      InsightAction: {
        payload: Prisma.$InsightActionPayload<ExtArgs>
        fields: Prisma.InsightActionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsightActionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightActionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsightActionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightActionPayload>
          }
          findFirst: {
            args: Prisma.InsightActionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightActionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsightActionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightActionPayload>
          }
          findMany: {
            args: Prisma.InsightActionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightActionPayload>[]
          }
          create: {
            args: Prisma.InsightActionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightActionPayload>
          }
          createMany: {
            args: Prisma.InsightActionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsightActionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightActionPayload>[]
          }
          delete: {
            args: Prisma.InsightActionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightActionPayload>
          }
          update: {
            args: Prisma.InsightActionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightActionPayload>
          }
          deleteMany: {
            args: Prisma.InsightActionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsightActionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InsightActionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightActionPayload>
          }
          aggregate: {
            args: Prisma.InsightActionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsightAction>
          }
          groupBy: {
            args: Prisma.InsightActionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsightActionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsightActionCountArgs<ExtArgs>
            result: $Utils.Optional<InsightActionCountAggregateOutputType> | number
          }
        }
      }
      InsightGenerationJob: {
        payload: Prisma.$InsightGenerationJobPayload<ExtArgs>
        fields: Prisma.InsightGenerationJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InsightGenerationJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightGenerationJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InsightGenerationJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightGenerationJobPayload>
          }
          findFirst: {
            args: Prisma.InsightGenerationJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightGenerationJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InsightGenerationJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightGenerationJobPayload>
          }
          findMany: {
            args: Prisma.InsightGenerationJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightGenerationJobPayload>[]
          }
          create: {
            args: Prisma.InsightGenerationJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightGenerationJobPayload>
          }
          createMany: {
            args: Prisma.InsightGenerationJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InsightGenerationJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightGenerationJobPayload>[]
          }
          delete: {
            args: Prisma.InsightGenerationJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightGenerationJobPayload>
          }
          update: {
            args: Prisma.InsightGenerationJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightGenerationJobPayload>
          }
          deleteMany: {
            args: Prisma.InsightGenerationJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InsightGenerationJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InsightGenerationJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InsightGenerationJobPayload>
          }
          aggregate: {
            args: Prisma.InsightGenerationJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInsightGenerationJob>
          }
          groupBy: {
            args: Prisma.InsightGenerationJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<InsightGenerationJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.InsightGenerationJobCountArgs<ExtArgs>
            result: $Utils.Optional<InsightGenerationJobCountAggregateOutputType> | number
          }
        }
      }
      LongevityPlanJob: {
        payload: Prisma.$LongevityPlanJobPayload<ExtArgs>
        fields: Prisma.LongevityPlanJobFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LongevityPlanJobFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanJobPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LongevityPlanJobFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanJobPayload>
          }
          findFirst: {
            args: Prisma.LongevityPlanJobFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanJobPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LongevityPlanJobFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanJobPayload>
          }
          findMany: {
            args: Prisma.LongevityPlanJobFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanJobPayload>[]
          }
          create: {
            args: Prisma.LongevityPlanJobCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanJobPayload>
          }
          createMany: {
            args: Prisma.LongevityPlanJobCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LongevityPlanJobCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanJobPayload>[]
          }
          delete: {
            args: Prisma.LongevityPlanJobDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanJobPayload>
          }
          update: {
            args: Prisma.LongevityPlanJobUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanJobPayload>
          }
          deleteMany: {
            args: Prisma.LongevityPlanJobDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LongevityPlanJobUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LongevityPlanJobUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LongevityPlanJobPayload>
          }
          aggregate: {
            args: Prisma.LongevityPlanJobAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLongevityPlanJob>
          }
          groupBy: {
            args: Prisma.LongevityPlanJobGroupByArgs<ExtArgs>
            result: $Utils.Optional<LongevityPlanJobGroupByOutputType>[]
          }
          count: {
            args: Prisma.LongevityPlanJobCountArgs<ExtArgs>
            result: $Utils.Optional<LongevityPlanJobCountAggregateOutputType> | number
          }
        }
      }
      CloudTaskMetadata: {
        payload: Prisma.$CloudTaskMetadataPayload<ExtArgs>
        fields: Prisma.CloudTaskMetadataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CloudTaskMetadataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudTaskMetadataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CloudTaskMetadataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudTaskMetadataPayload>
          }
          findFirst: {
            args: Prisma.CloudTaskMetadataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudTaskMetadataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CloudTaskMetadataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudTaskMetadataPayload>
          }
          findMany: {
            args: Prisma.CloudTaskMetadataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudTaskMetadataPayload>[]
          }
          create: {
            args: Prisma.CloudTaskMetadataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudTaskMetadataPayload>
          }
          createMany: {
            args: Prisma.CloudTaskMetadataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CloudTaskMetadataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudTaskMetadataPayload>[]
          }
          delete: {
            args: Prisma.CloudTaskMetadataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudTaskMetadataPayload>
          }
          update: {
            args: Prisma.CloudTaskMetadataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudTaskMetadataPayload>
          }
          deleteMany: {
            args: Prisma.CloudTaskMetadataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CloudTaskMetadataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CloudTaskMetadataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CloudTaskMetadataPayload>
          }
          aggregate: {
            args: Prisma.CloudTaskMetadataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCloudTaskMetadata>
          }
          groupBy: {
            args: Prisma.CloudTaskMetadataGroupByArgs<ExtArgs>
            result: $Utils.Optional<CloudTaskMetadataGroupByOutputType>[]
          }
          count: {
            args: Prisma.CloudTaskMetadataCountArgs<ExtArgs>
            result: $Utils.Optional<CloudTaskMetadataCountAggregateOutputType> | number
          }
        }
      }
      WhoopIntegration: {
        payload: Prisma.$WhoopIntegrationPayload<ExtArgs>
        fields: Prisma.WhoopIntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhoopIntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopIntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhoopIntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopIntegrationPayload>
          }
          findFirst: {
            args: Prisma.WhoopIntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopIntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhoopIntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopIntegrationPayload>
          }
          findMany: {
            args: Prisma.WhoopIntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopIntegrationPayload>[]
          }
          create: {
            args: Prisma.WhoopIntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopIntegrationPayload>
          }
          createMany: {
            args: Prisma.WhoopIntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhoopIntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopIntegrationPayload>[]
          }
          delete: {
            args: Prisma.WhoopIntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopIntegrationPayload>
          }
          update: {
            args: Prisma.WhoopIntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopIntegrationPayload>
          }
          deleteMany: {
            args: Prisma.WhoopIntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhoopIntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WhoopIntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopIntegrationPayload>
          }
          aggregate: {
            args: Prisma.WhoopIntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhoopIntegration>
          }
          groupBy: {
            args: Prisma.WhoopIntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhoopIntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhoopIntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<WhoopIntegrationCountAggregateOutputType> | number
          }
        }
      }
      WhoopLinkSession: {
        payload: Prisma.$WhoopLinkSessionPayload<ExtArgs>
        fields: Prisma.WhoopLinkSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WhoopLinkSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopLinkSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WhoopLinkSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopLinkSessionPayload>
          }
          findFirst: {
            args: Prisma.WhoopLinkSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopLinkSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WhoopLinkSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopLinkSessionPayload>
          }
          findMany: {
            args: Prisma.WhoopLinkSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopLinkSessionPayload>[]
          }
          create: {
            args: Prisma.WhoopLinkSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopLinkSessionPayload>
          }
          createMany: {
            args: Prisma.WhoopLinkSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WhoopLinkSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopLinkSessionPayload>[]
          }
          delete: {
            args: Prisma.WhoopLinkSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopLinkSessionPayload>
          }
          update: {
            args: Prisma.WhoopLinkSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopLinkSessionPayload>
          }
          deleteMany: {
            args: Prisma.WhoopLinkSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WhoopLinkSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WhoopLinkSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WhoopLinkSessionPayload>
          }
          aggregate: {
            args: Prisma.WhoopLinkSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWhoopLinkSession>
          }
          groupBy: {
            args: Prisma.WhoopLinkSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<WhoopLinkSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.WhoopLinkSessionCountArgs<ExtArgs>
            result: $Utils.Optional<WhoopLinkSessionCountAggregateOutputType> | number
          }
        }
      }
      FeedPost: {
        payload: Prisma.$FeedPostPayload<ExtArgs>
        fields: Prisma.FeedPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPostPayload>
          }
          findFirst: {
            args: Prisma.FeedPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPostPayload>
          }
          findMany: {
            args: Prisma.FeedPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPostPayload>[]
          }
          create: {
            args: Prisma.FeedPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPostPayload>
          }
          createMany: {
            args: Prisma.FeedPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FeedPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPostPayload>[]
          }
          delete: {
            args: Prisma.FeedPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPostPayload>
          }
          update: {
            args: Prisma.FeedPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPostPayload>
          }
          deleteMany: {
            args: Prisma.FeedPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeedPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedPostPayload>
          }
          aggregate: {
            args: Prisma.FeedPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedPost>
          }
          groupBy: {
            args: Prisma.FeedPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedPostCountArgs<ExtArgs>
            result: $Utils.Optional<FeedPostCountAggregateOutputType> | number
          }
        }
      }
      Comment: {
        payload: Prisma.$CommentPayload<ExtArgs>
        fields: Prisma.CommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findFirst: {
            args: Prisma.CommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          findMany: {
            args: Prisma.CommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          create: {
            args: Prisma.CommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          createMany: {
            args: Prisma.CommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>[]
          }
          delete: {
            args: Prisma.CommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          update: {
            args: Prisma.CommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          deleteMany: {
            args: Prisma.CommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentPayload>
          }
          aggregate: {
            args: Prisma.CommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComment>
          }
          groupBy: {
            args: Prisma.CommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentCountArgs<ExtArgs>
            result: $Utils.Optional<CommentCountAggregateOutputType> | number
          }
        }
      }
      Reaction: {
        payload: Prisma.$ReactionPayload<ExtArgs>
        fields: Prisma.ReactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          findFirst: {
            args: Prisma.ReactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          findMany: {
            args: Prisma.ReactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>[]
          }
          create: {
            args: Prisma.ReactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          createMany: {
            args: Prisma.ReactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>[]
          }
          delete: {
            args: Prisma.ReactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          update: {
            args: Prisma.ReactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          deleteMany: {
            args: Prisma.ReactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReactionPayload>
          }
          aggregate: {
            args: Prisma.ReactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReaction>
          }
          groupBy: {
            args: Prisma.ReactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReactionCountArgs<ExtArgs>
            result: $Utils.Optional<ReactionCountAggregateOutputType> | number
          }
        }
      }
      EngagementEvent: {
        payload: Prisma.$EngagementEventPayload<ExtArgs>
        fields: Prisma.EngagementEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EngagementEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EngagementEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementEventPayload>
          }
          findFirst: {
            args: Prisma.EngagementEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EngagementEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementEventPayload>
          }
          findMany: {
            args: Prisma.EngagementEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementEventPayload>[]
          }
          create: {
            args: Prisma.EngagementEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementEventPayload>
          }
          createMany: {
            args: Prisma.EngagementEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EngagementEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementEventPayload>[]
          }
          delete: {
            args: Prisma.EngagementEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementEventPayload>
          }
          update: {
            args: Prisma.EngagementEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementEventPayload>
          }
          deleteMany: {
            args: Prisma.EngagementEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EngagementEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EngagementEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementEventPayload>
          }
          aggregate: {
            args: Prisma.EngagementEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEngagementEvent>
          }
          groupBy: {
            args: Prisma.EngagementEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EngagementEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EngagementEventCountArgs<ExtArgs>
            result: $Utils.Optional<EngagementEventCountAggregateOutputType> | number
          }
        }
      }
      Flag: {
        payload: Prisma.$FlagPayload<ExtArgs>
        fields: Prisma.FlagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FlagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FlagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload>
          }
          findFirst: {
            args: Prisma.FlagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FlagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload>
          }
          findMany: {
            args: Prisma.FlagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload>[]
          }
          create: {
            args: Prisma.FlagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload>
          }
          createMany: {
            args: Prisma.FlagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FlagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload>[]
          }
          delete: {
            args: Prisma.FlagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload>
          }
          update: {
            args: Prisma.FlagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload>
          }
          deleteMany: {
            args: Prisma.FlagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FlagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FlagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FlagPayload>
          }
          aggregate: {
            args: Prisma.FlagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFlag>
          }
          groupBy: {
            args: Prisma.FlagGroupByArgs<ExtArgs>
            result: $Utils.Optional<FlagGroupByOutputType>[]
          }
          count: {
            args: Prisma.FlagCountArgs<ExtArgs>
            result: $Utils.Optional<FlagCountAggregateOutputType> | number
          }
        }
      }
      AdminAuditLog: {
        payload: Prisma.$AdminAuditLogPayload<ExtArgs>
        fields: Prisma.AdminAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AdminAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AdminAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          findFirst: {
            args: Prisma.AdminAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AdminAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          findMany: {
            args: Prisma.AdminAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>[]
          }
          create: {
            args: Prisma.AdminAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          createMany: {
            args: Prisma.AdminAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AdminAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>[]
          }
          delete: {
            args: Prisma.AdminAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          update: {
            args: Prisma.AdminAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AdminAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AdminAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AdminAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AdminAuditLogPayload>
          }
          aggregate: {
            args: Prisma.AdminAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdminAuditLog>
          }
          groupBy: {
            args: Prisma.AdminAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AdminAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AdminAuditLogCountAggregateOutputType> | number
          }
        }
      }
      AiResponseAudit: {
        payload: Prisma.$AiResponseAuditPayload<ExtArgs>
        fields: Prisma.AiResponseAuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AiResponseAuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiResponseAuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AiResponseAuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiResponseAuditPayload>
          }
          findFirst: {
            args: Prisma.AiResponseAuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiResponseAuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AiResponseAuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiResponseAuditPayload>
          }
          findMany: {
            args: Prisma.AiResponseAuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiResponseAuditPayload>[]
          }
          create: {
            args: Prisma.AiResponseAuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiResponseAuditPayload>
          }
          createMany: {
            args: Prisma.AiResponseAuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AiResponseAuditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiResponseAuditPayload>[]
          }
          delete: {
            args: Prisma.AiResponseAuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiResponseAuditPayload>
          }
          update: {
            args: Prisma.AiResponseAuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiResponseAuditPayload>
          }
          deleteMany: {
            args: Prisma.AiResponseAuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AiResponseAuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AiResponseAuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AiResponseAuditPayload>
          }
          aggregate: {
            args: Prisma.AiResponseAuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAiResponseAudit>
          }
          groupBy: {
            args: Prisma.AiResponseAuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<AiResponseAuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.AiResponseAuditCountArgs<ExtArgs>
            result: $Utils.Optional<AiResponseAuditCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      RoomMembership: {
        payload: Prisma.$RoomMembershipPayload<ExtArgs>
        fields: Prisma.RoomMembershipFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomMembershipFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomMembershipFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload>
          }
          findFirst: {
            args: Prisma.RoomMembershipFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomMembershipFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload>
          }
          findMany: {
            args: Prisma.RoomMembershipFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload>[]
          }
          create: {
            args: Prisma.RoomMembershipCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload>
          }
          createMany: {
            args: Prisma.RoomMembershipCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomMembershipCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload>[]
          }
          delete: {
            args: Prisma.RoomMembershipDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload>
          }
          update: {
            args: Prisma.RoomMembershipUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload>
          }
          deleteMany: {
            args: Prisma.RoomMembershipDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomMembershipUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomMembershipUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomMembershipPayload>
          }
          aggregate: {
            args: Prisma.RoomMembershipAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomMembership>
          }
          groupBy: {
            args: Prisma.RoomMembershipGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomMembershipGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomMembershipCountArgs<ExtArgs>
            result: $Utils.Optional<RoomMembershipCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    authProviders: number
    whoopLinkSessions: number
    insights: number
    insightActions: number
    insightGenerationJobs: number
    biomarkerLogs: number
    panelUploads: number
    biomarkerMeasurements: number
    feedPosts: number
    comments: number
    reactions: number
    engagementEvents: number
    roomsHosted: number
    roomMemberships: number
    flagsOpened: number
    flagsResolved: number
    auditLogs: number
    longevityPlans: number
    longevityPlanJobs: number
    aiResponseAudits: number
    loginAudits: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    authProviders?: boolean | UserCountOutputTypeCountAuthProvidersArgs
    whoopLinkSessions?: boolean | UserCountOutputTypeCountWhoopLinkSessionsArgs
    insights?: boolean | UserCountOutputTypeCountInsightsArgs
    insightActions?: boolean | UserCountOutputTypeCountInsightActionsArgs
    insightGenerationJobs?: boolean | UserCountOutputTypeCountInsightGenerationJobsArgs
    biomarkerLogs?: boolean | UserCountOutputTypeCountBiomarkerLogsArgs
    panelUploads?: boolean | UserCountOutputTypeCountPanelUploadsArgs
    biomarkerMeasurements?: boolean | UserCountOutputTypeCountBiomarkerMeasurementsArgs
    feedPosts?: boolean | UserCountOutputTypeCountFeedPostsArgs
    comments?: boolean | UserCountOutputTypeCountCommentsArgs
    reactions?: boolean | UserCountOutputTypeCountReactionsArgs
    engagementEvents?: boolean | UserCountOutputTypeCountEngagementEventsArgs
    roomsHosted?: boolean | UserCountOutputTypeCountRoomsHostedArgs
    roomMemberships?: boolean | UserCountOutputTypeCountRoomMembershipsArgs
    flagsOpened?: boolean | UserCountOutputTypeCountFlagsOpenedArgs
    flagsResolved?: boolean | UserCountOutputTypeCountFlagsResolvedArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    longevityPlans?: boolean | UserCountOutputTypeCountLongevityPlansArgs
    longevityPlanJobs?: boolean | UserCountOutputTypeCountLongevityPlanJobsArgs
    aiResponseAudits?: boolean | UserCountOutputTypeCountAiResponseAuditsArgs
    loginAudits?: boolean | UserCountOutputTypeCountLoginAuditsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuthProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthProviderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWhoopLinkSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhoopLinkSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInsightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInsightActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightActionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInsightGenerationJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightGenerationJobWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBiomarkerLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiomarkerLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPanelUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PanelUploadWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBiomarkerMeasurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiomarkerMeasurementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFeedPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEngagementEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EngagementEventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoomsHostedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoomMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomMembershipWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFlagsOpenedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlagWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFlagsResolvedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlagWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLongevityPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LongevityPlanWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLongevityPlanJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LongevityPlanJobWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAiResponseAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiResponseAuditWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLoginAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginAuditWhereInput
  }


  /**
   * Count Type InsightCountOutputType
   */

  export type InsightCountOutputType = {
    actions: number
    generationJobs: number
    flags: number
  }

  export type InsightCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actions?: boolean | InsightCountOutputTypeCountActionsArgs
    generationJobs?: boolean | InsightCountOutputTypeCountGenerationJobsArgs
    flags?: boolean | InsightCountOutputTypeCountFlagsArgs
  }

  // Custom InputTypes
  /**
   * InsightCountOutputType without action
   */
  export type InsightCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightCountOutputType
     */
    select?: InsightCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InsightCountOutputType without action
   */
  export type InsightCountOutputTypeCountActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightActionWhereInput
  }

  /**
   * InsightCountOutputType without action
   */
  export type InsightCountOutputTypeCountGenerationJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightGenerationJobWhereInput
  }

  /**
   * InsightCountOutputType without action
   */
  export type InsightCountOutputTypeCountFlagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlagWhereInput
  }


  /**
   * Count Type LongevityPlanCountOutputType
   */

  export type LongevityPlanCountOutputType = {
    jobs: number
    audits: number
  }

  export type LongevityPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | LongevityPlanCountOutputTypeCountJobsArgs
    audits?: boolean | LongevityPlanCountOutputTypeCountAuditsArgs
  }

  // Custom InputTypes
  /**
   * LongevityPlanCountOutputType without action
   */
  export type LongevityPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlanCountOutputType
     */
    select?: LongevityPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LongevityPlanCountOutputType without action
   */
  export type LongevityPlanCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LongevityPlanJobWhereInput
  }

  /**
   * LongevityPlanCountOutputType without action
   */
  export type LongevityPlanCountOutputTypeCountAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiResponseAuditWhereInput
  }


  /**
   * Count Type BiomarkerCountOutputType
   */

  export type BiomarkerCountOutputType = {
    logs: number
    measurements: number
  }

  export type BiomarkerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | BiomarkerCountOutputTypeCountLogsArgs
    measurements?: boolean | BiomarkerCountOutputTypeCountMeasurementsArgs
  }

  // Custom InputTypes
  /**
   * BiomarkerCountOutputType without action
   */
  export type BiomarkerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerCountOutputType
     */
    select?: BiomarkerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BiomarkerCountOutputType without action
   */
  export type BiomarkerCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiomarkerLogWhereInput
  }

  /**
   * BiomarkerCountOutputType without action
   */
  export type BiomarkerCountOutputTypeCountMeasurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiomarkerMeasurementWhereInput
  }


  /**
   * Count Type BiomarkerLogCountOutputType
   */

  export type BiomarkerLogCountOutputType = {
    flags: number
  }

  export type BiomarkerLogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    flags?: boolean | BiomarkerLogCountOutputTypeCountFlagsArgs
  }

  // Custom InputTypes
  /**
   * BiomarkerLogCountOutputType without action
   */
  export type BiomarkerLogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerLogCountOutputType
     */
    select?: BiomarkerLogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BiomarkerLogCountOutputType without action
   */
  export type BiomarkerLogCountOutputTypeCountFlagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlagWhereInput
  }


  /**
   * Count Type PanelUploadCountOutputType
   */

  export type PanelUploadCountOutputType = {
    measurements: number
  }

  export type PanelUploadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    measurements?: boolean | PanelUploadCountOutputTypeCountMeasurementsArgs
  }

  // Custom InputTypes
  /**
   * PanelUploadCountOutputType without action
   */
  export type PanelUploadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanelUploadCountOutputType
     */
    select?: PanelUploadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PanelUploadCountOutputType without action
   */
  export type PanelUploadCountOutputTypeCountMeasurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiomarkerMeasurementWhereInput
  }


  /**
   * Count Type FeedPostCountOutputType
   */

  export type FeedPostCountOutputType = {
    comments: number
    reactions: number
    flags: number
    engagementEvents: number
  }

  export type FeedPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | FeedPostCountOutputTypeCountCommentsArgs
    reactions?: boolean | FeedPostCountOutputTypeCountReactionsArgs
    flags?: boolean | FeedPostCountOutputTypeCountFlagsArgs
    engagementEvents?: boolean | FeedPostCountOutputTypeCountEngagementEventsArgs
  }

  // Custom InputTypes
  /**
   * FeedPostCountOutputType without action
   */
  export type FeedPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPostCountOutputType
     */
    select?: FeedPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FeedPostCountOutputType without action
   */
  export type FeedPostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
  }

  /**
   * FeedPostCountOutputType without action
   */
  export type FeedPostCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
  }

  /**
   * FeedPostCountOutputType without action
   */
  export type FeedPostCountOutputTypeCountFlagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlagWhereInput
  }

  /**
   * FeedPostCountOutputType without action
   */
  export type FeedPostCountOutputTypeCountEngagementEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EngagementEventWhereInput
  }


  /**
   * Count Type CommentCountOutputType
   */

  export type CommentCountOutputType = {
    reactions: number
    flags: number
    engagementEvents: number
  }

  export type CommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reactions?: boolean | CommentCountOutputTypeCountReactionsArgs
    flags?: boolean | CommentCountOutputTypeCountFlagsArgs
    engagementEvents?: boolean | CommentCountOutputTypeCountEngagementEventsArgs
  }

  // Custom InputTypes
  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentCountOutputType
     */
    select?: CommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountReactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountFlagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlagWhereInput
  }

  /**
   * CommentCountOutputType without action
   */
  export type CommentCountOutputTypeCountEngagementEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EngagementEventWhereInput
  }


  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    memberships: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberships?: boolean | RoomCountOutputTypeCountMembershipsArgs
  }

  // Custom InputTypes
  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomMembershipWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    fullName: string | null
    role: $Enums.Role | null
    status: $Enums.UserStatus | null
    whoopMemberId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    fullName: string | null
    role: $Enums.Role | null
    status: $Enums.UserStatus | null
    whoopMemberId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    fullName: number
    role: number
    status: number
    whoopMemberId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    role?: true
    status?: true
    whoopMemberId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    role?: true
    status?: true
    whoopMemberId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    fullName?: true
    role?: true
    status?: true
    whoopMemberId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string | null
    fullName: string | null
    role: $Enums.Role
    status: $Enums.UserStatus
    whoopMemberId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    role?: boolean
    status?: boolean
    whoopMemberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    authProviders?: boolean | User$authProvidersArgs<ExtArgs>
    whoopIntegration?: boolean | User$whoopIntegrationArgs<ExtArgs>
    whoopLinkSessions?: boolean | User$whoopLinkSessionsArgs<ExtArgs>
    insights?: boolean | User$insightsArgs<ExtArgs>
    insightActions?: boolean | User$insightActionsArgs<ExtArgs>
    insightGenerationJobs?: boolean | User$insightGenerationJobsArgs<ExtArgs>
    biomarkerLogs?: boolean | User$biomarkerLogsArgs<ExtArgs>
    panelUploads?: boolean | User$panelUploadsArgs<ExtArgs>
    biomarkerMeasurements?: boolean | User$biomarkerMeasurementsArgs<ExtArgs>
    feedPosts?: boolean | User$feedPostsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    reactions?: boolean | User$reactionsArgs<ExtArgs>
    engagementEvents?: boolean | User$engagementEventsArgs<ExtArgs>
    roomsHosted?: boolean | User$roomsHostedArgs<ExtArgs>
    roomMemberships?: boolean | User$roomMembershipsArgs<ExtArgs>
    flagsOpened?: boolean | User$flagsOpenedArgs<ExtArgs>
    flagsResolved?: boolean | User$flagsResolvedArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    longevityPlans?: boolean | User$longevityPlansArgs<ExtArgs>
    longevityPlanJobs?: boolean | User$longevityPlanJobsArgs<ExtArgs>
    aiResponseAudits?: boolean | User$aiResponseAuditsArgs<ExtArgs>
    loginAudits?: boolean | User$loginAuditsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    role?: boolean
    status?: boolean
    whoopMemberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    fullName?: boolean
    role?: boolean
    status?: boolean
    whoopMemberId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    authProviders?: boolean | User$authProvidersArgs<ExtArgs>
    whoopIntegration?: boolean | User$whoopIntegrationArgs<ExtArgs>
    whoopLinkSessions?: boolean | User$whoopLinkSessionsArgs<ExtArgs>
    insights?: boolean | User$insightsArgs<ExtArgs>
    insightActions?: boolean | User$insightActionsArgs<ExtArgs>
    insightGenerationJobs?: boolean | User$insightGenerationJobsArgs<ExtArgs>
    biomarkerLogs?: boolean | User$biomarkerLogsArgs<ExtArgs>
    panelUploads?: boolean | User$panelUploadsArgs<ExtArgs>
    biomarkerMeasurements?: boolean | User$biomarkerMeasurementsArgs<ExtArgs>
    feedPosts?: boolean | User$feedPostsArgs<ExtArgs>
    comments?: boolean | User$commentsArgs<ExtArgs>
    reactions?: boolean | User$reactionsArgs<ExtArgs>
    engagementEvents?: boolean | User$engagementEventsArgs<ExtArgs>
    roomsHosted?: boolean | User$roomsHostedArgs<ExtArgs>
    roomMemberships?: boolean | User$roomMembershipsArgs<ExtArgs>
    flagsOpened?: boolean | User$flagsOpenedArgs<ExtArgs>
    flagsResolved?: boolean | User$flagsResolvedArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    longevityPlans?: boolean | User$longevityPlansArgs<ExtArgs>
    longevityPlanJobs?: boolean | User$longevityPlanJobsArgs<ExtArgs>
    aiResponseAudits?: boolean | User$aiResponseAuditsArgs<ExtArgs>
    loginAudits?: boolean | User$loginAuditsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      authProviders: Prisma.$AuthProviderPayload<ExtArgs>[]
      whoopIntegration: Prisma.$WhoopIntegrationPayload<ExtArgs> | null
      whoopLinkSessions: Prisma.$WhoopLinkSessionPayload<ExtArgs>[]
      insights: Prisma.$InsightPayload<ExtArgs>[]
      insightActions: Prisma.$InsightActionPayload<ExtArgs>[]
      insightGenerationJobs: Prisma.$InsightGenerationJobPayload<ExtArgs>[]
      biomarkerLogs: Prisma.$BiomarkerLogPayload<ExtArgs>[]
      panelUploads: Prisma.$PanelUploadPayload<ExtArgs>[]
      biomarkerMeasurements: Prisma.$BiomarkerMeasurementPayload<ExtArgs>[]
      feedPosts: Prisma.$FeedPostPayload<ExtArgs>[]
      comments: Prisma.$CommentPayload<ExtArgs>[]
      reactions: Prisma.$ReactionPayload<ExtArgs>[]
      engagementEvents: Prisma.$EngagementEventPayload<ExtArgs>[]
      roomsHosted: Prisma.$RoomPayload<ExtArgs>[]
      roomMemberships: Prisma.$RoomMembershipPayload<ExtArgs>[]
      flagsOpened: Prisma.$FlagPayload<ExtArgs>[]
      flagsResolved: Prisma.$FlagPayload<ExtArgs>[]
      auditLogs: Prisma.$AdminAuditLogPayload<ExtArgs>[]
      longevityPlans: Prisma.$LongevityPlanPayload<ExtArgs>[]
      longevityPlanJobs: Prisma.$LongevityPlanJobPayload<ExtArgs>[]
      aiResponseAudits: Prisma.$AiResponseAuditPayload<ExtArgs>[]
      loginAudits: Prisma.$LoginAuditPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string | null
      fullName: string | null
      role: $Enums.Role
      status: $Enums.UserStatus
      whoopMemberId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    authProviders<T extends User$authProvidersArgs<ExtArgs> = {}>(args?: Subset<T, User$authProvidersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "findMany"> | Null>
    whoopIntegration<T extends User$whoopIntegrationArgs<ExtArgs> = {}>(args?: Subset<T, User$whoopIntegrationArgs<ExtArgs>>): Prisma__WhoopIntegrationClient<$Result.GetResult<Prisma.$WhoopIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    whoopLinkSessions<T extends User$whoopLinkSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$whoopLinkSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhoopLinkSessionPayload<ExtArgs>, T, "findMany"> | Null>
    insights<T extends User$insightsArgs<ExtArgs> = {}>(args?: Subset<T, User$insightsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findMany"> | Null>
    insightActions<T extends User$insightActionsArgs<ExtArgs> = {}>(args?: Subset<T, User$insightActionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightActionPayload<ExtArgs>, T, "findMany"> | Null>
    insightGenerationJobs<T extends User$insightGenerationJobsArgs<ExtArgs> = {}>(args?: Subset<T, User$insightGenerationJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightGenerationJobPayload<ExtArgs>, T, "findMany"> | Null>
    biomarkerLogs<T extends User$biomarkerLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$biomarkerLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomarkerLogPayload<ExtArgs>, T, "findMany"> | Null>
    panelUploads<T extends User$panelUploadsArgs<ExtArgs> = {}>(args?: Subset<T, User$panelUploadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PanelUploadPayload<ExtArgs>, T, "findMany"> | Null>
    biomarkerMeasurements<T extends User$biomarkerMeasurementsArgs<ExtArgs> = {}>(args?: Subset<T, User$biomarkerMeasurementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomarkerMeasurementPayload<ExtArgs>, T, "findMany"> | Null>
    feedPosts<T extends User$feedPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$feedPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedPostPayload<ExtArgs>, T, "findMany"> | Null>
    comments<T extends User$commentsArgs<ExtArgs> = {}>(args?: Subset<T, User$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    reactions<T extends User$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany"> | Null>
    engagementEvents<T extends User$engagementEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$engagementEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EngagementEventPayload<ExtArgs>, T, "findMany"> | Null>
    roomsHosted<T extends User$roomsHostedArgs<ExtArgs> = {}>(args?: Subset<T, User$roomsHostedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany"> | Null>
    roomMemberships<T extends User$roomMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$roomMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "findMany"> | Null>
    flagsOpened<T extends User$flagsOpenedArgs<ExtArgs> = {}>(args?: Subset<T, User$flagsOpenedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "findMany"> | Null>
    flagsResolved<T extends User$flagsResolvedArgs<ExtArgs> = {}>(args?: Subset<T, User$flagsResolvedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "findMany"> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    longevityPlans<T extends User$longevityPlansArgs<ExtArgs> = {}>(args?: Subset<T, User$longevityPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LongevityPlanPayload<ExtArgs>, T, "findMany"> | Null>
    longevityPlanJobs<T extends User$longevityPlanJobsArgs<ExtArgs> = {}>(args?: Subset<T, User$longevityPlanJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LongevityPlanJobPayload<ExtArgs>, T, "findMany"> | Null>
    aiResponseAudits<T extends User$aiResponseAuditsArgs<ExtArgs> = {}>(args?: Subset<T, User$aiResponseAuditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiResponseAuditPayload<ExtArgs>, T, "findMany"> | Null>
    loginAudits<T extends User$loginAuditsArgs<ExtArgs> = {}>(args?: Subset<T, User$loginAuditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly status: FieldRef<"User", 'UserStatus'>
    readonly whoopMemberId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User.authProviders
   */
  export type User$authProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    where?: AuthProviderWhereInput
    orderBy?: AuthProviderOrderByWithRelationInput | AuthProviderOrderByWithRelationInput[]
    cursor?: AuthProviderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuthProviderScalarFieldEnum | AuthProviderScalarFieldEnum[]
  }

  /**
   * User.whoopIntegration
   */
  export type User$whoopIntegrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopIntegration
     */
    select?: WhoopIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopIntegrationInclude<ExtArgs> | null
    where?: WhoopIntegrationWhereInput
  }

  /**
   * User.whoopLinkSessions
   */
  export type User$whoopLinkSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopLinkSession
     */
    select?: WhoopLinkSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopLinkSessionInclude<ExtArgs> | null
    where?: WhoopLinkSessionWhereInput
    orderBy?: WhoopLinkSessionOrderByWithRelationInput | WhoopLinkSessionOrderByWithRelationInput[]
    cursor?: WhoopLinkSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WhoopLinkSessionScalarFieldEnum | WhoopLinkSessionScalarFieldEnum[]
  }

  /**
   * User.insights
   */
  export type User$insightsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    where?: InsightWhereInput
    orderBy?: InsightOrderByWithRelationInput | InsightOrderByWithRelationInput[]
    cursor?: InsightWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsightScalarFieldEnum | InsightScalarFieldEnum[]
  }

  /**
   * User.insightActions
   */
  export type User$insightActionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightAction
     */
    select?: InsightActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightActionInclude<ExtArgs> | null
    where?: InsightActionWhereInput
    orderBy?: InsightActionOrderByWithRelationInput | InsightActionOrderByWithRelationInput[]
    cursor?: InsightActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsightActionScalarFieldEnum | InsightActionScalarFieldEnum[]
  }

  /**
   * User.insightGenerationJobs
   */
  export type User$insightGenerationJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightGenerationJob
     */
    select?: InsightGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightGenerationJobInclude<ExtArgs> | null
    where?: InsightGenerationJobWhereInput
    orderBy?: InsightGenerationJobOrderByWithRelationInput | InsightGenerationJobOrderByWithRelationInput[]
    cursor?: InsightGenerationJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsightGenerationJobScalarFieldEnum | InsightGenerationJobScalarFieldEnum[]
  }

  /**
   * User.biomarkerLogs
   */
  export type User$biomarkerLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerLog
     */
    select?: BiomarkerLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerLogInclude<ExtArgs> | null
    where?: BiomarkerLogWhereInput
    orderBy?: BiomarkerLogOrderByWithRelationInput | BiomarkerLogOrderByWithRelationInput[]
    cursor?: BiomarkerLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BiomarkerLogScalarFieldEnum | BiomarkerLogScalarFieldEnum[]
  }

  /**
   * User.panelUploads
   */
  export type User$panelUploadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanelUpload
     */
    select?: PanelUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanelUploadInclude<ExtArgs> | null
    where?: PanelUploadWhereInput
    orderBy?: PanelUploadOrderByWithRelationInput | PanelUploadOrderByWithRelationInput[]
    cursor?: PanelUploadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PanelUploadScalarFieldEnum | PanelUploadScalarFieldEnum[]
  }

  /**
   * User.biomarkerMeasurements
   */
  export type User$biomarkerMeasurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerMeasurement
     */
    select?: BiomarkerMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerMeasurementInclude<ExtArgs> | null
    where?: BiomarkerMeasurementWhereInput
    orderBy?: BiomarkerMeasurementOrderByWithRelationInput | BiomarkerMeasurementOrderByWithRelationInput[]
    cursor?: BiomarkerMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BiomarkerMeasurementScalarFieldEnum | BiomarkerMeasurementScalarFieldEnum[]
  }

  /**
   * User.feedPosts
   */
  export type User$feedPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPost
     */
    select?: FeedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPostInclude<ExtArgs> | null
    where?: FeedPostWhereInput
    orderBy?: FeedPostOrderByWithRelationInput | FeedPostOrderByWithRelationInput[]
    cursor?: FeedPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedPostScalarFieldEnum | FeedPostScalarFieldEnum[]
  }

  /**
   * User.comments
   */
  export type User$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * User.reactions
   */
  export type User$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    cursor?: ReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * User.engagementEvents
   */
  export type User$engagementEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementEvent
     */
    select?: EngagementEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementEventInclude<ExtArgs> | null
    where?: EngagementEventWhereInput
    orderBy?: EngagementEventOrderByWithRelationInput | EngagementEventOrderByWithRelationInput[]
    cursor?: EngagementEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EngagementEventScalarFieldEnum | EngagementEventScalarFieldEnum[]
  }

  /**
   * User.roomsHosted
   */
  export type User$roomsHostedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * User.roomMemberships
   */
  export type User$roomMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    where?: RoomMembershipWhereInput
    orderBy?: RoomMembershipOrderByWithRelationInput | RoomMembershipOrderByWithRelationInput[]
    cursor?: RoomMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomMembershipScalarFieldEnum | RoomMembershipScalarFieldEnum[]
  }

  /**
   * User.flagsOpened
   */
  export type User$flagsOpenedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    where?: FlagWhereInput
    orderBy?: FlagOrderByWithRelationInput | FlagOrderByWithRelationInput[]
    cursor?: FlagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlagScalarFieldEnum | FlagScalarFieldEnum[]
  }

  /**
   * User.flagsResolved
   */
  export type User$flagsResolvedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    where?: FlagWhereInput
    orderBy?: FlagOrderByWithRelationInput | FlagOrderByWithRelationInput[]
    cursor?: FlagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlagScalarFieldEnum | FlagScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    where?: AdminAuditLogWhereInput
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    cursor?: AdminAuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * User.longevityPlans
   */
  export type User$longevityPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlan
     */
    select?: LongevityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanInclude<ExtArgs> | null
    where?: LongevityPlanWhereInput
    orderBy?: LongevityPlanOrderByWithRelationInput | LongevityPlanOrderByWithRelationInput[]
    cursor?: LongevityPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LongevityPlanScalarFieldEnum | LongevityPlanScalarFieldEnum[]
  }

  /**
   * User.longevityPlanJobs
   */
  export type User$longevityPlanJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlanJob
     */
    select?: LongevityPlanJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanJobInclude<ExtArgs> | null
    where?: LongevityPlanJobWhereInput
    orderBy?: LongevityPlanJobOrderByWithRelationInput | LongevityPlanJobOrderByWithRelationInput[]
    cursor?: LongevityPlanJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LongevityPlanJobScalarFieldEnum | LongevityPlanJobScalarFieldEnum[]
  }

  /**
   * User.aiResponseAudits
   */
  export type User$aiResponseAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiResponseAudit
     */
    select?: AiResponseAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiResponseAuditInclude<ExtArgs> | null
    where?: AiResponseAuditWhereInput
    orderBy?: AiResponseAuditOrderByWithRelationInput | AiResponseAuditOrderByWithRelationInput[]
    cursor?: AiResponseAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiResponseAuditScalarFieldEnum | AiResponseAuditScalarFieldEnum[]
  }

  /**
   * User.loginAudits
   */
  export type User$loginAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    where?: LoginAuditWhereInput
    orderBy?: LoginAuditOrderByWithRelationInput | LoginAuditOrderByWithRelationInput[]
    cursor?: LoginAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LoginAuditScalarFieldEnum | LoginAuditScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    displayName: string | null
    timezone: string | null
    onboardingCompletedAt: Date | null
    deleteRequested: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    displayName: string | null
    timezone: string | null
    onboardingCompletedAt: Date | null
    deleteRequested: boolean | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    displayName: number
    timezone: number
    baselineSurvey: number
    consents: number
    onboardingCompletedAt: number
    deleteRequested: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    timezone?: true
    onboardingCompletedAt?: true
    deleteRequested?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    timezone?: true
    onboardingCompletedAt?: true
    deleteRequested?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    displayName?: true
    timezone?: true
    baselineSurvey?: true
    consents?: true
    onboardingCompletedAt?: true
    deleteRequested?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    displayName: string
    timezone: string
    baselineSurvey: JsonValue | null
    consents: JsonValue | null
    onboardingCompletedAt: Date | null
    deleteRequested: boolean
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    timezone?: boolean
    baselineSurvey?: boolean
    consents?: boolean
    onboardingCompletedAt?: boolean
    deleteRequested?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    displayName?: boolean
    timezone?: boolean
    baselineSurvey?: boolean
    consents?: boolean
    onboardingCompletedAt?: boolean
    deleteRequested?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    displayName?: boolean
    timezone?: boolean
    baselineSurvey?: boolean
    consents?: boolean
    onboardingCompletedAt?: boolean
    deleteRequested?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      displayName: string
      timezone: string
      baselineSurvey: Prisma.JsonValue | null
      consents: Prisma.JsonValue | null
      onboardingCompletedAt: Date | null
      deleteRequested: boolean
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */ 
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly displayName: FieldRef<"Profile", 'String'>
    readonly timezone: FieldRef<"Profile", 'String'>
    readonly baselineSurvey: FieldRef<"Profile", 'Json'>
    readonly consents: FieldRef<"Profile", 'Json'>
    readonly onboardingCompletedAt: FieldRef<"Profile", 'DateTime'>
    readonly deleteRequested: FieldRef<"Profile", 'Boolean'>
    readonly deletedAt: FieldRef<"Profile", 'DateTime'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model Insight
   */

  export type AggregateInsight = {
    _count: InsightCountAggregateOutputType | null
    _min: InsightMinAggregateOutputType | null
    _max: InsightMaxAggregateOutputType | null
  }

  export type InsightMinAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    summary: string | null
    modelUsed: string | null
    status: $Enums.InsightStatus | null
    generatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InsightMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    title: string | null
    summary: string | null
    modelUsed: string | null
    status: $Enums.InsightStatus | null
    generatedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InsightCountAggregateOutputType = {
    id: number
    userId: number
    title: number
    summary: number
    body: number
    modelUsed: number
    promptMetadata: number
    status: number
    generatedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InsightMinAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    summary?: true
    modelUsed?: true
    status?: true
    generatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InsightMaxAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    summary?: true
    modelUsed?: true
    status?: true
    generatedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InsightCountAggregateInputType = {
    id?: true
    userId?: true
    title?: true
    summary?: true
    body?: true
    modelUsed?: true
    promptMetadata?: true
    status?: true
    generatedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InsightAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Insight to aggregate.
     */
    where?: InsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insights to fetch.
     */
    orderBy?: InsightOrderByWithRelationInput | InsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Insights
    **/
    _count?: true | InsightCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsightMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsightMaxAggregateInputType
  }

  export type GetInsightAggregateType<T extends InsightAggregateArgs> = {
        [P in keyof T & keyof AggregateInsight]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsight[P]>
      : GetScalarType<T[P], AggregateInsight[P]>
  }




  export type InsightGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightWhereInput
    orderBy?: InsightOrderByWithAggregationInput | InsightOrderByWithAggregationInput[]
    by: InsightScalarFieldEnum[] | InsightScalarFieldEnum
    having?: InsightScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsightCountAggregateInputType | true
    _min?: InsightMinAggregateInputType
    _max?: InsightMaxAggregateInputType
  }

  export type InsightGroupByOutputType = {
    id: string
    userId: string
    title: string
    summary: string
    body: JsonValue | null
    modelUsed: string | null
    promptMetadata: JsonValue | null
    status: $Enums.InsightStatus
    generatedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: InsightCountAggregateOutputType | null
    _min: InsightMinAggregateOutputType | null
    _max: InsightMaxAggregateOutputType | null
  }

  type GetInsightGroupByPayload<T extends InsightGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsightGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsightGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsightGroupByOutputType[P]>
            : GetScalarType<T[P], InsightGroupByOutputType[P]>
        }
      >
    >


  export type InsightSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    summary?: boolean
    body?: boolean
    modelUsed?: boolean
    promptMetadata?: boolean
    status?: boolean
    generatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    actions?: boolean | Insight$actionsArgs<ExtArgs>
    generationJobs?: boolean | Insight$generationJobsArgs<ExtArgs>
    flags?: boolean | Insight$flagsArgs<ExtArgs>
    _count?: boolean | InsightCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insight"]>

  export type InsightSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    title?: boolean
    summary?: boolean
    body?: boolean
    modelUsed?: boolean
    promptMetadata?: boolean
    status?: boolean
    generatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["insight"]>

  export type InsightSelectScalar = {
    id?: boolean
    userId?: boolean
    title?: boolean
    summary?: boolean
    body?: boolean
    modelUsed?: boolean
    promptMetadata?: boolean
    status?: boolean
    generatedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InsightInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    actions?: boolean | Insight$actionsArgs<ExtArgs>
    generationJobs?: boolean | Insight$generationJobsArgs<ExtArgs>
    flags?: boolean | Insight$flagsArgs<ExtArgs>
    _count?: boolean | InsightCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InsightIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InsightPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Insight"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      actions: Prisma.$InsightActionPayload<ExtArgs>[]
      generationJobs: Prisma.$InsightGenerationJobPayload<ExtArgs>[]
      flags: Prisma.$FlagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      title: string
      summary: string
      body: Prisma.JsonValue | null
      modelUsed: string | null
      promptMetadata: Prisma.JsonValue | null
      status: $Enums.InsightStatus
      generatedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["insight"]>
    composites: {}
  }

  type InsightGetPayload<S extends boolean | null | undefined | InsightDefaultArgs> = $Result.GetResult<Prisma.$InsightPayload, S>

  type InsightCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InsightFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InsightCountAggregateInputType | true
    }

  export interface InsightDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Insight'], meta: { name: 'Insight' } }
    /**
     * Find zero or one Insight that matches the filter.
     * @param {InsightFindUniqueArgs} args - Arguments to find a Insight
     * @example
     * // Get one Insight
     * const insight = await prisma.insight.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsightFindUniqueArgs>(args: SelectSubset<T, InsightFindUniqueArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Insight that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InsightFindUniqueOrThrowArgs} args - Arguments to find a Insight
     * @example
     * // Get one Insight
     * const insight = await prisma.insight.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsightFindUniqueOrThrowArgs>(args: SelectSubset<T, InsightFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Insight that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightFindFirstArgs} args - Arguments to find a Insight
     * @example
     * // Get one Insight
     * const insight = await prisma.insight.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsightFindFirstArgs>(args?: SelectSubset<T, InsightFindFirstArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Insight that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightFindFirstOrThrowArgs} args - Arguments to find a Insight
     * @example
     * // Get one Insight
     * const insight = await prisma.insight.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsightFindFirstOrThrowArgs>(args?: SelectSubset<T, InsightFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Insights that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Insights
     * const insights = await prisma.insight.findMany()
     * 
     * // Get first 10 Insights
     * const insights = await prisma.insight.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insightWithIdOnly = await prisma.insight.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsightFindManyArgs>(args?: SelectSubset<T, InsightFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Insight.
     * @param {InsightCreateArgs} args - Arguments to create a Insight.
     * @example
     * // Create one Insight
     * const Insight = await prisma.insight.create({
     *   data: {
     *     // ... data to create a Insight
     *   }
     * })
     * 
     */
    create<T extends InsightCreateArgs>(args: SelectSubset<T, InsightCreateArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Insights.
     * @param {InsightCreateManyArgs} args - Arguments to create many Insights.
     * @example
     * // Create many Insights
     * const insight = await prisma.insight.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsightCreateManyArgs>(args?: SelectSubset<T, InsightCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Insights and returns the data saved in the database.
     * @param {InsightCreateManyAndReturnArgs} args - Arguments to create many Insights.
     * @example
     * // Create many Insights
     * const insight = await prisma.insight.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Insights and only return the `id`
     * const insightWithIdOnly = await prisma.insight.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsightCreateManyAndReturnArgs>(args?: SelectSubset<T, InsightCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Insight.
     * @param {InsightDeleteArgs} args - Arguments to delete one Insight.
     * @example
     * // Delete one Insight
     * const Insight = await prisma.insight.delete({
     *   where: {
     *     // ... filter to delete one Insight
     *   }
     * })
     * 
     */
    delete<T extends InsightDeleteArgs>(args: SelectSubset<T, InsightDeleteArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Insight.
     * @param {InsightUpdateArgs} args - Arguments to update one Insight.
     * @example
     * // Update one Insight
     * const insight = await prisma.insight.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsightUpdateArgs>(args: SelectSubset<T, InsightUpdateArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Insights.
     * @param {InsightDeleteManyArgs} args - Arguments to filter Insights to delete.
     * @example
     * // Delete a few Insights
     * const { count } = await prisma.insight.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsightDeleteManyArgs>(args?: SelectSubset<T, InsightDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Insights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Insights
     * const insight = await prisma.insight.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsightUpdateManyArgs>(args: SelectSubset<T, InsightUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Insight.
     * @param {InsightUpsertArgs} args - Arguments to update or create a Insight.
     * @example
     * // Update or create a Insight
     * const insight = await prisma.insight.upsert({
     *   create: {
     *     // ... data to create a Insight
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Insight we want to update
     *   }
     * })
     */
    upsert<T extends InsightUpsertArgs>(args: SelectSubset<T, InsightUpsertArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Insights.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightCountArgs} args - Arguments to filter Insights to count.
     * @example
     * // Count the number of Insights
     * const count = await prisma.insight.count({
     *   where: {
     *     // ... the filter for the Insights we want to count
     *   }
     * })
    **/
    count<T extends InsightCountArgs>(
      args?: Subset<T, InsightCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsightCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Insight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsightAggregateArgs>(args: Subset<T, InsightAggregateArgs>): Prisma.PrismaPromise<GetInsightAggregateType<T>>

    /**
     * Group by Insight.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsightGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsightGroupByArgs['orderBy'] }
        : { orderBy?: InsightGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsightGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsightGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Insight model
   */
  readonly fields: InsightFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Insight.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsightClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    actions<T extends Insight$actionsArgs<ExtArgs> = {}>(args?: Subset<T, Insight$actionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightActionPayload<ExtArgs>, T, "findMany"> | Null>
    generationJobs<T extends Insight$generationJobsArgs<ExtArgs> = {}>(args?: Subset<T, Insight$generationJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightGenerationJobPayload<ExtArgs>, T, "findMany"> | Null>
    flags<T extends Insight$flagsArgs<ExtArgs> = {}>(args?: Subset<T, Insight$flagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Insight model
   */ 
  interface InsightFieldRefs {
    readonly id: FieldRef<"Insight", 'String'>
    readonly userId: FieldRef<"Insight", 'String'>
    readonly title: FieldRef<"Insight", 'String'>
    readonly summary: FieldRef<"Insight", 'String'>
    readonly body: FieldRef<"Insight", 'Json'>
    readonly modelUsed: FieldRef<"Insight", 'String'>
    readonly promptMetadata: FieldRef<"Insight", 'Json'>
    readonly status: FieldRef<"Insight", 'InsightStatus'>
    readonly generatedAt: FieldRef<"Insight", 'DateTime'>
    readonly createdAt: FieldRef<"Insight", 'DateTime'>
    readonly updatedAt: FieldRef<"Insight", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Insight findUnique
   */
  export type InsightFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * Filter, which Insight to fetch.
     */
    where: InsightWhereUniqueInput
  }

  /**
   * Insight findUniqueOrThrow
   */
  export type InsightFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * Filter, which Insight to fetch.
     */
    where: InsightWhereUniqueInput
  }

  /**
   * Insight findFirst
   */
  export type InsightFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * Filter, which Insight to fetch.
     */
    where?: InsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insights to fetch.
     */
    orderBy?: InsightOrderByWithRelationInput | InsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Insights.
     */
    cursor?: InsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Insights.
     */
    distinct?: InsightScalarFieldEnum | InsightScalarFieldEnum[]
  }

  /**
   * Insight findFirstOrThrow
   */
  export type InsightFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * Filter, which Insight to fetch.
     */
    where?: InsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insights to fetch.
     */
    orderBy?: InsightOrderByWithRelationInput | InsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Insights.
     */
    cursor?: InsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insights.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Insights.
     */
    distinct?: InsightScalarFieldEnum | InsightScalarFieldEnum[]
  }

  /**
   * Insight findMany
   */
  export type InsightFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * Filter, which Insights to fetch.
     */
    where?: InsightWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Insights to fetch.
     */
    orderBy?: InsightOrderByWithRelationInput | InsightOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Insights.
     */
    cursor?: InsightWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Insights from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Insights.
     */
    skip?: number
    distinct?: InsightScalarFieldEnum | InsightScalarFieldEnum[]
  }

  /**
   * Insight create
   */
  export type InsightCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * The data needed to create a Insight.
     */
    data: XOR<InsightCreateInput, InsightUncheckedCreateInput>
  }

  /**
   * Insight createMany
   */
  export type InsightCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Insights.
     */
    data: InsightCreateManyInput | InsightCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Insight createManyAndReturn
   */
  export type InsightCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Insights.
     */
    data: InsightCreateManyInput | InsightCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Insight update
   */
  export type InsightUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * The data needed to update a Insight.
     */
    data: XOR<InsightUpdateInput, InsightUncheckedUpdateInput>
    /**
     * Choose, which Insight to update.
     */
    where: InsightWhereUniqueInput
  }

  /**
   * Insight updateMany
   */
  export type InsightUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Insights.
     */
    data: XOR<InsightUpdateManyMutationInput, InsightUncheckedUpdateManyInput>
    /**
     * Filter which Insights to update
     */
    where?: InsightWhereInput
  }

  /**
   * Insight upsert
   */
  export type InsightUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * The filter to search for the Insight to update in case it exists.
     */
    where: InsightWhereUniqueInput
    /**
     * In case the Insight found by the `where` argument doesn't exist, create a new Insight with this data.
     */
    create: XOR<InsightCreateInput, InsightUncheckedCreateInput>
    /**
     * In case the Insight was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsightUpdateInput, InsightUncheckedUpdateInput>
  }

  /**
   * Insight delete
   */
  export type InsightDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    /**
     * Filter which Insight to delete.
     */
    where: InsightWhereUniqueInput
  }

  /**
   * Insight deleteMany
   */
  export type InsightDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Insights to delete
     */
    where?: InsightWhereInput
  }

  /**
   * Insight.actions
   */
  export type Insight$actionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightAction
     */
    select?: InsightActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightActionInclude<ExtArgs> | null
    where?: InsightActionWhereInput
    orderBy?: InsightActionOrderByWithRelationInput | InsightActionOrderByWithRelationInput[]
    cursor?: InsightActionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsightActionScalarFieldEnum | InsightActionScalarFieldEnum[]
  }

  /**
   * Insight.generationJobs
   */
  export type Insight$generationJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightGenerationJob
     */
    select?: InsightGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightGenerationJobInclude<ExtArgs> | null
    where?: InsightGenerationJobWhereInput
    orderBy?: InsightGenerationJobOrderByWithRelationInput | InsightGenerationJobOrderByWithRelationInput[]
    cursor?: InsightGenerationJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InsightGenerationJobScalarFieldEnum | InsightGenerationJobScalarFieldEnum[]
  }

  /**
   * Insight.flags
   */
  export type Insight$flagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    where?: FlagWhereInput
    orderBy?: FlagOrderByWithRelationInput | FlagOrderByWithRelationInput[]
    cursor?: FlagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlagScalarFieldEnum | FlagScalarFieldEnum[]
  }

  /**
   * Insight without action
   */
  export type InsightDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
  }


  /**
   * Model LongevityPlan
   */

  export type AggregateLongevityPlan = {
    _count: LongevityPlanCountAggregateOutputType | null
    _min: LongevityPlanMinAggregateOutputType | null
    _max: LongevityPlanMaxAggregateOutputType | null
  }

  export type LongevityPlanMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.LongevityPlanStatus | null
    title: string | null
    summary: string | null
    validatedBy: string | null
    validatedAt: Date | null
    requestedAt: Date | null
    completedAt: Date | null
    errorCode: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LongevityPlanMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.LongevityPlanStatus | null
    title: string | null
    summary: string | null
    validatedBy: string | null
    validatedAt: Date | null
    requestedAt: Date | null
    completedAt: Date | null
    errorCode: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LongevityPlanCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    title: number
    summary: number
    focusAreas: number
    sections: number
    evidence: number
    safetyState: number
    validatedBy: number
    validatedAt: number
    requestedAt: number
    completedAt: number
    errorCode: number
    errorMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LongevityPlanMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    title?: true
    summary?: true
    validatedBy?: true
    validatedAt?: true
    requestedAt?: true
    completedAt?: true
    errorCode?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LongevityPlanMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    title?: true
    summary?: true
    validatedBy?: true
    validatedAt?: true
    requestedAt?: true
    completedAt?: true
    errorCode?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LongevityPlanCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    title?: true
    summary?: true
    focusAreas?: true
    sections?: true
    evidence?: true
    safetyState?: true
    validatedBy?: true
    validatedAt?: true
    requestedAt?: true
    completedAt?: true
    errorCode?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LongevityPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LongevityPlan to aggregate.
     */
    where?: LongevityPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LongevityPlans to fetch.
     */
    orderBy?: LongevityPlanOrderByWithRelationInput | LongevityPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LongevityPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LongevityPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LongevityPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LongevityPlans
    **/
    _count?: true | LongevityPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LongevityPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LongevityPlanMaxAggregateInputType
  }

  export type GetLongevityPlanAggregateType<T extends LongevityPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateLongevityPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLongevityPlan[P]>
      : GetScalarType<T[P], AggregateLongevityPlan[P]>
  }




  export type LongevityPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LongevityPlanWhereInput
    orderBy?: LongevityPlanOrderByWithAggregationInput | LongevityPlanOrderByWithAggregationInput[]
    by: LongevityPlanScalarFieldEnum[] | LongevityPlanScalarFieldEnum
    having?: LongevityPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LongevityPlanCountAggregateInputType | true
    _min?: LongevityPlanMinAggregateInputType
    _max?: LongevityPlanMaxAggregateInputType
  }

  export type LongevityPlanGroupByOutputType = {
    id: string
    userId: string
    status: $Enums.LongevityPlanStatus
    title: string
    summary: string | null
    focusAreas: string[]
    sections: JsonValue | null
    evidence: JsonValue | null
    safetyState: JsonValue | null
    validatedBy: string | null
    validatedAt: Date | null
    requestedAt: Date
    completedAt: Date | null
    errorCode: string | null
    errorMessage: string | null
    createdAt: Date
    updatedAt: Date
    _count: LongevityPlanCountAggregateOutputType | null
    _min: LongevityPlanMinAggregateOutputType | null
    _max: LongevityPlanMaxAggregateOutputType | null
  }

  type GetLongevityPlanGroupByPayload<T extends LongevityPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LongevityPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LongevityPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LongevityPlanGroupByOutputType[P]>
            : GetScalarType<T[P], LongevityPlanGroupByOutputType[P]>
        }
      >
    >


  export type LongevityPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    title?: boolean
    summary?: boolean
    focusAreas?: boolean
    sections?: boolean
    evidence?: boolean
    safetyState?: boolean
    validatedBy?: boolean
    validatedAt?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    jobs?: boolean | LongevityPlan$jobsArgs<ExtArgs>
    audits?: boolean | LongevityPlan$auditsArgs<ExtArgs>
    _count?: boolean | LongevityPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["longevityPlan"]>

  export type LongevityPlanSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    title?: boolean
    summary?: boolean
    focusAreas?: boolean
    sections?: boolean
    evidence?: boolean
    safetyState?: boolean
    validatedBy?: boolean
    validatedAt?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["longevityPlan"]>

  export type LongevityPlanSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    title?: boolean
    summary?: boolean
    focusAreas?: boolean
    sections?: boolean
    evidence?: boolean
    safetyState?: boolean
    validatedBy?: boolean
    validatedAt?: boolean
    requestedAt?: boolean
    completedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LongevityPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    jobs?: boolean | LongevityPlan$jobsArgs<ExtArgs>
    audits?: boolean | LongevityPlan$auditsArgs<ExtArgs>
    _count?: boolean | LongevityPlanCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LongevityPlanIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LongevityPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LongevityPlan"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      jobs: Prisma.$LongevityPlanJobPayload<ExtArgs>[]
      audits: Prisma.$AiResponseAuditPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: $Enums.LongevityPlanStatus
      title: string
      summary: string | null
      focusAreas: string[]
      sections: Prisma.JsonValue | null
      evidence: Prisma.JsonValue | null
      safetyState: Prisma.JsonValue | null
      validatedBy: string | null
      validatedAt: Date | null
      requestedAt: Date
      completedAt: Date | null
      errorCode: string | null
      errorMessage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["longevityPlan"]>
    composites: {}
  }

  type LongevityPlanGetPayload<S extends boolean | null | undefined | LongevityPlanDefaultArgs> = $Result.GetResult<Prisma.$LongevityPlanPayload, S>

  type LongevityPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LongevityPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LongevityPlanCountAggregateInputType | true
    }

  export interface LongevityPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LongevityPlan'], meta: { name: 'LongevityPlan' } }
    /**
     * Find zero or one LongevityPlan that matches the filter.
     * @param {LongevityPlanFindUniqueArgs} args - Arguments to find a LongevityPlan
     * @example
     * // Get one LongevityPlan
     * const longevityPlan = await prisma.longevityPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LongevityPlanFindUniqueArgs>(args: SelectSubset<T, LongevityPlanFindUniqueArgs<ExtArgs>>): Prisma__LongevityPlanClient<$Result.GetResult<Prisma.$LongevityPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LongevityPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LongevityPlanFindUniqueOrThrowArgs} args - Arguments to find a LongevityPlan
     * @example
     * // Get one LongevityPlan
     * const longevityPlan = await prisma.longevityPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LongevityPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, LongevityPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LongevityPlanClient<$Result.GetResult<Prisma.$LongevityPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LongevityPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LongevityPlanFindFirstArgs} args - Arguments to find a LongevityPlan
     * @example
     * // Get one LongevityPlan
     * const longevityPlan = await prisma.longevityPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LongevityPlanFindFirstArgs>(args?: SelectSubset<T, LongevityPlanFindFirstArgs<ExtArgs>>): Prisma__LongevityPlanClient<$Result.GetResult<Prisma.$LongevityPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LongevityPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LongevityPlanFindFirstOrThrowArgs} args - Arguments to find a LongevityPlan
     * @example
     * // Get one LongevityPlan
     * const longevityPlan = await prisma.longevityPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LongevityPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, LongevityPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__LongevityPlanClient<$Result.GetResult<Prisma.$LongevityPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LongevityPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LongevityPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LongevityPlans
     * const longevityPlans = await prisma.longevityPlan.findMany()
     * 
     * // Get first 10 LongevityPlans
     * const longevityPlans = await prisma.longevityPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const longevityPlanWithIdOnly = await prisma.longevityPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LongevityPlanFindManyArgs>(args?: SelectSubset<T, LongevityPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LongevityPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LongevityPlan.
     * @param {LongevityPlanCreateArgs} args - Arguments to create a LongevityPlan.
     * @example
     * // Create one LongevityPlan
     * const LongevityPlan = await prisma.longevityPlan.create({
     *   data: {
     *     // ... data to create a LongevityPlan
     *   }
     * })
     * 
     */
    create<T extends LongevityPlanCreateArgs>(args: SelectSubset<T, LongevityPlanCreateArgs<ExtArgs>>): Prisma__LongevityPlanClient<$Result.GetResult<Prisma.$LongevityPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LongevityPlans.
     * @param {LongevityPlanCreateManyArgs} args - Arguments to create many LongevityPlans.
     * @example
     * // Create many LongevityPlans
     * const longevityPlan = await prisma.longevityPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LongevityPlanCreateManyArgs>(args?: SelectSubset<T, LongevityPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LongevityPlans and returns the data saved in the database.
     * @param {LongevityPlanCreateManyAndReturnArgs} args - Arguments to create many LongevityPlans.
     * @example
     * // Create many LongevityPlans
     * const longevityPlan = await prisma.longevityPlan.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LongevityPlans and only return the `id`
     * const longevityPlanWithIdOnly = await prisma.longevityPlan.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LongevityPlanCreateManyAndReturnArgs>(args?: SelectSubset<T, LongevityPlanCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LongevityPlanPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LongevityPlan.
     * @param {LongevityPlanDeleteArgs} args - Arguments to delete one LongevityPlan.
     * @example
     * // Delete one LongevityPlan
     * const LongevityPlan = await prisma.longevityPlan.delete({
     *   where: {
     *     // ... filter to delete one LongevityPlan
     *   }
     * })
     * 
     */
    delete<T extends LongevityPlanDeleteArgs>(args: SelectSubset<T, LongevityPlanDeleteArgs<ExtArgs>>): Prisma__LongevityPlanClient<$Result.GetResult<Prisma.$LongevityPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LongevityPlan.
     * @param {LongevityPlanUpdateArgs} args - Arguments to update one LongevityPlan.
     * @example
     * // Update one LongevityPlan
     * const longevityPlan = await prisma.longevityPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LongevityPlanUpdateArgs>(args: SelectSubset<T, LongevityPlanUpdateArgs<ExtArgs>>): Prisma__LongevityPlanClient<$Result.GetResult<Prisma.$LongevityPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LongevityPlans.
     * @param {LongevityPlanDeleteManyArgs} args - Arguments to filter LongevityPlans to delete.
     * @example
     * // Delete a few LongevityPlans
     * const { count } = await prisma.longevityPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LongevityPlanDeleteManyArgs>(args?: SelectSubset<T, LongevityPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LongevityPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LongevityPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LongevityPlans
     * const longevityPlan = await prisma.longevityPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LongevityPlanUpdateManyArgs>(args: SelectSubset<T, LongevityPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LongevityPlan.
     * @param {LongevityPlanUpsertArgs} args - Arguments to update or create a LongevityPlan.
     * @example
     * // Update or create a LongevityPlan
     * const longevityPlan = await prisma.longevityPlan.upsert({
     *   create: {
     *     // ... data to create a LongevityPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LongevityPlan we want to update
     *   }
     * })
     */
    upsert<T extends LongevityPlanUpsertArgs>(args: SelectSubset<T, LongevityPlanUpsertArgs<ExtArgs>>): Prisma__LongevityPlanClient<$Result.GetResult<Prisma.$LongevityPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LongevityPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LongevityPlanCountArgs} args - Arguments to filter LongevityPlans to count.
     * @example
     * // Count the number of LongevityPlans
     * const count = await prisma.longevityPlan.count({
     *   where: {
     *     // ... the filter for the LongevityPlans we want to count
     *   }
     * })
    **/
    count<T extends LongevityPlanCountArgs>(
      args?: Subset<T, LongevityPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LongevityPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LongevityPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LongevityPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LongevityPlanAggregateArgs>(args: Subset<T, LongevityPlanAggregateArgs>): Prisma.PrismaPromise<GetLongevityPlanAggregateType<T>>

    /**
     * Group by LongevityPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LongevityPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LongevityPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LongevityPlanGroupByArgs['orderBy'] }
        : { orderBy?: LongevityPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LongevityPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLongevityPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LongevityPlan model
   */
  readonly fields: LongevityPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LongevityPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LongevityPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    jobs<T extends LongevityPlan$jobsArgs<ExtArgs> = {}>(args?: Subset<T, LongevityPlan$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LongevityPlanJobPayload<ExtArgs>, T, "findMany"> | Null>
    audits<T extends LongevityPlan$auditsArgs<ExtArgs> = {}>(args?: Subset<T, LongevityPlan$auditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiResponseAuditPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LongevityPlan model
   */ 
  interface LongevityPlanFieldRefs {
    readonly id: FieldRef<"LongevityPlan", 'String'>
    readonly userId: FieldRef<"LongevityPlan", 'String'>
    readonly status: FieldRef<"LongevityPlan", 'LongevityPlanStatus'>
    readonly title: FieldRef<"LongevityPlan", 'String'>
    readonly summary: FieldRef<"LongevityPlan", 'String'>
    readonly focusAreas: FieldRef<"LongevityPlan", 'String[]'>
    readonly sections: FieldRef<"LongevityPlan", 'Json'>
    readonly evidence: FieldRef<"LongevityPlan", 'Json'>
    readonly safetyState: FieldRef<"LongevityPlan", 'Json'>
    readonly validatedBy: FieldRef<"LongevityPlan", 'String'>
    readonly validatedAt: FieldRef<"LongevityPlan", 'DateTime'>
    readonly requestedAt: FieldRef<"LongevityPlan", 'DateTime'>
    readonly completedAt: FieldRef<"LongevityPlan", 'DateTime'>
    readonly errorCode: FieldRef<"LongevityPlan", 'String'>
    readonly errorMessage: FieldRef<"LongevityPlan", 'String'>
    readonly createdAt: FieldRef<"LongevityPlan", 'DateTime'>
    readonly updatedAt: FieldRef<"LongevityPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LongevityPlan findUnique
   */
  export type LongevityPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlan
     */
    select?: LongevityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanInclude<ExtArgs> | null
    /**
     * Filter, which LongevityPlan to fetch.
     */
    where: LongevityPlanWhereUniqueInput
  }

  /**
   * LongevityPlan findUniqueOrThrow
   */
  export type LongevityPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlan
     */
    select?: LongevityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanInclude<ExtArgs> | null
    /**
     * Filter, which LongevityPlan to fetch.
     */
    where: LongevityPlanWhereUniqueInput
  }

  /**
   * LongevityPlan findFirst
   */
  export type LongevityPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlan
     */
    select?: LongevityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanInclude<ExtArgs> | null
    /**
     * Filter, which LongevityPlan to fetch.
     */
    where?: LongevityPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LongevityPlans to fetch.
     */
    orderBy?: LongevityPlanOrderByWithRelationInput | LongevityPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LongevityPlans.
     */
    cursor?: LongevityPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LongevityPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LongevityPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LongevityPlans.
     */
    distinct?: LongevityPlanScalarFieldEnum | LongevityPlanScalarFieldEnum[]
  }

  /**
   * LongevityPlan findFirstOrThrow
   */
  export type LongevityPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlan
     */
    select?: LongevityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanInclude<ExtArgs> | null
    /**
     * Filter, which LongevityPlan to fetch.
     */
    where?: LongevityPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LongevityPlans to fetch.
     */
    orderBy?: LongevityPlanOrderByWithRelationInput | LongevityPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LongevityPlans.
     */
    cursor?: LongevityPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LongevityPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LongevityPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LongevityPlans.
     */
    distinct?: LongevityPlanScalarFieldEnum | LongevityPlanScalarFieldEnum[]
  }

  /**
   * LongevityPlan findMany
   */
  export type LongevityPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlan
     */
    select?: LongevityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanInclude<ExtArgs> | null
    /**
     * Filter, which LongevityPlans to fetch.
     */
    where?: LongevityPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LongevityPlans to fetch.
     */
    orderBy?: LongevityPlanOrderByWithRelationInput | LongevityPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LongevityPlans.
     */
    cursor?: LongevityPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LongevityPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LongevityPlans.
     */
    skip?: number
    distinct?: LongevityPlanScalarFieldEnum | LongevityPlanScalarFieldEnum[]
  }

  /**
   * LongevityPlan create
   */
  export type LongevityPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlan
     */
    select?: LongevityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a LongevityPlan.
     */
    data: XOR<LongevityPlanCreateInput, LongevityPlanUncheckedCreateInput>
  }

  /**
   * LongevityPlan createMany
   */
  export type LongevityPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LongevityPlans.
     */
    data: LongevityPlanCreateManyInput | LongevityPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LongevityPlan createManyAndReturn
   */
  export type LongevityPlanCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlan
     */
    select?: LongevityPlanSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LongevityPlans.
     */
    data: LongevityPlanCreateManyInput | LongevityPlanCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LongevityPlan update
   */
  export type LongevityPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlan
     */
    select?: LongevityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a LongevityPlan.
     */
    data: XOR<LongevityPlanUpdateInput, LongevityPlanUncheckedUpdateInput>
    /**
     * Choose, which LongevityPlan to update.
     */
    where: LongevityPlanWhereUniqueInput
  }

  /**
   * LongevityPlan updateMany
   */
  export type LongevityPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LongevityPlans.
     */
    data: XOR<LongevityPlanUpdateManyMutationInput, LongevityPlanUncheckedUpdateManyInput>
    /**
     * Filter which LongevityPlans to update
     */
    where?: LongevityPlanWhereInput
  }

  /**
   * LongevityPlan upsert
   */
  export type LongevityPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlan
     */
    select?: LongevityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the LongevityPlan to update in case it exists.
     */
    where: LongevityPlanWhereUniqueInput
    /**
     * In case the LongevityPlan found by the `where` argument doesn't exist, create a new LongevityPlan with this data.
     */
    create: XOR<LongevityPlanCreateInput, LongevityPlanUncheckedCreateInput>
    /**
     * In case the LongevityPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LongevityPlanUpdateInput, LongevityPlanUncheckedUpdateInput>
  }

  /**
   * LongevityPlan delete
   */
  export type LongevityPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlan
     */
    select?: LongevityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanInclude<ExtArgs> | null
    /**
     * Filter which LongevityPlan to delete.
     */
    where: LongevityPlanWhereUniqueInput
  }

  /**
   * LongevityPlan deleteMany
   */
  export type LongevityPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LongevityPlans to delete
     */
    where?: LongevityPlanWhereInput
  }

  /**
   * LongevityPlan.jobs
   */
  export type LongevityPlan$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlanJob
     */
    select?: LongevityPlanJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanJobInclude<ExtArgs> | null
    where?: LongevityPlanJobWhereInput
    orderBy?: LongevityPlanJobOrderByWithRelationInput | LongevityPlanJobOrderByWithRelationInput[]
    cursor?: LongevityPlanJobWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LongevityPlanJobScalarFieldEnum | LongevityPlanJobScalarFieldEnum[]
  }

  /**
   * LongevityPlan.audits
   */
  export type LongevityPlan$auditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiResponseAudit
     */
    select?: AiResponseAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiResponseAuditInclude<ExtArgs> | null
    where?: AiResponseAuditWhereInput
    orderBy?: AiResponseAuditOrderByWithRelationInput | AiResponseAuditOrderByWithRelationInput[]
    cursor?: AiResponseAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AiResponseAuditScalarFieldEnum | AiResponseAuditScalarFieldEnum[]
  }

  /**
   * LongevityPlan without action
   */
  export type LongevityPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlan
     */
    select?: LongevityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanInclude<ExtArgs> | null
  }


  /**
   * Model Biomarker
   */

  export type AggregateBiomarker = {
    _count: BiomarkerCountAggregateOutputType | null
    _avg: BiomarkerAvgAggregateOutputType | null
    _sum: BiomarkerSumAggregateOutputType | null
    _min: BiomarkerMinAggregateOutputType | null
    _max: BiomarkerMaxAggregateOutputType | null
  }

  export type BiomarkerAvgAggregateOutputType = {
    referenceLow: Decimal | null
    referenceHigh: Decimal | null
  }

  export type BiomarkerSumAggregateOutputType = {
    referenceLow: Decimal | null
    referenceHigh: Decimal | null
  }

  export type BiomarkerMinAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    unit: string | null
    referenceLow: Decimal | null
    referenceHigh: Decimal | null
    source: $Enums.BiomarkerSource | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BiomarkerMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    unit: string | null
    referenceLow: Decimal | null
    referenceHigh: Decimal | null
    source: $Enums.BiomarkerSource | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BiomarkerCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    unit: number
    referenceLow: number
    referenceHigh: number
    source: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BiomarkerAvgAggregateInputType = {
    referenceLow?: true
    referenceHigh?: true
  }

  export type BiomarkerSumAggregateInputType = {
    referenceLow?: true
    referenceHigh?: true
  }

  export type BiomarkerMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    unit?: true
    referenceLow?: true
    referenceHigh?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BiomarkerMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    unit?: true
    referenceLow?: true
    referenceHigh?: true
    source?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BiomarkerCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    unit?: true
    referenceLow?: true
    referenceHigh?: true
    source?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BiomarkerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Biomarker to aggregate.
     */
    where?: BiomarkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Biomarkers to fetch.
     */
    orderBy?: BiomarkerOrderByWithRelationInput | BiomarkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BiomarkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Biomarkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Biomarkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Biomarkers
    **/
    _count?: true | BiomarkerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BiomarkerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BiomarkerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BiomarkerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BiomarkerMaxAggregateInputType
  }

  export type GetBiomarkerAggregateType<T extends BiomarkerAggregateArgs> = {
        [P in keyof T & keyof AggregateBiomarker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBiomarker[P]>
      : GetScalarType<T[P], AggregateBiomarker[P]>
  }




  export type BiomarkerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiomarkerWhereInput
    orderBy?: BiomarkerOrderByWithAggregationInput | BiomarkerOrderByWithAggregationInput[]
    by: BiomarkerScalarFieldEnum[] | BiomarkerScalarFieldEnum
    having?: BiomarkerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BiomarkerCountAggregateInputType | true
    _avg?: BiomarkerAvgAggregateInputType
    _sum?: BiomarkerSumAggregateInputType
    _min?: BiomarkerMinAggregateInputType
    _max?: BiomarkerMaxAggregateInputType
  }

  export type BiomarkerGroupByOutputType = {
    id: string
    slug: string
    name: string
    unit: string
    referenceLow: Decimal | null
    referenceHigh: Decimal | null
    source: $Enums.BiomarkerSource
    createdAt: Date
    updatedAt: Date
    _count: BiomarkerCountAggregateOutputType | null
    _avg: BiomarkerAvgAggregateOutputType | null
    _sum: BiomarkerSumAggregateOutputType | null
    _min: BiomarkerMinAggregateOutputType | null
    _max: BiomarkerMaxAggregateOutputType | null
  }

  type GetBiomarkerGroupByPayload<T extends BiomarkerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BiomarkerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BiomarkerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BiomarkerGroupByOutputType[P]>
            : GetScalarType<T[P], BiomarkerGroupByOutputType[P]>
        }
      >
    >


  export type BiomarkerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    unit?: boolean
    referenceLow?: boolean
    referenceHigh?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    logs?: boolean | Biomarker$logsArgs<ExtArgs>
    measurements?: boolean | Biomarker$measurementsArgs<ExtArgs>
    _count?: boolean | BiomarkerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["biomarker"]>

  export type BiomarkerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    unit?: boolean
    referenceLow?: boolean
    referenceHigh?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["biomarker"]>

  export type BiomarkerSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    unit?: boolean
    referenceLow?: boolean
    referenceHigh?: boolean
    source?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BiomarkerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    logs?: boolean | Biomarker$logsArgs<ExtArgs>
    measurements?: boolean | Biomarker$measurementsArgs<ExtArgs>
    _count?: boolean | BiomarkerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BiomarkerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BiomarkerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Biomarker"
    objects: {
      logs: Prisma.$BiomarkerLogPayload<ExtArgs>[]
      measurements: Prisma.$BiomarkerMeasurementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      slug: string
      name: string
      unit: string
      referenceLow: Prisma.Decimal | null
      referenceHigh: Prisma.Decimal | null
      source: $Enums.BiomarkerSource
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["biomarker"]>
    composites: {}
  }

  type BiomarkerGetPayload<S extends boolean | null | undefined | BiomarkerDefaultArgs> = $Result.GetResult<Prisma.$BiomarkerPayload, S>

  type BiomarkerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BiomarkerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BiomarkerCountAggregateInputType | true
    }

  export interface BiomarkerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Biomarker'], meta: { name: 'Biomarker' } }
    /**
     * Find zero or one Biomarker that matches the filter.
     * @param {BiomarkerFindUniqueArgs} args - Arguments to find a Biomarker
     * @example
     * // Get one Biomarker
     * const biomarker = await prisma.biomarker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BiomarkerFindUniqueArgs>(args: SelectSubset<T, BiomarkerFindUniqueArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Biomarker that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BiomarkerFindUniqueOrThrowArgs} args - Arguments to find a Biomarker
     * @example
     * // Get one Biomarker
     * const biomarker = await prisma.biomarker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BiomarkerFindUniqueOrThrowArgs>(args: SelectSubset<T, BiomarkerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Biomarker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerFindFirstArgs} args - Arguments to find a Biomarker
     * @example
     * // Get one Biomarker
     * const biomarker = await prisma.biomarker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BiomarkerFindFirstArgs>(args?: SelectSubset<T, BiomarkerFindFirstArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Biomarker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerFindFirstOrThrowArgs} args - Arguments to find a Biomarker
     * @example
     * // Get one Biomarker
     * const biomarker = await prisma.biomarker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BiomarkerFindFirstOrThrowArgs>(args?: SelectSubset<T, BiomarkerFindFirstOrThrowArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Biomarkers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Biomarkers
     * const biomarkers = await prisma.biomarker.findMany()
     * 
     * // Get first 10 Biomarkers
     * const biomarkers = await prisma.biomarker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const biomarkerWithIdOnly = await prisma.biomarker.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BiomarkerFindManyArgs>(args?: SelectSubset<T, BiomarkerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Biomarker.
     * @param {BiomarkerCreateArgs} args - Arguments to create a Biomarker.
     * @example
     * // Create one Biomarker
     * const Biomarker = await prisma.biomarker.create({
     *   data: {
     *     // ... data to create a Biomarker
     *   }
     * })
     * 
     */
    create<T extends BiomarkerCreateArgs>(args: SelectSubset<T, BiomarkerCreateArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Biomarkers.
     * @param {BiomarkerCreateManyArgs} args - Arguments to create many Biomarkers.
     * @example
     * // Create many Biomarkers
     * const biomarker = await prisma.biomarker.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BiomarkerCreateManyArgs>(args?: SelectSubset<T, BiomarkerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Biomarkers and returns the data saved in the database.
     * @param {BiomarkerCreateManyAndReturnArgs} args - Arguments to create many Biomarkers.
     * @example
     * // Create many Biomarkers
     * const biomarker = await prisma.biomarker.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Biomarkers and only return the `id`
     * const biomarkerWithIdOnly = await prisma.biomarker.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BiomarkerCreateManyAndReturnArgs>(args?: SelectSubset<T, BiomarkerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Biomarker.
     * @param {BiomarkerDeleteArgs} args - Arguments to delete one Biomarker.
     * @example
     * // Delete one Biomarker
     * const Biomarker = await prisma.biomarker.delete({
     *   where: {
     *     // ... filter to delete one Biomarker
     *   }
     * })
     * 
     */
    delete<T extends BiomarkerDeleteArgs>(args: SelectSubset<T, BiomarkerDeleteArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Biomarker.
     * @param {BiomarkerUpdateArgs} args - Arguments to update one Biomarker.
     * @example
     * // Update one Biomarker
     * const biomarker = await prisma.biomarker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BiomarkerUpdateArgs>(args: SelectSubset<T, BiomarkerUpdateArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Biomarkers.
     * @param {BiomarkerDeleteManyArgs} args - Arguments to filter Biomarkers to delete.
     * @example
     * // Delete a few Biomarkers
     * const { count } = await prisma.biomarker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BiomarkerDeleteManyArgs>(args?: SelectSubset<T, BiomarkerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Biomarkers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Biomarkers
     * const biomarker = await prisma.biomarker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BiomarkerUpdateManyArgs>(args: SelectSubset<T, BiomarkerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Biomarker.
     * @param {BiomarkerUpsertArgs} args - Arguments to update or create a Biomarker.
     * @example
     * // Update or create a Biomarker
     * const biomarker = await prisma.biomarker.upsert({
     *   create: {
     *     // ... data to create a Biomarker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Biomarker we want to update
     *   }
     * })
     */
    upsert<T extends BiomarkerUpsertArgs>(args: SelectSubset<T, BiomarkerUpsertArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Biomarkers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerCountArgs} args - Arguments to filter Biomarkers to count.
     * @example
     * // Count the number of Biomarkers
     * const count = await prisma.biomarker.count({
     *   where: {
     *     // ... the filter for the Biomarkers we want to count
     *   }
     * })
    **/
    count<T extends BiomarkerCountArgs>(
      args?: Subset<T, BiomarkerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BiomarkerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Biomarker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BiomarkerAggregateArgs>(args: Subset<T, BiomarkerAggregateArgs>): Prisma.PrismaPromise<GetBiomarkerAggregateType<T>>

    /**
     * Group by Biomarker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BiomarkerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BiomarkerGroupByArgs['orderBy'] }
        : { orderBy?: BiomarkerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BiomarkerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBiomarkerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Biomarker model
   */
  readonly fields: BiomarkerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Biomarker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BiomarkerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    logs<T extends Biomarker$logsArgs<ExtArgs> = {}>(args?: Subset<T, Biomarker$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomarkerLogPayload<ExtArgs>, T, "findMany"> | Null>
    measurements<T extends Biomarker$measurementsArgs<ExtArgs> = {}>(args?: Subset<T, Biomarker$measurementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomarkerMeasurementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Biomarker model
   */ 
  interface BiomarkerFieldRefs {
    readonly id: FieldRef<"Biomarker", 'String'>
    readonly slug: FieldRef<"Biomarker", 'String'>
    readonly name: FieldRef<"Biomarker", 'String'>
    readonly unit: FieldRef<"Biomarker", 'String'>
    readonly referenceLow: FieldRef<"Biomarker", 'Decimal'>
    readonly referenceHigh: FieldRef<"Biomarker", 'Decimal'>
    readonly source: FieldRef<"Biomarker", 'BiomarkerSource'>
    readonly createdAt: FieldRef<"Biomarker", 'DateTime'>
    readonly updatedAt: FieldRef<"Biomarker", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Biomarker findUnique
   */
  export type BiomarkerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
    /**
     * Filter, which Biomarker to fetch.
     */
    where: BiomarkerWhereUniqueInput
  }

  /**
   * Biomarker findUniqueOrThrow
   */
  export type BiomarkerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
    /**
     * Filter, which Biomarker to fetch.
     */
    where: BiomarkerWhereUniqueInput
  }

  /**
   * Biomarker findFirst
   */
  export type BiomarkerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
    /**
     * Filter, which Biomarker to fetch.
     */
    where?: BiomarkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Biomarkers to fetch.
     */
    orderBy?: BiomarkerOrderByWithRelationInput | BiomarkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Biomarkers.
     */
    cursor?: BiomarkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Biomarkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Biomarkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Biomarkers.
     */
    distinct?: BiomarkerScalarFieldEnum | BiomarkerScalarFieldEnum[]
  }

  /**
   * Biomarker findFirstOrThrow
   */
  export type BiomarkerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
    /**
     * Filter, which Biomarker to fetch.
     */
    where?: BiomarkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Biomarkers to fetch.
     */
    orderBy?: BiomarkerOrderByWithRelationInput | BiomarkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Biomarkers.
     */
    cursor?: BiomarkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Biomarkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Biomarkers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Biomarkers.
     */
    distinct?: BiomarkerScalarFieldEnum | BiomarkerScalarFieldEnum[]
  }

  /**
   * Biomarker findMany
   */
  export type BiomarkerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
    /**
     * Filter, which Biomarkers to fetch.
     */
    where?: BiomarkerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Biomarkers to fetch.
     */
    orderBy?: BiomarkerOrderByWithRelationInput | BiomarkerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Biomarkers.
     */
    cursor?: BiomarkerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Biomarkers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Biomarkers.
     */
    skip?: number
    distinct?: BiomarkerScalarFieldEnum | BiomarkerScalarFieldEnum[]
  }

  /**
   * Biomarker create
   */
  export type BiomarkerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
    /**
     * The data needed to create a Biomarker.
     */
    data: XOR<BiomarkerCreateInput, BiomarkerUncheckedCreateInput>
  }

  /**
   * Biomarker createMany
   */
  export type BiomarkerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Biomarkers.
     */
    data: BiomarkerCreateManyInput | BiomarkerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Biomarker createManyAndReturn
   */
  export type BiomarkerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Biomarkers.
     */
    data: BiomarkerCreateManyInput | BiomarkerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Biomarker update
   */
  export type BiomarkerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
    /**
     * The data needed to update a Biomarker.
     */
    data: XOR<BiomarkerUpdateInput, BiomarkerUncheckedUpdateInput>
    /**
     * Choose, which Biomarker to update.
     */
    where: BiomarkerWhereUniqueInput
  }

  /**
   * Biomarker updateMany
   */
  export type BiomarkerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Biomarkers.
     */
    data: XOR<BiomarkerUpdateManyMutationInput, BiomarkerUncheckedUpdateManyInput>
    /**
     * Filter which Biomarkers to update
     */
    where?: BiomarkerWhereInput
  }

  /**
   * Biomarker upsert
   */
  export type BiomarkerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
    /**
     * The filter to search for the Biomarker to update in case it exists.
     */
    where: BiomarkerWhereUniqueInput
    /**
     * In case the Biomarker found by the `where` argument doesn't exist, create a new Biomarker with this data.
     */
    create: XOR<BiomarkerCreateInput, BiomarkerUncheckedCreateInput>
    /**
     * In case the Biomarker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BiomarkerUpdateInput, BiomarkerUncheckedUpdateInput>
  }

  /**
   * Biomarker delete
   */
  export type BiomarkerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
    /**
     * Filter which Biomarker to delete.
     */
    where: BiomarkerWhereUniqueInput
  }

  /**
   * Biomarker deleteMany
   */
  export type BiomarkerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Biomarkers to delete
     */
    where?: BiomarkerWhereInput
  }

  /**
   * Biomarker.logs
   */
  export type Biomarker$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerLog
     */
    select?: BiomarkerLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerLogInclude<ExtArgs> | null
    where?: BiomarkerLogWhereInput
    orderBy?: BiomarkerLogOrderByWithRelationInput | BiomarkerLogOrderByWithRelationInput[]
    cursor?: BiomarkerLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BiomarkerLogScalarFieldEnum | BiomarkerLogScalarFieldEnum[]
  }

  /**
   * Biomarker.measurements
   */
  export type Biomarker$measurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerMeasurement
     */
    select?: BiomarkerMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerMeasurementInclude<ExtArgs> | null
    where?: BiomarkerMeasurementWhereInput
    orderBy?: BiomarkerMeasurementOrderByWithRelationInput | BiomarkerMeasurementOrderByWithRelationInput[]
    cursor?: BiomarkerMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BiomarkerMeasurementScalarFieldEnum | BiomarkerMeasurementScalarFieldEnum[]
  }

  /**
   * Biomarker without action
   */
  export type BiomarkerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
  }


  /**
   * Model BiomarkerLog
   */

  export type AggregateBiomarkerLog = {
    _count: BiomarkerLogCountAggregateOutputType | null
    _avg: BiomarkerLogAvgAggregateOutputType | null
    _sum: BiomarkerLogSumAggregateOutputType | null
    _min: BiomarkerLogMinAggregateOutputType | null
    _max: BiomarkerLogMaxAggregateOutputType | null
  }

  export type BiomarkerLogAvgAggregateOutputType = {
    value: Decimal | null
  }

  export type BiomarkerLogSumAggregateOutputType = {
    value: Decimal | null
  }

  export type BiomarkerLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    biomarkerId: string | null
    value: Decimal | null
    unit: string | null
    source: $Enums.BiomarkerSource | null
    capturedAt: Date | null
    accepted: boolean | null
    flagged: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BiomarkerLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    biomarkerId: string | null
    value: Decimal | null
    unit: string | null
    source: $Enums.BiomarkerSource | null
    capturedAt: Date | null
    accepted: boolean | null
    flagged: boolean | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BiomarkerLogCountAggregateOutputType = {
    id: number
    userId: number
    biomarkerId: number
    value: number
    unit: number
    source: number
    capturedAt: number
    accepted: number
    flagged: number
    notes: number
    rawPayload: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BiomarkerLogAvgAggregateInputType = {
    value?: true
  }

  export type BiomarkerLogSumAggregateInputType = {
    value?: true
  }

  export type BiomarkerLogMinAggregateInputType = {
    id?: true
    userId?: true
    biomarkerId?: true
    value?: true
    unit?: true
    source?: true
    capturedAt?: true
    accepted?: true
    flagged?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BiomarkerLogMaxAggregateInputType = {
    id?: true
    userId?: true
    biomarkerId?: true
    value?: true
    unit?: true
    source?: true
    capturedAt?: true
    accepted?: true
    flagged?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BiomarkerLogCountAggregateInputType = {
    id?: true
    userId?: true
    biomarkerId?: true
    value?: true
    unit?: true
    source?: true
    capturedAt?: true
    accepted?: true
    flagged?: true
    notes?: true
    rawPayload?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BiomarkerLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BiomarkerLog to aggregate.
     */
    where?: BiomarkerLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiomarkerLogs to fetch.
     */
    orderBy?: BiomarkerLogOrderByWithRelationInput | BiomarkerLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BiomarkerLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiomarkerLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiomarkerLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BiomarkerLogs
    **/
    _count?: true | BiomarkerLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BiomarkerLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BiomarkerLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BiomarkerLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BiomarkerLogMaxAggregateInputType
  }

  export type GetBiomarkerLogAggregateType<T extends BiomarkerLogAggregateArgs> = {
        [P in keyof T & keyof AggregateBiomarkerLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBiomarkerLog[P]>
      : GetScalarType<T[P], AggregateBiomarkerLog[P]>
  }




  export type BiomarkerLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiomarkerLogWhereInput
    orderBy?: BiomarkerLogOrderByWithAggregationInput | BiomarkerLogOrderByWithAggregationInput[]
    by: BiomarkerLogScalarFieldEnum[] | BiomarkerLogScalarFieldEnum
    having?: BiomarkerLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BiomarkerLogCountAggregateInputType | true
    _avg?: BiomarkerLogAvgAggregateInputType
    _sum?: BiomarkerLogSumAggregateInputType
    _min?: BiomarkerLogMinAggregateInputType
    _max?: BiomarkerLogMaxAggregateInputType
  }

  export type BiomarkerLogGroupByOutputType = {
    id: string
    userId: string
    biomarkerId: string
    value: Decimal
    unit: string | null
    source: $Enums.BiomarkerSource
    capturedAt: Date
    accepted: boolean
    flagged: boolean
    notes: string | null
    rawPayload: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: BiomarkerLogCountAggregateOutputType | null
    _avg: BiomarkerLogAvgAggregateOutputType | null
    _sum: BiomarkerLogSumAggregateOutputType | null
    _min: BiomarkerLogMinAggregateOutputType | null
    _max: BiomarkerLogMaxAggregateOutputType | null
  }

  type GetBiomarkerLogGroupByPayload<T extends BiomarkerLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BiomarkerLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BiomarkerLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BiomarkerLogGroupByOutputType[P]>
            : GetScalarType<T[P], BiomarkerLogGroupByOutputType[P]>
        }
      >
    >


  export type BiomarkerLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    biomarkerId?: boolean
    value?: boolean
    unit?: boolean
    source?: boolean
    capturedAt?: boolean
    accepted?: boolean
    flagged?: boolean
    notes?: boolean
    rawPayload?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    biomarker?: boolean | BiomarkerDefaultArgs<ExtArgs>
    flags?: boolean | BiomarkerLog$flagsArgs<ExtArgs>
    _count?: boolean | BiomarkerLogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["biomarkerLog"]>

  export type BiomarkerLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    biomarkerId?: boolean
    value?: boolean
    unit?: boolean
    source?: boolean
    capturedAt?: boolean
    accepted?: boolean
    flagged?: boolean
    notes?: boolean
    rawPayload?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    biomarker?: boolean | BiomarkerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["biomarkerLog"]>

  export type BiomarkerLogSelectScalar = {
    id?: boolean
    userId?: boolean
    biomarkerId?: boolean
    value?: boolean
    unit?: boolean
    source?: boolean
    capturedAt?: boolean
    accepted?: boolean
    flagged?: boolean
    notes?: boolean
    rawPayload?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BiomarkerLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    biomarker?: boolean | BiomarkerDefaultArgs<ExtArgs>
    flags?: boolean | BiomarkerLog$flagsArgs<ExtArgs>
    _count?: boolean | BiomarkerLogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BiomarkerLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    biomarker?: boolean | BiomarkerDefaultArgs<ExtArgs>
  }

  export type $BiomarkerLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BiomarkerLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      biomarker: Prisma.$BiomarkerPayload<ExtArgs>
      flags: Prisma.$FlagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      biomarkerId: string
      value: Prisma.Decimal
      unit: string | null
      source: $Enums.BiomarkerSource
      capturedAt: Date
      accepted: boolean
      flagged: boolean
      notes: string | null
      rawPayload: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["biomarkerLog"]>
    composites: {}
  }

  type BiomarkerLogGetPayload<S extends boolean | null | undefined | BiomarkerLogDefaultArgs> = $Result.GetResult<Prisma.$BiomarkerLogPayload, S>

  type BiomarkerLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BiomarkerLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BiomarkerLogCountAggregateInputType | true
    }

  export interface BiomarkerLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BiomarkerLog'], meta: { name: 'BiomarkerLog' } }
    /**
     * Find zero or one BiomarkerLog that matches the filter.
     * @param {BiomarkerLogFindUniqueArgs} args - Arguments to find a BiomarkerLog
     * @example
     * // Get one BiomarkerLog
     * const biomarkerLog = await prisma.biomarkerLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BiomarkerLogFindUniqueArgs>(args: SelectSubset<T, BiomarkerLogFindUniqueArgs<ExtArgs>>): Prisma__BiomarkerLogClient<$Result.GetResult<Prisma.$BiomarkerLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BiomarkerLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BiomarkerLogFindUniqueOrThrowArgs} args - Arguments to find a BiomarkerLog
     * @example
     * // Get one BiomarkerLog
     * const biomarkerLog = await prisma.biomarkerLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BiomarkerLogFindUniqueOrThrowArgs>(args: SelectSubset<T, BiomarkerLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BiomarkerLogClient<$Result.GetResult<Prisma.$BiomarkerLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BiomarkerLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerLogFindFirstArgs} args - Arguments to find a BiomarkerLog
     * @example
     * // Get one BiomarkerLog
     * const biomarkerLog = await prisma.biomarkerLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BiomarkerLogFindFirstArgs>(args?: SelectSubset<T, BiomarkerLogFindFirstArgs<ExtArgs>>): Prisma__BiomarkerLogClient<$Result.GetResult<Prisma.$BiomarkerLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BiomarkerLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerLogFindFirstOrThrowArgs} args - Arguments to find a BiomarkerLog
     * @example
     * // Get one BiomarkerLog
     * const biomarkerLog = await prisma.biomarkerLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BiomarkerLogFindFirstOrThrowArgs>(args?: SelectSubset<T, BiomarkerLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__BiomarkerLogClient<$Result.GetResult<Prisma.$BiomarkerLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BiomarkerLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BiomarkerLogs
     * const biomarkerLogs = await prisma.biomarkerLog.findMany()
     * 
     * // Get first 10 BiomarkerLogs
     * const biomarkerLogs = await prisma.biomarkerLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const biomarkerLogWithIdOnly = await prisma.biomarkerLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BiomarkerLogFindManyArgs>(args?: SelectSubset<T, BiomarkerLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomarkerLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BiomarkerLog.
     * @param {BiomarkerLogCreateArgs} args - Arguments to create a BiomarkerLog.
     * @example
     * // Create one BiomarkerLog
     * const BiomarkerLog = await prisma.biomarkerLog.create({
     *   data: {
     *     // ... data to create a BiomarkerLog
     *   }
     * })
     * 
     */
    create<T extends BiomarkerLogCreateArgs>(args: SelectSubset<T, BiomarkerLogCreateArgs<ExtArgs>>): Prisma__BiomarkerLogClient<$Result.GetResult<Prisma.$BiomarkerLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BiomarkerLogs.
     * @param {BiomarkerLogCreateManyArgs} args - Arguments to create many BiomarkerLogs.
     * @example
     * // Create many BiomarkerLogs
     * const biomarkerLog = await prisma.biomarkerLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BiomarkerLogCreateManyArgs>(args?: SelectSubset<T, BiomarkerLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BiomarkerLogs and returns the data saved in the database.
     * @param {BiomarkerLogCreateManyAndReturnArgs} args - Arguments to create many BiomarkerLogs.
     * @example
     * // Create many BiomarkerLogs
     * const biomarkerLog = await prisma.biomarkerLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BiomarkerLogs and only return the `id`
     * const biomarkerLogWithIdOnly = await prisma.biomarkerLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BiomarkerLogCreateManyAndReturnArgs>(args?: SelectSubset<T, BiomarkerLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomarkerLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BiomarkerLog.
     * @param {BiomarkerLogDeleteArgs} args - Arguments to delete one BiomarkerLog.
     * @example
     * // Delete one BiomarkerLog
     * const BiomarkerLog = await prisma.biomarkerLog.delete({
     *   where: {
     *     // ... filter to delete one BiomarkerLog
     *   }
     * })
     * 
     */
    delete<T extends BiomarkerLogDeleteArgs>(args: SelectSubset<T, BiomarkerLogDeleteArgs<ExtArgs>>): Prisma__BiomarkerLogClient<$Result.GetResult<Prisma.$BiomarkerLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BiomarkerLog.
     * @param {BiomarkerLogUpdateArgs} args - Arguments to update one BiomarkerLog.
     * @example
     * // Update one BiomarkerLog
     * const biomarkerLog = await prisma.biomarkerLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BiomarkerLogUpdateArgs>(args: SelectSubset<T, BiomarkerLogUpdateArgs<ExtArgs>>): Prisma__BiomarkerLogClient<$Result.GetResult<Prisma.$BiomarkerLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BiomarkerLogs.
     * @param {BiomarkerLogDeleteManyArgs} args - Arguments to filter BiomarkerLogs to delete.
     * @example
     * // Delete a few BiomarkerLogs
     * const { count } = await prisma.biomarkerLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BiomarkerLogDeleteManyArgs>(args?: SelectSubset<T, BiomarkerLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BiomarkerLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BiomarkerLogs
     * const biomarkerLog = await prisma.biomarkerLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BiomarkerLogUpdateManyArgs>(args: SelectSubset<T, BiomarkerLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BiomarkerLog.
     * @param {BiomarkerLogUpsertArgs} args - Arguments to update or create a BiomarkerLog.
     * @example
     * // Update or create a BiomarkerLog
     * const biomarkerLog = await prisma.biomarkerLog.upsert({
     *   create: {
     *     // ... data to create a BiomarkerLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BiomarkerLog we want to update
     *   }
     * })
     */
    upsert<T extends BiomarkerLogUpsertArgs>(args: SelectSubset<T, BiomarkerLogUpsertArgs<ExtArgs>>): Prisma__BiomarkerLogClient<$Result.GetResult<Prisma.$BiomarkerLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BiomarkerLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerLogCountArgs} args - Arguments to filter BiomarkerLogs to count.
     * @example
     * // Count the number of BiomarkerLogs
     * const count = await prisma.biomarkerLog.count({
     *   where: {
     *     // ... the filter for the BiomarkerLogs we want to count
     *   }
     * })
    **/
    count<T extends BiomarkerLogCountArgs>(
      args?: Subset<T, BiomarkerLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BiomarkerLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BiomarkerLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BiomarkerLogAggregateArgs>(args: Subset<T, BiomarkerLogAggregateArgs>): Prisma.PrismaPromise<GetBiomarkerLogAggregateType<T>>

    /**
     * Group by BiomarkerLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BiomarkerLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BiomarkerLogGroupByArgs['orderBy'] }
        : { orderBy?: BiomarkerLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BiomarkerLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBiomarkerLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BiomarkerLog model
   */
  readonly fields: BiomarkerLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BiomarkerLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BiomarkerLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    biomarker<T extends BiomarkerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BiomarkerDefaultArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    flags<T extends BiomarkerLog$flagsArgs<ExtArgs> = {}>(args?: Subset<T, BiomarkerLog$flagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BiomarkerLog model
   */ 
  interface BiomarkerLogFieldRefs {
    readonly id: FieldRef<"BiomarkerLog", 'String'>
    readonly userId: FieldRef<"BiomarkerLog", 'String'>
    readonly biomarkerId: FieldRef<"BiomarkerLog", 'String'>
    readonly value: FieldRef<"BiomarkerLog", 'Decimal'>
    readonly unit: FieldRef<"BiomarkerLog", 'String'>
    readonly source: FieldRef<"BiomarkerLog", 'BiomarkerSource'>
    readonly capturedAt: FieldRef<"BiomarkerLog", 'DateTime'>
    readonly accepted: FieldRef<"BiomarkerLog", 'Boolean'>
    readonly flagged: FieldRef<"BiomarkerLog", 'Boolean'>
    readonly notes: FieldRef<"BiomarkerLog", 'String'>
    readonly rawPayload: FieldRef<"BiomarkerLog", 'Json'>
    readonly createdAt: FieldRef<"BiomarkerLog", 'DateTime'>
    readonly updatedAt: FieldRef<"BiomarkerLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BiomarkerLog findUnique
   */
  export type BiomarkerLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerLog
     */
    select?: BiomarkerLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerLogInclude<ExtArgs> | null
    /**
     * Filter, which BiomarkerLog to fetch.
     */
    where: BiomarkerLogWhereUniqueInput
  }

  /**
   * BiomarkerLog findUniqueOrThrow
   */
  export type BiomarkerLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerLog
     */
    select?: BiomarkerLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerLogInclude<ExtArgs> | null
    /**
     * Filter, which BiomarkerLog to fetch.
     */
    where: BiomarkerLogWhereUniqueInput
  }

  /**
   * BiomarkerLog findFirst
   */
  export type BiomarkerLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerLog
     */
    select?: BiomarkerLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerLogInclude<ExtArgs> | null
    /**
     * Filter, which BiomarkerLog to fetch.
     */
    where?: BiomarkerLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiomarkerLogs to fetch.
     */
    orderBy?: BiomarkerLogOrderByWithRelationInput | BiomarkerLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BiomarkerLogs.
     */
    cursor?: BiomarkerLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiomarkerLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiomarkerLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BiomarkerLogs.
     */
    distinct?: BiomarkerLogScalarFieldEnum | BiomarkerLogScalarFieldEnum[]
  }

  /**
   * BiomarkerLog findFirstOrThrow
   */
  export type BiomarkerLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerLog
     */
    select?: BiomarkerLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerLogInclude<ExtArgs> | null
    /**
     * Filter, which BiomarkerLog to fetch.
     */
    where?: BiomarkerLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiomarkerLogs to fetch.
     */
    orderBy?: BiomarkerLogOrderByWithRelationInput | BiomarkerLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BiomarkerLogs.
     */
    cursor?: BiomarkerLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiomarkerLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiomarkerLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BiomarkerLogs.
     */
    distinct?: BiomarkerLogScalarFieldEnum | BiomarkerLogScalarFieldEnum[]
  }

  /**
   * BiomarkerLog findMany
   */
  export type BiomarkerLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerLog
     */
    select?: BiomarkerLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerLogInclude<ExtArgs> | null
    /**
     * Filter, which BiomarkerLogs to fetch.
     */
    where?: BiomarkerLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiomarkerLogs to fetch.
     */
    orderBy?: BiomarkerLogOrderByWithRelationInput | BiomarkerLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BiomarkerLogs.
     */
    cursor?: BiomarkerLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiomarkerLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiomarkerLogs.
     */
    skip?: number
    distinct?: BiomarkerLogScalarFieldEnum | BiomarkerLogScalarFieldEnum[]
  }

  /**
   * BiomarkerLog create
   */
  export type BiomarkerLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerLog
     */
    select?: BiomarkerLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerLogInclude<ExtArgs> | null
    /**
     * The data needed to create a BiomarkerLog.
     */
    data: XOR<BiomarkerLogCreateInput, BiomarkerLogUncheckedCreateInput>
  }

  /**
   * BiomarkerLog createMany
   */
  export type BiomarkerLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BiomarkerLogs.
     */
    data: BiomarkerLogCreateManyInput | BiomarkerLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BiomarkerLog createManyAndReturn
   */
  export type BiomarkerLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerLog
     */
    select?: BiomarkerLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BiomarkerLogs.
     */
    data: BiomarkerLogCreateManyInput | BiomarkerLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BiomarkerLog update
   */
  export type BiomarkerLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerLog
     */
    select?: BiomarkerLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerLogInclude<ExtArgs> | null
    /**
     * The data needed to update a BiomarkerLog.
     */
    data: XOR<BiomarkerLogUpdateInput, BiomarkerLogUncheckedUpdateInput>
    /**
     * Choose, which BiomarkerLog to update.
     */
    where: BiomarkerLogWhereUniqueInput
  }

  /**
   * BiomarkerLog updateMany
   */
  export type BiomarkerLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BiomarkerLogs.
     */
    data: XOR<BiomarkerLogUpdateManyMutationInput, BiomarkerLogUncheckedUpdateManyInput>
    /**
     * Filter which BiomarkerLogs to update
     */
    where?: BiomarkerLogWhereInput
  }

  /**
   * BiomarkerLog upsert
   */
  export type BiomarkerLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerLog
     */
    select?: BiomarkerLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerLogInclude<ExtArgs> | null
    /**
     * The filter to search for the BiomarkerLog to update in case it exists.
     */
    where: BiomarkerLogWhereUniqueInput
    /**
     * In case the BiomarkerLog found by the `where` argument doesn't exist, create a new BiomarkerLog with this data.
     */
    create: XOR<BiomarkerLogCreateInput, BiomarkerLogUncheckedCreateInput>
    /**
     * In case the BiomarkerLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BiomarkerLogUpdateInput, BiomarkerLogUncheckedUpdateInput>
  }

  /**
   * BiomarkerLog delete
   */
  export type BiomarkerLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerLog
     */
    select?: BiomarkerLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerLogInclude<ExtArgs> | null
    /**
     * Filter which BiomarkerLog to delete.
     */
    where: BiomarkerLogWhereUniqueInput
  }

  /**
   * BiomarkerLog deleteMany
   */
  export type BiomarkerLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BiomarkerLogs to delete
     */
    where?: BiomarkerLogWhereInput
  }

  /**
   * BiomarkerLog.flags
   */
  export type BiomarkerLog$flagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    where?: FlagWhereInput
    orderBy?: FlagOrderByWithRelationInput | FlagOrderByWithRelationInput[]
    cursor?: FlagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlagScalarFieldEnum | FlagScalarFieldEnum[]
  }

  /**
   * BiomarkerLog without action
   */
  export type BiomarkerLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerLog
     */
    select?: BiomarkerLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerLogInclude<ExtArgs> | null
  }


  /**
   * Model PanelUpload
   */

  export type AggregatePanelUpload = {
    _count: PanelUploadCountAggregateOutputType | null
    _avg: PanelUploadAvgAggregateOutputType | null
    _sum: PanelUploadSumAggregateOutputType | null
    _min: PanelUploadMinAggregateOutputType | null
    _max: PanelUploadMaxAggregateOutputType | null
  }

  export type PanelUploadAvgAggregateOutputType = {
    pageCount: number | null
    measurementCount: number | null
  }

  export type PanelUploadSumAggregateOutputType = {
    pageCount: number | null
    measurementCount: number | null
  }

  export type PanelUploadMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.PanelUploadStatus | null
    source: $Enums.PanelUploadSource | null
    storageKey: string | null
    contentType: string | null
    pageCount: number | null
    measurementCount: number | null
    processedAt: Date | null
    errorCode: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PanelUploadMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.PanelUploadStatus | null
    source: $Enums.PanelUploadSource | null
    storageKey: string | null
    contentType: string | null
    pageCount: number | null
    measurementCount: number | null
    processedAt: Date | null
    errorCode: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PanelUploadCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    source: number
    storageKey: number
    contentType: number
    pageCount: number
    rawMetadata: number
    normalizedPayload: number
    measurementCount: number
    processedAt: number
    errorCode: number
    errorMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PanelUploadAvgAggregateInputType = {
    pageCount?: true
    measurementCount?: true
  }

  export type PanelUploadSumAggregateInputType = {
    pageCount?: true
    measurementCount?: true
  }

  export type PanelUploadMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    source?: true
    storageKey?: true
    contentType?: true
    pageCount?: true
    measurementCount?: true
    processedAt?: true
    errorCode?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PanelUploadMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    source?: true
    storageKey?: true
    contentType?: true
    pageCount?: true
    measurementCount?: true
    processedAt?: true
    errorCode?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PanelUploadCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    source?: true
    storageKey?: true
    contentType?: true
    pageCount?: true
    rawMetadata?: true
    normalizedPayload?: true
    measurementCount?: true
    processedAt?: true
    errorCode?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PanelUploadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PanelUpload to aggregate.
     */
    where?: PanelUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PanelUploads to fetch.
     */
    orderBy?: PanelUploadOrderByWithRelationInput | PanelUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PanelUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PanelUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PanelUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PanelUploads
    **/
    _count?: true | PanelUploadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PanelUploadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PanelUploadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PanelUploadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PanelUploadMaxAggregateInputType
  }

  export type GetPanelUploadAggregateType<T extends PanelUploadAggregateArgs> = {
        [P in keyof T & keyof AggregatePanelUpload]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePanelUpload[P]>
      : GetScalarType<T[P], AggregatePanelUpload[P]>
  }




  export type PanelUploadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PanelUploadWhereInput
    orderBy?: PanelUploadOrderByWithAggregationInput | PanelUploadOrderByWithAggregationInput[]
    by: PanelUploadScalarFieldEnum[] | PanelUploadScalarFieldEnum
    having?: PanelUploadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PanelUploadCountAggregateInputType | true
    _avg?: PanelUploadAvgAggregateInputType
    _sum?: PanelUploadSumAggregateInputType
    _min?: PanelUploadMinAggregateInputType
    _max?: PanelUploadMaxAggregateInputType
  }

  export type PanelUploadGroupByOutputType = {
    id: string
    userId: string
    status: $Enums.PanelUploadStatus
    source: $Enums.PanelUploadSource
    storageKey: string
    contentType: string | null
    pageCount: number | null
    rawMetadata: JsonValue | null
    normalizedPayload: JsonValue | null
    measurementCount: number
    processedAt: Date | null
    errorCode: string | null
    errorMessage: string | null
    createdAt: Date
    updatedAt: Date
    _count: PanelUploadCountAggregateOutputType | null
    _avg: PanelUploadAvgAggregateOutputType | null
    _sum: PanelUploadSumAggregateOutputType | null
    _min: PanelUploadMinAggregateOutputType | null
    _max: PanelUploadMaxAggregateOutputType | null
  }

  type GetPanelUploadGroupByPayload<T extends PanelUploadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PanelUploadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PanelUploadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PanelUploadGroupByOutputType[P]>
            : GetScalarType<T[P], PanelUploadGroupByOutputType[P]>
        }
      >
    >


  export type PanelUploadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    source?: boolean
    storageKey?: boolean
    contentType?: boolean
    pageCount?: boolean
    rawMetadata?: boolean
    normalizedPayload?: boolean
    measurementCount?: boolean
    processedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    measurements?: boolean | PanelUpload$measurementsArgs<ExtArgs>
    _count?: boolean | PanelUploadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["panelUpload"]>

  export type PanelUploadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    source?: boolean
    storageKey?: boolean
    contentType?: boolean
    pageCount?: boolean
    rawMetadata?: boolean
    normalizedPayload?: boolean
    measurementCount?: boolean
    processedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["panelUpload"]>

  export type PanelUploadSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    source?: boolean
    storageKey?: boolean
    contentType?: boolean
    pageCount?: boolean
    rawMetadata?: boolean
    normalizedPayload?: boolean
    measurementCount?: boolean
    processedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PanelUploadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    measurements?: boolean | PanelUpload$measurementsArgs<ExtArgs>
    _count?: boolean | PanelUploadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PanelUploadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PanelUploadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PanelUpload"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      measurements: Prisma.$BiomarkerMeasurementPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: $Enums.PanelUploadStatus
      source: $Enums.PanelUploadSource
      storageKey: string
      contentType: string | null
      pageCount: number | null
      rawMetadata: Prisma.JsonValue | null
      normalizedPayload: Prisma.JsonValue | null
      measurementCount: number
      processedAt: Date | null
      errorCode: string | null
      errorMessage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["panelUpload"]>
    composites: {}
  }

  type PanelUploadGetPayload<S extends boolean | null | undefined | PanelUploadDefaultArgs> = $Result.GetResult<Prisma.$PanelUploadPayload, S>

  type PanelUploadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PanelUploadFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PanelUploadCountAggregateInputType | true
    }

  export interface PanelUploadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PanelUpload'], meta: { name: 'PanelUpload' } }
    /**
     * Find zero or one PanelUpload that matches the filter.
     * @param {PanelUploadFindUniqueArgs} args - Arguments to find a PanelUpload
     * @example
     * // Get one PanelUpload
     * const panelUpload = await prisma.panelUpload.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PanelUploadFindUniqueArgs>(args: SelectSubset<T, PanelUploadFindUniqueArgs<ExtArgs>>): Prisma__PanelUploadClient<$Result.GetResult<Prisma.$PanelUploadPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PanelUpload that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PanelUploadFindUniqueOrThrowArgs} args - Arguments to find a PanelUpload
     * @example
     * // Get one PanelUpload
     * const panelUpload = await prisma.panelUpload.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PanelUploadFindUniqueOrThrowArgs>(args: SelectSubset<T, PanelUploadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PanelUploadClient<$Result.GetResult<Prisma.$PanelUploadPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PanelUpload that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanelUploadFindFirstArgs} args - Arguments to find a PanelUpload
     * @example
     * // Get one PanelUpload
     * const panelUpload = await prisma.panelUpload.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PanelUploadFindFirstArgs>(args?: SelectSubset<T, PanelUploadFindFirstArgs<ExtArgs>>): Prisma__PanelUploadClient<$Result.GetResult<Prisma.$PanelUploadPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PanelUpload that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanelUploadFindFirstOrThrowArgs} args - Arguments to find a PanelUpload
     * @example
     * // Get one PanelUpload
     * const panelUpload = await prisma.panelUpload.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PanelUploadFindFirstOrThrowArgs>(args?: SelectSubset<T, PanelUploadFindFirstOrThrowArgs<ExtArgs>>): Prisma__PanelUploadClient<$Result.GetResult<Prisma.$PanelUploadPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PanelUploads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanelUploadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PanelUploads
     * const panelUploads = await prisma.panelUpload.findMany()
     * 
     * // Get first 10 PanelUploads
     * const panelUploads = await prisma.panelUpload.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const panelUploadWithIdOnly = await prisma.panelUpload.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PanelUploadFindManyArgs>(args?: SelectSubset<T, PanelUploadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PanelUploadPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PanelUpload.
     * @param {PanelUploadCreateArgs} args - Arguments to create a PanelUpload.
     * @example
     * // Create one PanelUpload
     * const PanelUpload = await prisma.panelUpload.create({
     *   data: {
     *     // ... data to create a PanelUpload
     *   }
     * })
     * 
     */
    create<T extends PanelUploadCreateArgs>(args: SelectSubset<T, PanelUploadCreateArgs<ExtArgs>>): Prisma__PanelUploadClient<$Result.GetResult<Prisma.$PanelUploadPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PanelUploads.
     * @param {PanelUploadCreateManyArgs} args - Arguments to create many PanelUploads.
     * @example
     * // Create many PanelUploads
     * const panelUpload = await prisma.panelUpload.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PanelUploadCreateManyArgs>(args?: SelectSubset<T, PanelUploadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PanelUploads and returns the data saved in the database.
     * @param {PanelUploadCreateManyAndReturnArgs} args - Arguments to create many PanelUploads.
     * @example
     * // Create many PanelUploads
     * const panelUpload = await prisma.panelUpload.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PanelUploads and only return the `id`
     * const panelUploadWithIdOnly = await prisma.panelUpload.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PanelUploadCreateManyAndReturnArgs>(args?: SelectSubset<T, PanelUploadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PanelUploadPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PanelUpload.
     * @param {PanelUploadDeleteArgs} args - Arguments to delete one PanelUpload.
     * @example
     * // Delete one PanelUpload
     * const PanelUpload = await prisma.panelUpload.delete({
     *   where: {
     *     // ... filter to delete one PanelUpload
     *   }
     * })
     * 
     */
    delete<T extends PanelUploadDeleteArgs>(args: SelectSubset<T, PanelUploadDeleteArgs<ExtArgs>>): Prisma__PanelUploadClient<$Result.GetResult<Prisma.$PanelUploadPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PanelUpload.
     * @param {PanelUploadUpdateArgs} args - Arguments to update one PanelUpload.
     * @example
     * // Update one PanelUpload
     * const panelUpload = await prisma.panelUpload.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PanelUploadUpdateArgs>(args: SelectSubset<T, PanelUploadUpdateArgs<ExtArgs>>): Prisma__PanelUploadClient<$Result.GetResult<Prisma.$PanelUploadPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PanelUploads.
     * @param {PanelUploadDeleteManyArgs} args - Arguments to filter PanelUploads to delete.
     * @example
     * // Delete a few PanelUploads
     * const { count } = await prisma.panelUpload.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PanelUploadDeleteManyArgs>(args?: SelectSubset<T, PanelUploadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PanelUploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanelUploadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PanelUploads
     * const panelUpload = await prisma.panelUpload.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PanelUploadUpdateManyArgs>(args: SelectSubset<T, PanelUploadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PanelUpload.
     * @param {PanelUploadUpsertArgs} args - Arguments to update or create a PanelUpload.
     * @example
     * // Update or create a PanelUpload
     * const panelUpload = await prisma.panelUpload.upsert({
     *   create: {
     *     // ... data to create a PanelUpload
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PanelUpload we want to update
     *   }
     * })
     */
    upsert<T extends PanelUploadUpsertArgs>(args: SelectSubset<T, PanelUploadUpsertArgs<ExtArgs>>): Prisma__PanelUploadClient<$Result.GetResult<Prisma.$PanelUploadPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PanelUploads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanelUploadCountArgs} args - Arguments to filter PanelUploads to count.
     * @example
     * // Count the number of PanelUploads
     * const count = await prisma.panelUpload.count({
     *   where: {
     *     // ... the filter for the PanelUploads we want to count
     *   }
     * })
    **/
    count<T extends PanelUploadCountArgs>(
      args?: Subset<T, PanelUploadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PanelUploadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PanelUpload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanelUploadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PanelUploadAggregateArgs>(args: Subset<T, PanelUploadAggregateArgs>): Prisma.PrismaPromise<GetPanelUploadAggregateType<T>>

    /**
     * Group by PanelUpload.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PanelUploadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PanelUploadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PanelUploadGroupByArgs['orderBy'] }
        : { orderBy?: PanelUploadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PanelUploadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPanelUploadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PanelUpload model
   */
  readonly fields: PanelUploadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PanelUpload.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PanelUploadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    measurements<T extends PanelUpload$measurementsArgs<ExtArgs> = {}>(args?: Subset<T, PanelUpload$measurementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomarkerMeasurementPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PanelUpload model
   */ 
  interface PanelUploadFieldRefs {
    readonly id: FieldRef<"PanelUpload", 'String'>
    readonly userId: FieldRef<"PanelUpload", 'String'>
    readonly status: FieldRef<"PanelUpload", 'PanelUploadStatus'>
    readonly source: FieldRef<"PanelUpload", 'PanelUploadSource'>
    readonly storageKey: FieldRef<"PanelUpload", 'String'>
    readonly contentType: FieldRef<"PanelUpload", 'String'>
    readonly pageCount: FieldRef<"PanelUpload", 'Int'>
    readonly rawMetadata: FieldRef<"PanelUpload", 'Json'>
    readonly normalizedPayload: FieldRef<"PanelUpload", 'Json'>
    readonly measurementCount: FieldRef<"PanelUpload", 'Int'>
    readonly processedAt: FieldRef<"PanelUpload", 'DateTime'>
    readonly errorCode: FieldRef<"PanelUpload", 'String'>
    readonly errorMessage: FieldRef<"PanelUpload", 'String'>
    readonly createdAt: FieldRef<"PanelUpload", 'DateTime'>
    readonly updatedAt: FieldRef<"PanelUpload", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PanelUpload findUnique
   */
  export type PanelUploadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanelUpload
     */
    select?: PanelUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanelUploadInclude<ExtArgs> | null
    /**
     * Filter, which PanelUpload to fetch.
     */
    where: PanelUploadWhereUniqueInput
  }

  /**
   * PanelUpload findUniqueOrThrow
   */
  export type PanelUploadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanelUpload
     */
    select?: PanelUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanelUploadInclude<ExtArgs> | null
    /**
     * Filter, which PanelUpload to fetch.
     */
    where: PanelUploadWhereUniqueInput
  }

  /**
   * PanelUpload findFirst
   */
  export type PanelUploadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanelUpload
     */
    select?: PanelUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanelUploadInclude<ExtArgs> | null
    /**
     * Filter, which PanelUpload to fetch.
     */
    where?: PanelUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PanelUploads to fetch.
     */
    orderBy?: PanelUploadOrderByWithRelationInput | PanelUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PanelUploads.
     */
    cursor?: PanelUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PanelUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PanelUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PanelUploads.
     */
    distinct?: PanelUploadScalarFieldEnum | PanelUploadScalarFieldEnum[]
  }

  /**
   * PanelUpload findFirstOrThrow
   */
  export type PanelUploadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanelUpload
     */
    select?: PanelUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanelUploadInclude<ExtArgs> | null
    /**
     * Filter, which PanelUpload to fetch.
     */
    where?: PanelUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PanelUploads to fetch.
     */
    orderBy?: PanelUploadOrderByWithRelationInput | PanelUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PanelUploads.
     */
    cursor?: PanelUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PanelUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PanelUploads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PanelUploads.
     */
    distinct?: PanelUploadScalarFieldEnum | PanelUploadScalarFieldEnum[]
  }

  /**
   * PanelUpload findMany
   */
  export type PanelUploadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanelUpload
     */
    select?: PanelUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanelUploadInclude<ExtArgs> | null
    /**
     * Filter, which PanelUploads to fetch.
     */
    where?: PanelUploadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PanelUploads to fetch.
     */
    orderBy?: PanelUploadOrderByWithRelationInput | PanelUploadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PanelUploads.
     */
    cursor?: PanelUploadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PanelUploads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PanelUploads.
     */
    skip?: number
    distinct?: PanelUploadScalarFieldEnum | PanelUploadScalarFieldEnum[]
  }

  /**
   * PanelUpload create
   */
  export type PanelUploadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanelUpload
     */
    select?: PanelUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanelUploadInclude<ExtArgs> | null
    /**
     * The data needed to create a PanelUpload.
     */
    data: XOR<PanelUploadCreateInput, PanelUploadUncheckedCreateInput>
  }

  /**
   * PanelUpload createMany
   */
  export type PanelUploadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PanelUploads.
     */
    data: PanelUploadCreateManyInput | PanelUploadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PanelUpload createManyAndReturn
   */
  export type PanelUploadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanelUpload
     */
    select?: PanelUploadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PanelUploads.
     */
    data: PanelUploadCreateManyInput | PanelUploadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanelUploadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PanelUpload update
   */
  export type PanelUploadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanelUpload
     */
    select?: PanelUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanelUploadInclude<ExtArgs> | null
    /**
     * The data needed to update a PanelUpload.
     */
    data: XOR<PanelUploadUpdateInput, PanelUploadUncheckedUpdateInput>
    /**
     * Choose, which PanelUpload to update.
     */
    where: PanelUploadWhereUniqueInput
  }

  /**
   * PanelUpload updateMany
   */
  export type PanelUploadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PanelUploads.
     */
    data: XOR<PanelUploadUpdateManyMutationInput, PanelUploadUncheckedUpdateManyInput>
    /**
     * Filter which PanelUploads to update
     */
    where?: PanelUploadWhereInput
  }

  /**
   * PanelUpload upsert
   */
  export type PanelUploadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanelUpload
     */
    select?: PanelUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanelUploadInclude<ExtArgs> | null
    /**
     * The filter to search for the PanelUpload to update in case it exists.
     */
    where: PanelUploadWhereUniqueInput
    /**
     * In case the PanelUpload found by the `where` argument doesn't exist, create a new PanelUpload with this data.
     */
    create: XOR<PanelUploadCreateInput, PanelUploadUncheckedCreateInput>
    /**
     * In case the PanelUpload was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PanelUploadUpdateInput, PanelUploadUncheckedUpdateInput>
  }

  /**
   * PanelUpload delete
   */
  export type PanelUploadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanelUpload
     */
    select?: PanelUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanelUploadInclude<ExtArgs> | null
    /**
     * Filter which PanelUpload to delete.
     */
    where: PanelUploadWhereUniqueInput
  }

  /**
   * PanelUpload deleteMany
   */
  export type PanelUploadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PanelUploads to delete
     */
    where?: PanelUploadWhereInput
  }

  /**
   * PanelUpload.measurements
   */
  export type PanelUpload$measurementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerMeasurement
     */
    select?: BiomarkerMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerMeasurementInclude<ExtArgs> | null
    where?: BiomarkerMeasurementWhereInput
    orderBy?: BiomarkerMeasurementOrderByWithRelationInput | BiomarkerMeasurementOrderByWithRelationInput[]
    cursor?: BiomarkerMeasurementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BiomarkerMeasurementScalarFieldEnum | BiomarkerMeasurementScalarFieldEnum[]
  }

  /**
   * PanelUpload without action
   */
  export type PanelUploadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanelUpload
     */
    select?: PanelUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanelUploadInclude<ExtArgs> | null
  }


  /**
   * Model BiomarkerMeasurement
   */

  export type AggregateBiomarkerMeasurement = {
    _count: BiomarkerMeasurementCountAggregateOutputType | null
    _avg: BiomarkerMeasurementAvgAggregateOutputType | null
    _sum: BiomarkerMeasurementSumAggregateOutputType | null
    _min: BiomarkerMeasurementMinAggregateOutputType | null
    _max: BiomarkerMeasurementMaxAggregateOutputType | null
  }

  export type BiomarkerMeasurementAvgAggregateOutputType = {
    value: Decimal | null
    referenceLow: Decimal | null
    referenceHigh: Decimal | null
    confidence: Decimal | null
  }

  export type BiomarkerMeasurementSumAggregateOutputType = {
    value: Decimal | null
    referenceLow: Decimal | null
    referenceHigh: Decimal | null
    confidence: Decimal | null
  }

  export type BiomarkerMeasurementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    biomarkerId: string | null
    panelUploadId: string | null
    markerName: string | null
    value: Decimal | null
    unit: string | null
    referenceLow: Decimal | null
    referenceHigh: Decimal | null
    capturedAt: Date | null
    status: $Enums.MeasurementStatus | null
    source: $Enums.BiomarkerSource | null
    confidence: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BiomarkerMeasurementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    biomarkerId: string | null
    panelUploadId: string | null
    markerName: string | null
    value: Decimal | null
    unit: string | null
    referenceLow: Decimal | null
    referenceHigh: Decimal | null
    capturedAt: Date | null
    status: $Enums.MeasurementStatus | null
    source: $Enums.BiomarkerSource | null
    confidence: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BiomarkerMeasurementCountAggregateOutputType = {
    id: number
    userId: number
    biomarkerId: number
    panelUploadId: number
    markerName: number
    value: number
    unit: number
    referenceLow: number
    referenceHigh: number
    capturedAt: number
    status: number
    source: number
    confidence: number
    flags: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BiomarkerMeasurementAvgAggregateInputType = {
    value?: true
    referenceLow?: true
    referenceHigh?: true
    confidence?: true
  }

  export type BiomarkerMeasurementSumAggregateInputType = {
    value?: true
    referenceLow?: true
    referenceHigh?: true
    confidence?: true
  }

  export type BiomarkerMeasurementMinAggregateInputType = {
    id?: true
    userId?: true
    biomarkerId?: true
    panelUploadId?: true
    markerName?: true
    value?: true
    unit?: true
    referenceLow?: true
    referenceHigh?: true
    capturedAt?: true
    status?: true
    source?: true
    confidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BiomarkerMeasurementMaxAggregateInputType = {
    id?: true
    userId?: true
    biomarkerId?: true
    panelUploadId?: true
    markerName?: true
    value?: true
    unit?: true
    referenceLow?: true
    referenceHigh?: true
    capturedAt?: true
    status?: true
    source?: true
    confidence?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BiomarkerMeasurementCountAggregateInputType = {
    id?: true
    userId?: true
    biomarkerId?: true
    panelUploadId?: true
    markerName?: true
    value?: true
    unit?: true
    referenceLow?: true
    referenceHigh?: true
    capturedAt?: true
    status?: true
    source?: true
    confidence?: true
    flags?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BiomarkerMeasurementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BiomarkerMeasurement to aggregate.
     */
    where?: BiomarkerMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiomarkerMeasurements to fetch.
     */
    orderBy?: BiomarkerMeasurementOrderByWithRelationInput | BiomarkerMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BiomarkerMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiomarkerMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiomarkerMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BiomarkerMeasurements
    **/
    _count?: true | BiomarkerMeasurementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BiomarkerMeasurementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BiomarkerMeasurementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BiomarkerMeasurementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BiomarkerMeasurementMaxAggregateInputType
  }

  export type GetBiomarkerMeasurementAggregateType<T extends BiomarkerMeasurementAggregateArgs> = {
        [P in keyof T & keyof AggregateBiomarkerMeasurement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBiomarkerMeasurement[P]>
      : GetScalarType<T[P], AggregateBiomarkerMeasurement[P]>
  }




  export type BiomarkerMeasurementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiomarkerMeasurementWhereInput
    orderBy?: BiomarkerMeasurementOrderByWithAggregationInput | BiomarkerMeasurementOrderByWithAggregationInput[]
    by: BiomarkerMeasurementScalarFieldEnum[] | BiomarkerMeasurementScalarFieldEnum
    having?: BiomarkerMeasurementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BiomarkerMeasurementCountAggregateInputType | true
    _avg?: BiomarkerMeasurementAvgAggregateInputType
    _sum?: BiomarkerMeasurementSumAggregateInputType
    _min?: BiomarkerMeasurementMinAggregateInputType
    _max?: BiomarkerMeasurementMaxAggregateInputType
  }

  export type BiomarkerMeasurementGroupByOutputType = {
    id: string
    userId: string
    biomarkerId: string | null
    panelUploadId: string | null
    markerName: string
    value: Decimal | null
    unit: string | null
    referenceLow: Decimal | null
    referenceHigh: Decimal | null
    capturedAt: Date | null
    status: $Enums.MeasurementStatus
    source: $Enums.BiomarkerSource
    confidence: Decimal | null
    flags: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: BiomarkerMeasurementCountAggregateOutputType | null
    _avg: BiomarkerMeasurementAvgAggregateOutputType | null
    _sum: BiomarkerMeasurementSumAggregateOutputType | null
    _min: BiomarkerMeasurementMinAggregateOutputType | null
    _max: BiomarkerMeasurementMaxAggregateOutputType | null
  }

  type GetBiomarkerMeasurementGroupByPayload<T extends BiomarkerMeasurementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BiomarkerMeasurementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BiomarkerMeasurementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BiomarkerMeasurementGroupByOutputType[P]>
            : GetScalarType<T[P], BiomarkerMeasurementGroupByOutputType[P]>
        }
      >
    >


  export type BiomarkerMeasurementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    biomarkerId?: boolean
    panelUploadId?: boolean
    markerName?: boolean
    value?: boolean
    unit?: boolean
    referenceLow?: boolean
    referenceHigh?: boolean
    capturedAt?: boolean
    status?: boolean
    source?: boolean
    confidence?: boolean
    flags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    biomarker?: boolean | BiomarkerMeasurement$biomarkerArgs<ExtArgs>
    panelUpload?: boolean | BiomarkerMeasurement$panelUploadArgs<ExtArgs>
  }, ExtArgs["result"]["biomarkerMeasurement"]>

  export type BiomarkerMeasurementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    biomarkerId?: boolean
    panelUploadId?: boolean
    markerName?: boolean
    value?: boolean
    unit?: boolean
    referenceLow?: boolean
    referenceHigh?: boolean
    capturedAt?: boolean
    status?: boolean
    source?: boolean
    confidence?: boolean
    flags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    biomarker?: boolean | BiomarkerMeasurement$biomarkerArgs<ExtArgs>
    panelUpload?: boolean | BiomarkerMeasurement$panelUploadArgs<ExtArgs>
  }, ExtArgs["result"]["biomarkerMeasurement"]>

  export type BiomarkerMeasurementSelectScalar = {
    id?: boolean
    userId?: boolean
    biomarkerId?: boolean
    panelUploadId?: boolean
    markerName?: boolean
    value?: boolean
    unit?: boolean
    referenceLow?: boolean
    referenceHigh?: boolean
    capturedAt?: boolean
    status?: boolean
    source?: boolean
    confidence?: boolean
    flags?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BiomarkerMeasurementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    biomarker?: boolean | BiomarkerMeasurement$biomarkerArgs<ExtArgs>
    panelUpload?: boolean | BiomarkerMeasurement$panelUploadArgs<ExtArgs>
  }
  export type BiomarkerMeasurementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    biomarker?: boolean | BiomarkerMeasurement$biomarkerArgs<ExtArgs>
    panelUpload?: boolean | BiomarkerMeasurement$panelUploadArgs<ExtArgs>
  }

  export type $BiomarkerMeasurementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BiomarkerMeasurement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      biomarker: Prisma.$BiomarkerPayload<ExtArgs> | null
      panelUpload: Prisma.$PanelUploadPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      biomarkerId: string | null
      panelUploadId: string | null
      markerName: string
      value: Prisma.Decimal | null
      unit: string | null
      referenceLow: Prisma.Decimal | null
      referenceHigh: Prisma.Decimal | null
      capturedAt: Date | null
      status: $Enums.MeasurementStatus
      source: $Enums.BiomarkerSource
      confidence: Prisma.Decimal | null
      flags: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["biomarkerMeasurement"]>
    composites: {}
  }

  type BiomarkerMeasurementGetPayload<S extends boolean | null | undefined | BiomarkerMeasurementDefaultArgs> = $Result.GetResult<Prisma.$BiomarkerMeasurementPayload, S>

  type BiomarkerMeasurementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BiomarkerMeasurementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BiomarkerMeasurementCountAggregateInputType | true
    }

  export interface BiomarkerMeasurementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BiomarkerMeasurement'], meta: { name: 'BiomarkerMeasurement' } }
    /**
     * Find zero or one BiomarkerMeasurement that matches the filter.
     * @param {BiomarkerMeasurementFindUniqueArgs} args - Arguments to find a BiomarkerMeasurement
     * @example
     * // Get one BiomarkerMeasurement
     * const biomarkerMeasurement = await prisma.biomarkerMeasurement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BiomarkerMeasurementFindUniqueArgs>(args: SelectSubset<T, BiomarkerMeasurementFindUniqueArgs<ExtArgs>>): Prisma__BiomarkerMeasurementClient<$Result.GetResult<Prisma.$BiomarkerMeasurementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BiomarkerMeasurement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BiomarkerMeasurementFindUniqueOrThrowArgs} args - Arguments to find a BiomarkerMeasurement
     * @example
     * // Get one BiomarkerMeasurement
     * const biomarkerMeasurement = await prisma.biomarkerMeasurement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BiomarkerMeasurementFindUniqueOrThrowArgs>(args: SelectSubset<T, BiomarkerMeasurementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BiomarkerMeasurementClient<$Result.GetResult<Prisma.$BiomarkerMeasurementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BiomarkerMeasurement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerMeasurementFindFirstArgs} args - Arguments to find a BiomarkerMeasurement
     * @example
     * // Get one BiomarkerMeasurement
     * const biomarkerMeasurement = await prisma.biomarkerMeasurement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BiomarkerMeasurementFindFirstArgs>(args?: SelectSubset<T, BiomarkerMeasurementFindFirstArgs<ExtArgs>>): Prisma__BiomarkerMeasurementClient<$Result.GetResult<Prisma.$BiomarkerMeasurementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BiomarkerMeasurement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerMeasurementFindFirstOrThrowArgs} args - Arguments to find a BiomarkerMeasurement
     * @example
     * // Get one BiomarkerMeasurement
     * const biomarkerMeasurement = await prisma.biomarkerMeasurement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BiomarkerMeasurementFindFirstOrThrowArgs>(args?: SelectSubset<T, BiomarkerMeasurementFindFirstOrThrowArgs<ExtArgs>>): Prisma__BiomarkerMeasurementClient<$Result.GetResult<Prisma.$BiomarkerMeasurementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BiomarkerMeasurements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerMeasurementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BiomarkerMeasurements
     * const biomarkerMeasurements = await prisma.biomarkerMeasurement.findMany()
     * 
     * // Get first 10 BiomarkerMeasurements
     * const biomarkerMeasurements = await prisma.biomarkerMeasurement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const biomarkerMeasurementWithIdOnly = await prisma.biomarkerMeasurement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BiomarkerMeasurementFindManyArgs>(args?: SelectSubset<T, BiomarkerMeasurementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomarkerMeasurementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BiomarkerMeasurement.
     * @param {BiomarkerMeasurementCreateArgs} args - Arguments to create a BiomarkerMeasurement.
     * @example
     * // Create one BiomarkerMeasurement
     * const BiomarkerMeasurement = await prisma.biomarkerMeasurement.create({
     *   data: {
     *     // ... data to create a BiomarkerMeasurement
     *   }
     * })
     * 
     */
    create<T extends BiomarkerMeasurementCreateArgs>(args: SelectSubset<T, BiomarkerMeasurementCreateArgs<ExtArgs>>): Prisma__BiomarkerMeasurementClient<$Result.GetResult<Prisma.$BiomarkerMeasurementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BiomarkerMeasurements.
     * @param {BiomarkerMeasurementCreateManyArgs} args - Arguments to create many BiomarkerMeasurements.
     * @example
     * // Create many BiomarkerMeasurements
     * const biomarkerMeasurement = await prisma.biomarkerMeasurement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BiomarkerMeasurementCreateManyArgs>(args?: SelectSubset<T, BiomarkerMeasurementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BiomarkerMeasurements and returns the data saved in the database.
     * @param {BiomarkerMeasurementCreateManyAndReturnArgs} args - Arguments to create many BiomarkerMeasurements.
     * @example
     * // Create many BiomarkerMeasurements
     * const biomarkerMeasurement = await prisma.biomarkerMeasurement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BiomarkerMeasurements and only return the `id`
     * const biomarkerMeasurementWithIdOnly = await prisma.biomarkerMeasurement.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BiomarkerMeasurementCreateManyAndReturnArgs>(args?: SelectSubset<T, BiomarkerMeasurementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiomarkerMeasurementPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BiomarkerMeasurement.
     * @param {BiomarkerMeasurementDeleteArgs} args - Arguments to delete one BiomarkerMeasurement.
     * @example
     * // Delete one BiomarkerMeasurement
     * const BiomarkerMeasurement = await prisma.biomarkerMeasurement.delete({
     *   where: {
     *     // ... filter to delete one BiomarkerMeasurement
     *   }
     * })
     * 
     */
    delete<T extends BiomarkerMeasurementDeleteArgs>(args: SelectSubset<T, BiomarkerMeasurementDeleteArgs<ExtArgs>>): Prisma__BiomarkerMeasurementClient<$Result.GetResult<Prisma.$BiomarkerMeasurementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BiomarkerMeasurement.
     * @param {BiomarkerMeasurementUpdateArgs} args - Arguments to update one BiomarkerMeasurement.
     * @example
     * // Update one BiomarkerMeasurement
     * const biomarkerMeasurement = await prisma.biomarkerMeasurement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BiomarkerMeasurementUpdateArgs>(args: SelectSubset<T, BiomarkerMeasurementUpdateArgs<ExtArgs>>): Prisma__BiomarkerMeasurementClient<$Result.GetResult<Prisma.$BiomarkerMeasurementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BiomarkerMeasurements.
     * @param {BiomarkerMeasurementDeleteManyArgs} args - Arguments to filter BiomarkerMeasurements to delete.
     * @example
     * // Delete a few BiomarkerMeasurements
     * const { count } = await prisma.biomarkerMeasurement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BiomarkerMeasurementDeleteManyArgs>(args?: SelectSubset<T, BiomarkerMeasurementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BiomarkerMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerMeasurementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BiomarkerMeasurements
     * const biomarkerMeasurement = await prisma.biomarkerMeasurement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BiomarkerMeasurementUpdateManyArgs>(args: SelectSubset<T, BiomarkerMeasurementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BiomarkerMeasurement.
     * @param {BiomarkerMeasurementUpsertArgs} args - Arguments to update or create a BiomarkerMeasurement.
     * @example
     * // Update or create a BiomarkerMeasurement
     * const biomarkerMeasurement = await prisma.biomarkerMeasurement.upsert({
     *   create: {
     *     // ... data to create a BiomarkerMeasurement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BiomarkerMeasurement we want to update
     *   }
     * })
     */
    upsert<T extends BiomarkerMeasurementUpsertArgs>(args: SelectSubset<T, BiomarkerMeasurementUpsertArgs<ExtArgs>>): Prisma__BiomarkerMeasurementClient<$Result.GetResult<Prisma.$BiomarkerMeasurementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BiomarkerMeasurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerMeasurementCountArgs} args - Arguments to filter BiomarkerMeasurements to count.
     * @example
     * // Count the number of BiomarkerMeasurements
     * const count = await prisma.biomarkerMeasurement.count({
     *   where: {
     *     // ... the filter for the BiomarkerMeasurements we want to count
     *   }
     * })
    **/
    count<T extends BiomarkerMeasurementCountArgs>(
      args?: Subset<T, BiomarkerMeasurementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BiomarkerMeasurementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BiomarkerMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerMeasurementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BiomarkerMeasurementAggregateArgs>(args: Subset<T, BiomarkerMeasurementAggregateArgs>): Prisma.PrismaPromise<GetBiomarkerMeasurementAggregateType<T>>

    /**
     * Group by BiomarkerMeasurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiomarkerMeasurementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BiomarkerMeasurementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BiomarkerMeasurementGroupByArgs['orderBy'] }
        : { orderBy?: BiomarkerMeasurementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BiomarkerMeasurementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBiomarkerMeasurementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BiomarkerMeasurement model
   */
  readonly fields: BiomarkerMeasurementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BiomarkerMeasurement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BiomarkerMeasurementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    biomarker<T extends BiomarkerMeasurement$biomarkerArgs<ExtArgs> = {}>(args?: Subset<T, BiomarkerMeasurement$biomarkerArgs<ExtArgs>>): Prisma__BiomarkerClient<$Result.GetResult<Prisma.$BiomarkerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    panelUpload<T extends BiomarkerMeasurement$panelUploadArgs<ExtArgs> = {}>(args?: Subset<T, BiomarkerMeasurement$panelUploadArgs<ExtArgs>>): Prisma__PanelUploadClient<$Result.GetResult<Prisma.$PanelUploadPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BiomarkerMeasurement model
   */ 
  interface BiomarkerMeasurementFieldRefs {
    readonly id: FieldRef<"BiomarkerMeasurement", 'String'>
    readonly userId: FieldRef<"BiomarkerMeasurement", 'String'>
    readonly biomarkerId: FieldRef<"BiomarkerMeasurement", 'String'>
    readonly panelUploadId: FieldRef<"BiomarkerMeasurement", 'String'>
    readonly markerName: FieldRef<"BiomarkerMeasurement", 'String'>
    readonly value: FieldRef<"BiomarkerMeasurement", 'Decimal'>
    readonly unit: FieldRef<"BiomarkerMeasurement", 'String'>
    readonly referenceLow: FieldRef<"BiomarkerMeasurement", 'Decimal'>
    readonly referenceHigh: FieldRef<"BiomarkerMeasurement", 'Decimal'>
    readonly capturedAt: FieldRef<"BiomarkerMeasurement", 'DateTime'>
    readonly status: FieldRef<"BiomarkerMeasurement", 'MeasurementStatus'>
    readonly source: FieldRef<"BiomarkerMeasurement", 'BiomarkerSource'>
    readonly confidence: FieldRef<"BiomarkerMeasurement", 'Decimal'>
    readonly flags: FieldRef<"BiomarkerMeasurement", 'Json'>
    readonly createdAt: FieldRef<"BiomarkerMeasurement", 'DateTime'>
    readonly updatedAt: FieldRef<"BiomarkerMeasurement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BiomarkerMeasurement findUnique
   */
  export type BiomarkerMeasurementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerMeasurement
     */
    select?: BiomarkerMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which BiomarkerMeasurement to fetch.
     */
    where: BiomarkerMeasurementWhereUniqueInput
  }

  /**
   * BiomarkerMeasurement findUniqueOrThrow
   */
  export type BiomarkerMeasurementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerMeasurement
     */
    select?: BiomarkerMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which BiomarkerMeasurement to fetch.
     */
    where: BiomarkerMeasurementWhereUniqueInput
  }

  /**
   * BiomarkerMeasurement findFirst
   */
  export type BiomarkerMeasurementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerMeasurement
     */
    select?: BiomarkerMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which BiomarkerMeasurement to fetch.
     */
    where?: BiomarkerMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiomarkerMeasurements to fetch.
     */
    orderBy?: BiomarkerMeasurementOrderByWithRelationInput | BiomarkerMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BiomarkerMeasurements.
     */
    cursor?: BiomarkerMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiomarkerMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiomarkerMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BiomarkerMeasurements.
     */
    distinct?: BiomarkerMeasurementScalarFieldEnum | BiomarkerMeasurementScalarFieldEnum[]
  }

  /**
   * BiomarkerMeasurement findFirstOrThrow
   */
  export type BiomarkerMeasurementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerMeasurement
     */
    select?: BiomarkerMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which BiomarkerMeasurement to fetch.
     */
    where?: BiomarkerMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiomarkerMeasurements to fetch.
     */
    orderBy?: BiomarkerMeasurementOrderByWithRelationInput | BiomarkerMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BiomarkerMeasurements.
     */
    cursor?: BiomarkerMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiomarkerMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiomarkerMeasurements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BiomarkerMeasurements.
     */
    distinct?: BiomarkerMeasurementScalarFieldEnum | BiomarkerMeasurementScalarFieldEnum[]
  }

  /**
   * BiomarkerMeasurement findMany
   */
  export type BiomarkerMeasurementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerMeasurement
     */
    select?: BiomarkerMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerMeasurementInclude<ExtArgs> | null
    /**
     * Filter, which BiomarkerMeasurements to fetch.
     */
    where?: BiomarkerMeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiomarkerMeasurements to fetch.
     */
    orderBy?: BiomarkerMeasurementOrderByWithRelationInput | BiomarkerMeasurementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BiomarkerMeasurements.
     */
    cursor?: BiomarkerMeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiomarkerMeasurements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiomarkerMeasurements.
     */
    skip?: number
    distinct?: BiomarkerMeasurementScalarFieldEnum | BiomarkerMeasurementScalarFieldEnum[]
  }

  /**
   * BiomarkerMeasurement create
   */
  export type BiomarkerMeasurementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerMeasurement
     */
    select?: BiomarkerMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to create a BiomarkerMeasurement.
     */
    data: XOR<BiomarkerMeasurementCreateInput, BiomarkerMeasurementUncheckedCreateInput>
  }

  /**
   * BiomarkerMeasurement createMany
   */
  export type BiomarkerMeasurementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BiomarkerMeasurements.
     */
    data: BiomarkerMeasurementCreateManyInput | BiomarkerMeasurementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BiomarkerMeasurement createManyAndReturn
   */
  export type BiomarkerMeasurementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerMeasurement
     */
    select?: BiomarkerMeasurementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BiomarkerMeasurements.
     */
    data: BiomarkerMeasurementCreateManyInput | BiomarkerMeasurementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerMeasurementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BiomarkerMeasurement update
   */
  export type BiomarkerMeasurementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerMeasurement
     */
    select?: BiomarkerMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerMeasurementInclude<ExtArgs> | null
    /**
     * The data needed to update a BiomarkerMeasurement.
     */
    data: XOR<BiomarkerMeasurementUpdateInput, BiomarkerMeasurementUncheckedUpdateInput>
    /**
     * Choose, which BiomarkerMeasurement to update.
     */
    where: BiomarkerMeasurementWhereUniqueInput
  }

  /**
   * BiomarkerMeasurement updateMany
   */
  export type BiomarkerMeasurementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BiomarkerMeasurements.
     */
    data: XOR<BiomarkerMeasurementUpdateManyMutationInput, BiomarkerMeasurementUncheckedUpdateManyInput>
    /**
     * Filter which BiomarkerMeasurements to update
     */
    where?: BiomarkerMeasurementWhereInput
  }

  /**
   * BiomarkerMeasurement upsert
   */
  export type BiomarkerMeasurementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerMeasurement
     */
    select?: BiomarkerMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerMeasurementInclude<ExtArgs> | null
    /**
     * The filter to search for the BiomarkerMeasurement to update in case it exists.
     */
    where: BiomarkerMeasurementWhereUniqueInput
    /**
     * In case the BiomarkerMeasurement found by the `where` argument doesn't exist, create a new BiomarkerMeasurement with this data.
     */
    create: XOR<BiomarkerMeasurementCreateInput, BiomarkerMeasurementUncheckedCreateInput>
    /**
     * In case the BiomarkerMeasurement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BiomarkerMeasurementUpdateInput, BiomarkerMeasurementUncheckedUpdateInput>
  }

  /**
   * BiomarkerMeasurement delete
   */
  export type BiomarkerMeasurementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerMeasurement
     */
    select?: BiomarkerMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerMeasurementInclude<ExtArgs> | null
    /**
     * Filter which BiomarkerMeasurement to delete.
     */
    where: BiomarkerMeasurementWhereUniqueInput
  }

  /**
   * BiomarkerMeasurement deleteMany
   */
  export type BiomarkerMeasurementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BiomarkerMeasurements to delete
     */
    where?: BiomarkerMeasurementWhereInput
  }

  /**
   * BiomarkerMeasurement.biomarker
   */
  export type BiomarkerMeasurement$biomarkerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Biomarker
     */
    select?: BiomarkerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerInclude<ExtArgs> | null
    where?: BiomarkerWhereInput
  }

  /**
   * BiomarkerMeasurement.panelUpload
   */
  export type BiomarkerMeasurement$panelUploadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PanelUpload
     */
    select?: PanelUploadSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PanelUploadInclude<ExtArgs> | null
    where?: PanelUploadWhereInput
  }

  /**
   * BiomarkerMeasurement without action
   */
  export type BiomarkerMeasurementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerMeasurement
     */
    select?: BiomarkerMeasurementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerMeasurementInclude<ExtArgs> | null
  }


  /**
   * Model AuthProvider
   */

  export type AggregateAuthProvider = {
    _count: AuthProviderCountAggregateOutputType | null
    _min: AuthProviderMinAggregateOutputType | null
    _max: AuthProviderMaxAggregateOutputType | null
  }

  export type AuthProviderMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.AuthProviderType | null
    providerUserId: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    linkedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthProviderMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.AuthProviderType | null
    providerUserId: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    linkedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AuthProviderCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    providerUserId: number
    accessToken: number
    refreshToken: number
    scopes: number
    expiresAt: number
    linkedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AuthProviderMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    providerUserId?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    linkedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthProviderMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    providerUserId?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    linkedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AuthProviderCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    providerUserId?: true
    accessToken?: true
    refreshToken?: true
    scopes?: true
    expiresAt?: true
    linkedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AuthProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthProvider to aggregate.
     */
    where?: AuthProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthProviders to fetch.
     */
    orderBy?: AuthProviderOrderByWithRelationInput | AuthProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuthProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuthProviders
    **/
    _count?: true | AuthProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuthProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuthProviderMaxAggregateInputType
  }

  export type GetAuthProviderAggregateType<T extends AuthProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateAuthProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuthProvider[P]>
      : GetScalarType<T[P], AggregateAuthProvider[P]>
  }




  export type AuthProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuthProviderWhereInput
    orderBy?: AuthProviderOrderByWithAggregationInput | AuthProviderOrderByWithAggregationInput[]
    by: AuthProviderScalarFieldEnum[] | AuthProviderScalarFieldEnum
    having?: AuthProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuthProviderCountAggregateInputType | true
    _min?: AuthProviderMinAggregateInputType
    _max?: AuthProviderMaxAggregateInputType
  }

  export type AuthProviderGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.AuthProviderType
    providerUserId: string | null
    accessToken: string | null
    refreshToken: string | null
    scopes: string[]
    expiresAt: Date | null
    linkedAt: Date
    createdAt: Date
    updatedAt: Date
    _count: AuthProviderCountAggregateOutputType | null
    _min: AuthProviderMinAggregateOutputType | null
    _max: AuthProviderMaxAggregateOutputType | null
  }

  type GetAuthProviderGroupByPayload<T extends AuthProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuthProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuthProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuthProviderGroupByOutputType[P]>
            : GetScalarType<T[P], AuthProviderGroupByOutputType[P]>
        }
      >
    >


  export type AuthProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    providerUserId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    scopes?: boolean
    expiresAt?: boolean
    linkedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authProvider"]>

  export type AuthProviderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    providerUserId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    scopes?: boolean
    expiresAt?: boolean
    linkedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["authProvider"]>

  export type AuthProviderSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    providerUserId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    scopes?: boolean
    expiresAt?: boolean
    linkedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AuthProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuthProviderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuthProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuthProvider"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.AuthProviderType
      providerUserId: string | null
      accessToken: string | null
      refreshToken: string | null
      scopes: string[]
      expiresAt: Date | null
      linkedAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["authProvider"]>
    composites: {}
  }

  type AuthProviderGetPayload<S extends boolean | null | undefined | AuthProviderDefaultArgs> = $Result.GetResult<Prisma.$AuthProviderPayload, S>

  type AuthProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuthProviderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuthProviderCountAggregateInputType | true
    }

  export interface AuthProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuthProvider'], meta: { name: 'AuthProvider' } }
    /**
     * Find zero or one AuthProvider that matches the filter.
     * @param {AuthProviderFindUniqueArgs} args - Arguments to find a AuthProvider
     * @example
     * // Get one AuthProvider
     * const authProvider = await prisma.authProvider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuthProviderFindUniqueArgs>(args: SelectSubset<T, AuthProviderFindUniqueArgs<ExtArgs>>): Prisma__AuthProviderClient<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuthProvider that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuthProviderFindUniqueOrThrowArgs} args - Arguments to find a AuthProvider
     * @example
     * // Get one AuthProvider
     * const authProvider = await prisma.authProvider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuthProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, AuthProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuthProviderClient<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuthProvider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthProviderFindFirstArgs} args - Arguments to find a AuthProvider
     * @example
     * // Get one AuthProvider
     * const authProvider = await prisma.authProvider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuthProviderFindFirstArgs>(args?: SelectSubset<T, AuthProviderFindFirstArgs<ExtArgs>>): Prisma__AuthProviderClient<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuthProvider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthProviderFindFirstOrThrowArgs} args - Arguments to find a AuthProvider
     * @example
     * // Get one AuthProvider
     * const authProvider = await prisma.authProvider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuthProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, AuthProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuthProviderClient<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuthProviders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuthProviders
     * const authProviders = await prisma.authProvider.findMany()
     * 
     * // Get first 10 AuthProviders
     * const authProviders = await prisma.authProvider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const authProviderWithIdOnly = await prisma.authProvider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuthProviderFindManyArgs>(args?: SelectSubset<T, AuthProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuthProvider.
     * @param {AuthProviderCreateArgs} args - Arguments to create a AuthProvider.
     * @example
     * // Create one AuthProvider
     * const AuthProvider = await prisma.authProvider.create({
     *   data: {
     *     // ... data to create a AuthProvider
     *   }
     * })
     * 
     */
    create<T extends AuthProviderCreateArgs>(args: SelectSubset<T, AuthProviderCreateArgs<ExtArgs>>): Prisma__AuthProviderClient<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuthProviders.
     * @param {AuthProviderCreateManyArgs} args - Arguments to create many AuthProviders.
     * @example
     * // Create many AuthProviders
     * const authProvider = await prisma.authProvider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuthProviderCreateManyArgs>(args?: SelectSubset<T, AuthProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuthProviders and returns the data saved in the database.
     * @param {AuthProviderCreateManyAndReturnArgs} args - Arguments to create many AuthProviders.
     * @example
     * // Create many AuthProviders
     * const authProvider = await prisma.authProvider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuthProviders and only return the `id`
     * const authProviderWithIdOnly = await prisma.authProvider.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuthProviderCreateManyAndReturnArgs>(args?: SelectSubset<T, AuthProviderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuthProvider.
     * @param {AuthProviderDeleteArgs} args - Arguments to delete one AuthProvider.
     * @example
     * // Delete one AuthProvider
     * const AuthProvider = await prisma.authProvider.delete({
     *   where: {
     *     // ... filter to delete one AuthProvider
     *   }
     * })
     * 
     */
    delete<T extends AuthProviderDeleteArgs>(args: SelectSubset<T, AuthProviderDeleteArgs<ExtArgs>>): Prisma__AuthProviderClient<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuthProvider.
     * @param {AuthProviderUpdateArgs} args - Arguments to update one AuthProvider.
     * @example
     * // Update one AuthProvider
     * const authProvider = await prisma.authProvider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuthProviderUpdateArgs>(args: SelectSubset<T, AuthProviderUpdateArgs<ExtArgs>>): Prisma__AuthProviderClient<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuthProviders.
     * @param {AuthProviderDeleteManyArgs} args - Arguments to filter AuthProviders to delete.
     * @example
     * // Delete a few AuthProviders
     * const { count } = await prisma.authProvider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuthProviderDeleteManyArgs>(args?: SelectSubset<T, AuthProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuthProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuthProviders
     * const authProvider = await prisma.authProvider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuthProviderUpdateManyArgs>(args: SelectSubset<T, AuthProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuthProvider.
     * @param {AuthProviderUpsertArgs} args - Arguments to update or create a AuthProvider.
     * @example
     * // Update or create a AuthProvider
     * const authProvider = await prisma.authProvider.upsert({
     *   create: {
     *     // ... data to create a AuthProvider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuthProvider we want to update
     *   }
     * })
     */
    upsert<T extends AuthProviderUpsertArgs>(args: SelectSubset<T, AuthProviderUpsertArgs<ExtArgs>>): Prisma__AuthProviderClient<$Result.GetResult<Prisma.$AuthProviderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuthProviders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthProviderCountArgs} args - Arguments to filter AuthProviders to count.
     * @example
     * // Count the number of AuthProviders
     * const count = await prisma.authProvider.count({
     *   where: {
     *     // ... the filter for the AuthProviders we want to count
     *   }
     * })
    **/
    count<T extends AuthProviderCountArgs>(
      args?: Subset<T, AuthProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuthProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuthProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuthProviderAggregateArgs>(args: Subset<T, AuthProviderAggregateArgs>): Prisma.PrismaPromise<GetAuthProviderAggregateType<T>>

    /**
     * Group by AuthProvider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuthProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuthProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuthProviderGroupByArgs['orderBy'] }
        : { orderBy?: AuthProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuthProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuthProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuthProvider model
   */
  readonly fields: AuthProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuthProvider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuthProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuthProvider model
   */ 
  interface AuthProviderFieldRefs {
    readonly id: FieldRef<"AuthProvider", 'String'>
    readonly userId: FieldRef<"AuthProvider", 'String'>
    readonly type: FieldRef<"AuthProvider", 'AuthProviderType'>
    readonly providerUserId: FieldRef<"AuthProvider", 'String'>
    readonly accessToken: FieldRef<"AuthProvider", 'String'>
    readonly refreshToken: FieldRef<"AuthProvider", 'String'>
    readonly scopes: FieldRef<"AuthProvider", 'String[]'>
    readonly expiresAt: FieldRef<"AuthProvider", 'DateTime'>
    readonly linkedAt: FieldRef<"AuthProvider", 'DateTime'>
    readonly createdAt: FieldRef<"AuthProvider", 'DateTime'>
    readonly updatedAt: FieldRef<"AuthProvider", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuthProvider findUnique
   */
  export type AuthProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    /**
     * Filter, which AuthProvider to fetch.
     */
    where: AuthProviderWhereUniqueInput
  }

  /**
   * AuthProvider findUniqueOrThrow
   */
  export type AuthProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    /**
     * Filter, which AuthProvider to fetch.
     */
    where: AuthProviderWhereUniqueInput
  }

  /**
   * AuthProvider findFirst
   */
  export type AuthProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    /**
     * Filter, which AuthProvider to fetch.
     */
    where?: AuthProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthProviders to fetch.
     */
    orderBy?: AuthProviderOrderByWithRelationInput | AuthProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthProviders.
     */
    cursor?: AuthProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthProviders.
     */
    distinct?: AuthProviderScalarFieldEnum | AuthProviderScalarFieldEnum[]
  }

  /**
   * AuthProvider findFirstOrThrow
   */
  export type AuthProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    /**
     * Filter, which AuthProvider to fetch.
     */
    where?: AuthProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthProviders to fetch.
     */
    orderBy?: AuthProviderOrderByWithRelationInput | AuthProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuthProviders.
     */
    cursor?: AuthProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthProviders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuthProviders.
     */
    distinct?: AuthProviderScalarFieldEnum | AuthProviderScalarFieldEnum[]
  }

  /**
   * AuthProvider findMany
   */
  export type AuthProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    /**
     * Filter, which AuthProviders to fetch.
     */
    where?: AuthProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuthProviders to fetch.
     */
    orderBy?: AuthProviderOrderByWithRelationInput | AuthProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuthProviders.
     */
    cursor?: AuthProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuthProviders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuthProviders.
     */
    skip?: number
    distinct?: AuthProviderScalarFieldEnum | AuthProviderScalarFieldEnum[]
  }

  /**
   * AuthProvider create
   */
  export type AuthProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a AuthProvider.
     */
    data: XOR<AuthProviderCreateInput, AuthProviderUncheckedCreateInput>
  }

  /**
   * AuthProvider createMany
   */
  export type AuthProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuthProviders.
     */
    data: AuthProviderCreateManyInput | AuthProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuthProvider createManyAndReturn
   */
  export type AuthProviderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuthProviders.
     */
    data: AuthProviderCreateManyInput | AuthProviderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuthProvider update
   */
  export type AuthProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a AuthProvider.
     */
    data: XOR<AuthProviderUpdateInput, AuthProviderUncheckedUpdateInput>
    /**
     * Choose, which AuthProvider to update.
     */
    where: AuthProviderWhereUniqueInput
  }

  /**
   * AuthProvider updateMany
   */
  export type AuthProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuthProviders.
     */
    data: XOR<AuthProviderUpdateManyMutationInput, AuthProviderUncheckedUpdateManyInput>
    /**
     * Filter which AuthProviders to update
     */
    where?: AuthProviderWhereInput
  }

  /**
   * AuthProvider upsert
   */
  export type AuthProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the AuthProvider to update in case it exists.
     */
    where: AuthProviderWhereUniqueInput
    /**
     * In case the AuthProvider found by the `where` argument doesn't exist, create a new AuthProvider with this data.
     */
    create: XOR<AuthProviderCreateInput, AuthProviderUncheckedCreateInput>
    /**
     * In case the AuthProvider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuthProviderUpdateInput, AuthProviderUncheckedUpdateInput>
  }

  /**
   * AuthProvider delete
   */
  export type AuthProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
    /**
     * Filter which AuthProvider to delete.
     */
    where: AuthProviderWhereUniqueInput
  }

  /**
   * AuthProvider deleteMany
   */
  export type AuthProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuthProviders to delete
     */
    where?: AuthProviderWhereInput
  }

  /**
   * AuthProvider without action
   */
  export type AuthProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuthProvider
     */
    select?: AuthProviderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuthProviderInclude<ExtArgs> | null
  }


  /**
   * Model LoginAudit
   */

  export type AggregateLoginAudit = {
    _count: LoginAuditCountAggregateOutputType | null
    _min: LoginAuditMinAggregateOutputType | null
    _max: LoginAuditMaxAggregateOutputType | null
  }

  export type LoginAuditMinAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    provider: $Enums.AuthProviderType | null
    success: boolean | null
    ipAddress: string | null
    userAgent: string | null
    failureReason: string | null
    createdAt: Date | null
  }

  export type LoginAuditMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    email: string | null
    provider: $Enums.AuthProviderType | null
    success: boolean | null
    ipAddress: string | null
    userAgent: string | null
    failureReason: string | null
    createdAt: Date | null
  }

  export type LoginAuditCountAggregateOutputType = {
    id: number
    userId: number
    email: number
    provider: number
    success: number
    ipAddress: number
    userAgent: number
    failureReason: number
    createdAt: number
    _all: number
  }


  export type LoginAuditMinAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    provider?: true
    success?: true
    ipAddress?: true
    userAgent?: true
    failureReason?: true
    createdAt?: true
  }

  export type LoginAuditMaxAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    provider?: true
    success?: true
    ipAddress?: true
    userAgent?: true
    failureReason?: true
    createdAt?: true
  }

  export type LoginAuditCountAggregateInputType = {
    id?: true
    userId?: true
    email?: true
    provider?: true
    success?: true
    ipAddress?: true
    userAgent?: true
    failureReason?: true
    createdAt?: true
    _all?: true
  }

  export type LoginAuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginAudit to aggregate.
     */
    where?: LoginAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginAudits to fetch.
     */
    orderBy?: LoginAuditOrderByWithRelationInput | LoginAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LoginAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LoginAudits
    **/
    _count?: true | LoginAuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LoginAuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LoginAuditMaxAggregateInputType
  }

  export type GetLoginAuditAggregateType<T extends LoginAuditAggregateArgs> = {
        [P in keyof T & keyof AggregateLoginAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLoginAudit[P]>
      : GetScalarType<T[P], AggregateLoginAudit[P]>
  }




  export type LoginAuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LoginAuditWhereInput
    orderBy?: LoginAuditOrderByWithAggregationInput | LoginAuditOrderByWithAggregationInput[]
    by: LoginAuditScalarFieldEnum[] | LoginAuditScalarFieldEnum
    having?: LoginAuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LoginAuditCountAggregateInputType | true
    _min?: LoginAuditMinAggregateInputType
    _max?: LoginAuditMaxAggregateInputType
  }

  export type LoginAuditGroupByOutputType = {
    id: string
    userId: string | null
    email: string
    provider: $Enums.AuthProviderType
    success: boolean
    ipAddress: string | null
    userAgent: string | null
    failureReason: string | null
    createdAt: Date
    _count: LoginAuditCountAggregateOutputType | null
    _min: LoginAuditMinAggregateOutputType | null
    _max: LoginAuditMaxAggregateOutputType | null
  }

  type GetLoginAuditGroupByPayload<T extends LoginAuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LoginAuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LoginAuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LoginAuditGroupByOutputType[P]>
            : GetScalarType<T[P], LoginAuditGroupByOutputType[P]>
        }
      >
    >


  export type LoginAuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    provider?: boolean
    success?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    failureReason?: boolean
    createdAt?: boolean
    user?: boolean | LoginAudit$userArgs<ExtArgs>
  }, ExtArgs["result"]["loginAudit"]>

  export type LoginAuditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    email?: boolean
    provider?: boolean
    success?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    failureReason?: boolean
    createdAt?: boolean
    user?: boolean | LoginAudit$userArgs<ExtArgs>
  }, ExtArgs["result"]["loginAudit"]>

  export type LoginAuditSelectScalar = {
    id?: boolean
    userId?: boolean
    email?: boolean
    provider?: boolean
    success?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    failureReason?: boolean
    createdAt?: boolean
  }

  export type LoginAuditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | LoginAudit$userArgs<ExtArgs>
  }
  export type LoginAuditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | LoginAudit$userArgs<ExtArgs>
  }

  export type $LoginAuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LoginAudit"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      email: string
      provider: $Enums.AuthProviderType
      success: boolean
      ipAddress: string | null
      userAgent: string | null
      failureReason: string | null
      createdAt: Date
    }, ExtArgs["result"]["loginAudit"]>
    composites: {}
  }

  type LoginAuditGetPayload<S extends boolean | null | undefined | LoginAuditDefaultArgs> = $Result.GetResult<Prisma.$LoginAuditPayload, S>

  type LoginAuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LoginAuditFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LoginAuditCountAggregateInputType | true
    }

  export interface LoginAuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LoginAudit'], meta: { name: 'LoginAudit' } }
    /**
     * Find zero or one LoginAudit that matches the filter.
     * @param {LoginAuditFindUniqueArgs} args - Arguments to find a LoginAudit
     * @example
     * // Get one LoginAudit
     * const loginAudit = await prisma.loginAudit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LoginAuditFindUniqueArgs>(args: SelectSubset<T, LoginAuditFindUniqueArgs<ExtArgs>>): Prisma__LoginAuditClient<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LoginAudit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LoginAuditFindUniqueOrThrowArgs} args - Arguments to find a LoginAudit
     * @example
     * // Get one LoginAudit
     * const loginAudit = await prisma.loginAudit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LoginAuditFindUniqueOrThrowArgs>(args: SelectSubset<T, LoginAuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LoginAuditClient<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LoginAudit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAuditFindFirstArgs} args - Arguments to find a LoginAudit
     * @example
     * // Get one LoginAudit
     * const loginAudit = await prisma.loginAudit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LoginAuditFindFirstArgs>(args?: SelectSubset<T, LoginAuditFindFirstArgs<ExtArgs>>): Prisma__LoginAuditClient<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LoginAudit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAuditFindFirstOrThrowArgs} args - Arguments to find a LoginAudit
     * @example
     * // Get one LoginAudit
     * const loginAudit = await prisma.loginAudit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LoginAuditFindFirstOrThrowArgs>(args?: SelectSubset<T, LoginAuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__LoginAuditClient<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LoginAudits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LoginAudits
     * const loginAudits = await prisma.loginAudit.findMany()
     * 
     * // Get first 10 LoginAudits
     * const loginAudits = await prisma.loginAudit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const loginAuditWithIdOnly = await prisma.loginAudit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LoginAuditFindManyArgs>(args?: SelectSubset<T, LoginAuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LoginAudit.
     * @param {LoginAuditCreateArgs} args - Arguments to create a LoginAudit.
     * @example
     * // Create one LoginAudit
     * const LoginAudit = await prisma.loginAudit.create({
     *   data: {
     *     // ... data to create a LoginAudit
     *   }
     * })
     * 
     */
    create<T extends LoginAuditCreateArgs>(args: SelectSubset<T, LoginAuditCreateArgs<ExtArgs>>): Prisma__LoginAuditClient<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LoginAudits.
     * @param {LoginAuditCreateManyArgs} args - Arguments to create many LoginAudits.
     * @example
     * // Create many LoginAudits
     * const loginAudit = await prisma.loginAudit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LoginAuditCreateManyArgs>(args?: SelectSubset<T, LoginAuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LoginAudits and returns the data saved in the database.
     * @param {LoginAuditCreateManyAndReturnArgs} args - Arguments to create many LoginAudits.
     * @example
     * // Create many LoginAudits
     * const loginAudit = await prisma.loginAudit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LoginAudits and only return the `id`
     * const loginAuditWithIdOnly = await prisma.loginAudit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LoginAuditCreateManyAndReturnArgs>(args?: SelectSubset<T, LoginAuditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LoginAudit.
     * @param {LoginAuditDeleteArgs} args - Arguments to delete one LoginAudit.
     * @example
     * // Delete one LoginAudit
     * const LoginAudit = await prisma.loginAudit.delete({
     *   where: {
     *     // ... filter to delete one LoginAudit
     *   }
     * })
     * 
     */
    delete<T extends LoginAuditDeleteArgs>(args: SelectSubset<T, LoginAuditDeleteArgs<ExtArgs>>): Prisma__LoginAuditClient<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LoginAudit.
     * @param {LoginAuditUpdateArgs} args - Arguments to update one LoginAudit.
     * @example
     * // Update one LoginAudit
     * const loginAudit = await prisma.loginAudit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LoginAuditUpdateArgs>(args: SelectSubset<T, LoginAuditUpdateArgs<ExtArgs>>): Prisma__LoginAuditClient<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LoginAudits.
     * @param {LoginAuditDeleteManyArgs} args - Arguments to filter LoginAudits to delete.
     * @example
     * // Delete a few LoginAudits
     * const { count } = await prisma.loginAudit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LoginAuditDeleteManyArgs>(args?: SelectSubset<T, LoginAuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LoginAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LoginAudits
     * const loginAudit = await prisma.loginAudit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LoginAuditUpdateManyArgs>(args: SelectSubset<T, LoginAuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LoginAudit.
     * @param {LoginAuditUpsertArgs} args - Arguments to update or create a LoginAudit.
     * @example
     * // Update or create a LoginAudit
     * const loginAudit = await prisma.loginAudit.upsert({
     *   create: {
     *     // ... data to create a LoginAudit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LoginAudit we want to update
     *   }
     * })
     */
    upsert<T extends LoginAuditUpsertArgs>(args: SelectSubset<T, LoginAuditUpsertArgs<ExtArgs>>): Prisma__LoginAuditClient<$Result.GetResult<Prisma.$LoginAuditPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LoginAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAuditCountArgs} args - Arguments to filter LoginAudits to count.
     * @example
     * // Count the number of LoginAudits
     * const count = await prisma.loginAudit.count({
     *   where: {
     *     // ... the filter for the LoginAudits we want to count
     *   }
     * })
    **/
    count<T extends LoginAuditCountArgs>(
      args?: Subset<T, LoginAuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LoginAuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LoginAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LoginAuditAggregateArgs>(args: Subset<T, LoginAuditAggregateArgs>): Prisma.PrismaPromise<GetLoginAuditAggregateType<T>>

    /**
     * Group by LoginAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LoginAuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LoginAuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LoginAuditGroupByArgs['orderBy'] }
        : { orderBy?: LoginAuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LoginAuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLoginAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LoginAudit model
   */
  readonly fields: LoginAuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LoginAudit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LoginAuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends LoginAudit$userArgs<ExtArgs> = {}>(args?: Subset<T, LoginAudit$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LoginAudit model
   */ 
  interface LoginAuditFieldRefs {
    readonly id: FieldRef<"LoginAudit", 'String'>
    readonly userId: FieldRef<"LoginAudit", 'String'>
    readonly email: FieldRef<"LoginAudit", 'String'>
    readonly provider: FieldRef<"LoginAudit", 'AuthProviderType'>
    readonly success: FieldRef<"LoginAudit", 'Boolean'>
    readonly ipAddress: FieldRef<"LoginAudit", 'String'>
    readonly userAgent: FieldRef<"LoginAudit", 'String'>
    readonly failureReason: FieldRef<"LoginAudit", 'String'>
    readonly createdAt: FieldRef<"LoginAudit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LoginAudit findUnique
   */
  export type LoginAuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    /**
     * Filter, which LoginAudit to fetch.
     */
    where: LoginAuditWhereUniqueInput
  }

  /**
   * LoginAudit findUniqueOrThrow
   */
  export type LoginAuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    /**
     * Filter, which LoginAudit to fetch.
     */
    where: LoginAuditWhereUniqueInput
  }

  /**
   * LoginAudit findFirst
   */
  export type LoginAuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    /**
     * Filter, which LoginAudit to fetch.
     */
    where?: LoginAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginAudits to fetch.
     */
    orderBy?: LoginAuditOrderByWithRelationInput | LoginAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginAudits.
     */
    cursor?: LoginAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginAudits.
     */
    distinct?: LoginAuditScalarFieldEnum | LoginAuditScalarFieldEnum[]
  }

  /**
   * LoginAudit findFirstOrThrow
   */
  export type LoginAuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    /**
     * Filter, which LoginAudit to fetch.
     */
    where?: LoginAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginAudits to fetch.
     */
    orderBy?: LoginAuditOrderByWithRelationInput | LoginAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LoginAudits.
     */
    cursor?: LoginAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LoginAudits.
     */
    distinct?: LoginAuditScalarFieldEnum | LoginAuditScalarFieldEnum[]
  }

  /**
   * LoginAudit findMany
   */
  export type LoginAuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    /**
     * Filter, which LoginAudits to fetch.
     */
    where?: LoginAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LoginAudits to fetch.
     */
    orderBy?: LoginAuditOrderByWithRelationInput | LoginAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LoginAudits.
     */
    cursor?: LoginAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LoginAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LoginAudits.
     */
    skip?: number
    distinct?: LoginAuditScalarFieldEnum | LoginAuditScalarFieldEnum[]
  }

  /**
   * LoginAudit create
   */
  export type LoginAuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    /**
     * The data needed to create a LoginAudit.
     */
    data: XOR<LoginAuditCreateInput, LoginAuditUncheckedCreateInput>
  }

  /**
   * LoginAudit createMany
   */
  export type LoginAuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LoginAudits.
     */
    data: LoginAuditCreateManyInput | LoginAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LoginAudit createManyAndReturn
   */
  export type LoginAuditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LoginAudits.
     */
    data: LoginAuditCreateManyInput | LoginAuditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LoginAudit update
   */
  export type LoginAuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    /**
     * The data needed to update a LoginAudit.
     */
    data: XOR<LoginAuditUpdateInput, LoginAuditUncheckedUpdateInput>
    /**
     * Choose, which LoginAudit to update.
     */
    where: LoginAuditWhereUniqueInput
  }

  /**
   * LoginAudit updateMany
   */
  export type LoginAuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LoginAudits.
     */
    data: XOR<LoginAuditUpdateManyMutationInput, LoginAuditUncheckedUpdateManyInput>
    /**
     * Filter which LoginAudits to update
     */
    where?: LoginAuditWhereInput
  }

  /**
   * LoginAudit upsert
   */
  export type LoginAuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    /**
     * The filter to search for the LoginAudit to update in case it exists.
     */
    where: LoginAuditWhereUniqueInput
    /**
     * In case the LoginAudit found by the `where` argument doesn't exist, create a new LoginAudit with this data.
     */
    create: XOR<LoginAuditCreateInput, LoginAuditUncheckedCreateInput>
    /**
     * In case the LoginAudit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LoginAuditUpdateInput, LoginAuditUncheckedUpdateInput>
  }

  /**
   * LoginAudit delete
   */
  export type LoginAuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
    /**
     * Filter which LoginAudit to delete.
     */
    where: LoginAuditWhereUniqueInput
  }

  /**
   * LoginAudit deleteMany
   */
  export type LoginAuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LoginAudits to delete
     */
    where?: LoginAuditWhereInput
  }

  /**
   * LoginAudit.user
   */
  export type LoginAudit$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LoginAudit without action
   */
  export type LoginAuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LoginAudit
     */
    select?: LoginAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LoginAuditInclude<ExtArgs> | null
  }


  /**
   * Model InsightAction
   */

  export type AggregateInsightAction = {
    _count: InsightActionCountAggregateOutputType | null
    _min: InsightActionMinAggregateOutputType | null
    _max: InsightActionMaxAggregateOutputType | null
  }

  export type InsightActionMinAggregateOutputType = {
    id: string | null
    insightId: string | null
    actorId: string | null
    actionType: $Enums.InsightActionType | null
    notes: string | null
    createdAt: Date | null
  }

  export type InsightActionMaxAggregateOutputType = {
    id: string | null
    insightId: string | null
    actorId: string | null
    actionType: $Enums.InsightActionType | null
    notes: string | null
    createdAt: Date | null
  }

  export type InsightActionCountAggregateOutputType = {
    id: number
    insightId: number
    actorId: number
    actionType: number
    notes: number
    createdAt: number
    _all: number
  }


  export type InsightActionMinAggregateInputType = {
    id?: true
    insightId?: true
    actorId?: true
    actionType?: true
    notes?: true
    createdAt?: true
  }

  export type InsightActionMaxAggregateInputType = {
    id?: true
    insightId?: true
    actorId?: true
    actionType?: true
    notes?: true
    createdAt?: true
  }

  export type InsightActionCountAggregateInputType = {
    id?: true
    insightId?: true
    actorId?: true
    actionType?: true
    notes?: true
    createdAt?: true
    _all?: true
  }

  export type InsightActionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsightAction to aggregate.
     */
    where?: InsightActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightActions to fetch.
     */
    orderBy?: InsightActionOrderByWithRelationInput | InsightActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsightActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InsightActions
    **/
    _count?: true | InsightActionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsightActionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsightActionMaxAggregateInputType
  }

  export type GetInsightActionAggregateType<T extends InsightActionAggregateArgs> = {
        [P in keyof T & keyof AggregateInsightAction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsightAction[P]>
      : GetScalarType<T[P], AggregateInsightAction[P]>
  }




  export type InsightActionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightActionWhereInput
    orderBy?: InsightActionOrderByWithAggregationInput | InsightActionOrderByWithAggregationInput[]
    by: InsightActionScalarFieldEnum[] | InsightActionScalarFieldEnum
    having?: InsightActionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsightActionCountAggregateInputType | true
    _min?: InsightActionMinAggregateInputType
    _max?: InsightActionMaxAggregateInputType
  }

  export type InsightActionGroupByOutputType = {
    id: string
    insightId: string
    actorId: string | null
    actionType: $Enums.InsightActionType
    notes: string | null
    createdAt: Date
    _count: InsightActionCountAggregateOutputType | null
    _min: InsightActionMinAggregateOutputType | null
    _max: InsightActionMaxAggregateOutputType | null
  }

  type GetInsightActionGroupByPayload<T extends InsightActionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsightActionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsightActionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsightActionGroupByOutputType[P]>
            : GetScalarType<T[P], InsightActionGroupByOutputType[P]>
        }
      >
    >


  export type InsightActionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insightId?: boolean
    actorId?: boolean
    actionType?: boolean
    notes?: boolean
    createdAt?: boolean
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    actor?: boolean | InsightAction$actorArgs<ExtArgs>
  }, ExtArgs["result"]["insightAction"]>

  export type InsightActionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insightId?: boolean
    actorId?: boolean
    actionType?: boolean
    notes?: boolean
    createdAt?: boolean
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    actor?: boolean | InsightAction$actorArgs<ExtArgs>
  }, ExtArgs["result"]["insightAction"]>

  export type InsightActionSelectScalar = {
    id?: boolean
    insightId?: boolean
    actorId?: boolean
    actionType?: boolean
    notes?: boolean
    createdAt?: boolean
  }

  export type InsightActionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    actor?: boolean | InsightAction$actorArgs<ExtArgs>
  }
  export type InsightActionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insight?: boolean | InsightDefaultArgs<ExtArgs>
    actor?: boolean | InsightAction$actorArgs<ExtArgs>
  }

  export type $InsightActionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InsightAction"
    objects: {
      insight: Prisma.$InsightPayload<ExtArgs>
      actor: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      insightId: string
      actorId: string | null
      actionType: $Enums.InsightActionType
      notes: string | null
      createdAt: Date
    }, ExtArgs["result"]["insightAction"]>
    composites: {}
  }

  type InsightActionGetPayload<S extends boolean | null | undefined | InsightActionDefaultArgs> = $Result.GetResult<Prisma.$InsightActionPayload, S>

  type InsightActionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InsightActionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InsightActionCountAggregateInputType | true
    }

  export interface InsightActionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InsightAction'], meta: { name: 'InsightAction' } }
    /**
     * Find zero or one InsightAction that matches the filter.
     * @param {InsightActionFindUniqueArgs} args - Arguments to find a InsightAction
     * @example
     * // Get one InsightAction
     * const insightAction = await prisma.insightAction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsightActionFindUniqueArgs>(args: SelectSubset<T, InsightActionFindUniqueArgs<ExtArgs>>): Prisma__InsightActionClient<$Result.GetResult<Prisma.$InsightActionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InsightAction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InsightActionFindUniqueOrThrowArgs} args - Arguments to find a InsightAction
     * @example
     * // Get one InsightAction
     * const insightAction = await prisma.insightAction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsightActionFindUniqueOrThrowArgs>(args: SelectSubset<T, InsightActionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsightActionClient<$Result.GetResult<Prisma.$InsightActionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InsightAction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightActionFindFirstArgs} args - Arguments to find a InsightAction
     * @example
     * // Get one InsightAction
     * const insightAction = await prisma.insightAction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsightActionFindFirstArgs>(args?: SelectSubset<T, InsightActionFindFirstArgs<ExtArgs>>): Prisma__InsightActionClient<$Result.GetResult<Prisma.$InsightActionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InsightAction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightActionFindFirstOrThrowArgs} args - Arguments to find a InsightAction
     * @example
     * // Get one InsightAction
     * const insightAction = await prisma.insightAction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsightActionFindFirstOrThrowArgs>(args?: SelectSubset<T, InsightActionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsightActionClient<$Result.GetResult<Prisma.$InsightActionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InsightActions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightActionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InsightActions
     * const insightActions = await prisma.insightAction.findMany()
     * 
     * // Get first 10 InsightActions
     * const insightActions = await prisma.insightAction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insightActionWithIdOnly = await prisma.insightAction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsightActionFindManyArgs>(args?: SelectSubset<T, InsightActionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightActionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InsightAction.
     * @param {InsightActionCreateArgs} args - Arguments to create a InsightAction.
     * @example
     * // Create one InsightAction
     * const InsightAction = await prisma.insightAction.create({
     *   data: {
     *     // ... data to create a InsightAction
     *   }
     * })
     * 
     */
    create<T extends InsightActionCreateArgs>(args: SelectSubset<T, InsightActionCreateArgs<ExtArgs>>): Prisma__InsightActionClient<$Result.GetResult<Prisma.$InsightActionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InsightActions.
     * @param {InsightActionCreateManyArgs} args - Arguments to create many InsightActions.
     * @example
     * // Create many InsightActions
     * const insightAction = await prisma.insightAction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsightActionCreateManyArgs>(args?: SelectSubset<T, InsightActionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InsightActions and returns the data saved in the database.
     * @param {InsightActionCreateManyAndReturnArgs} args - Arguments to create many InsightActions.
     * @example
     * // Create many InsightActions
     * const insightAction = await prisma.insightAction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InsightActions and only return the `id`
     * const insightActionWithIdOnly = await prisma.insightAction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsightActionCreateManyAndReturnArgs>(args?: SelectSubset<T, InsightActionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightActionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InsightAction.
     * @param {InsightActionDeleteArgs} args - Arguments to delete one InsightAction.
     * @example
     * // Delete one InsightAction
     * const InsightAction = await prisma.insightAction.delete({
     *   where: {
     *     // ... filter to delete one InsightAction
     *   }
     * })
     * 
     */
    delete<T extends InsightActionDeleteArgs>(args: SelectSubset<T, InsightActionDeleteArgs<ExtArgs>>): Prisma__InsightActionClient<$Result.GetResult<Prisma.$InsightActionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InsightAction.
     * @param {InsightActionUpdateArgs} args - Arguments to update one InsightAction.
     * @example
     * // Update one InsightAction
     * const insightAction = await prisma.insightAction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsightActionUpdateArgs>(args: SelectSubset<T, InsightActionUpdateArgs<ExtArgs>>): Prisma__InsightActionClient<$Result.GetResult<Prisma.$InsightActionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InsightActions.
     * @param {InsightActionDeleteManyArgs} args - Arguments to filter InsightActions to delete.
     * @example
     * // Delete a few InsightActions
     * const { count } = await prisma.insightAction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsightActionDeleteManyArgs>(args?: SelectSubset<T, InsightActionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsightActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightActionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InsightActions
     * const insightAction = await prisma.insightAction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsightActionUpdateManyArgs>(args: SelectSubset<T, InsightActionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InsightAction.
     * @param {InsightActionUpsertArgs} args - Arguments to update or create a InsightAction.
     * @example
     * // Update or create a InsightAction
     * const insightAction = await prisma.insightAction.upsert({
     *   create: {
     *     // ... data to create a InsightAction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InsightAction we want to update
     *   }
     * })
     */
    upsert<T extends InsightActionUpsertArgs>(args: SelectSubset<T, InsightActionUpsertArgs<ExtArgs>>): Prisma__InsightActionClient<$Result.GetResult<Prisma.$InsightActionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InsightActions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightActionCountArgs} args - Arguments to filter InsightActions to count.
     * @example
     * // Count the number of InsightActions
     * const count = await prisma.insightAction.count({
     *   where: {
     *     // ... the filter for the InsightActions we want to count
     *   }
     * })
    **/
    count<T extends InsightActionCountArgs>(
      args?: Subset<T, InsightActionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsightActionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InsightAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightActionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsightActionAggregateArgs>(args: Subset<T, InsightActionAggregateArgs>): Prisma.PrismaPromise<GetInsightActionAggregateType<T>>

    /**
     * Group by InsightAction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightActionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsightActionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsightActionGroupByArgs['orderBy'] }
        : { orderBy?: InsightActionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsightActionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsightActionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InsightAction model
   */
  readonly fields: InsightActionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InsightAction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsightActionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insight<T extends InsightDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InsightDefaultArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    actor<T extends InsightAction$actorArgs<ExtArgs> = {}>(args?: Subset<T, InsightAction$actorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InsightAction model
   */ 
  interface InsightActionFieldRefs {
    readonly id: FieldRef<"InsightAction", 'String'>
    readonly insightId: FieldRef<"InsightAction", 'String'>
    readonly actorId: FieldRef<"InsightAction", 'String'>
    readonly actionType: FieldRef<"InsightAction", 'InsightActionType'>
    readonly notes: FieldRef<"InsightAction", 'String'>
    readonly createdAt: FieldRef<"InsightAction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InsightAction findUnique
   */
  export type InsightActionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightAction
     */
    select?: InsightActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightActionInclude<ExtArgs> | null
    /**
     * Filter, which InsightAction to fetch.
     */
    where: InsightActionWhereUniqueInput
  }

  /**
   * InsightAction findUniqueOrThrow
   */
  export type InsightActionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightAction
     */
    select?: InsightActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightActionInclude<ExtArgs> | null
    /**
     * Filter, which InsightAction to fetch.
     */
    where: InsightActionWhereUniqueInput
  }

  /**
   * InsightAction findFirst
   */
  export type InsightActionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightAction
     */
    select?: InsightActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightActionInclude<ExtArgs> | null
    /**
     * Filter, which InsightAction to fetch.
     */
    where?: InsightActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightActions to fetch.
     */
    orderBy?: InsightActionOrderByWithRelationInput | InsightActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsightActions.
     */
    cursor?: InsightActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsightActions.
     */
    distinct?: InsightActionScalarFieldEnum | InsightActionScalarFieldEnum[]
  }

  /**
   * InsightAction findFirstOrThrow
   */
  export type InsightActionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightAction
     */
    select?: InsightActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightActionInclude<ExtArgs> | null
    /**
     * Filter, which InsightAction to fetch.
     */
    where?: InsightActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightActions to fetch.
     */
    orderBy?: InsightActionOrderByWithRelationInput | InsightActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsightActions.
     */
    cursor?: InsightActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightActions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsightActions.
     */
    distinct?: InsightActionScalarFieldEnum | InsightActionScalarFieldEnum[]
  }

  /**
   * InsightAction findMany
   */
  export type InsightActionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightAction
     */
    select?: InsightActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightActionInclude<ExtArgs> | null
    /**
     * Filter, which InsightActions to fetch.
     */
    where?: InsightActionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightActions to fetch.
     */
    orderBy?: InsightActionOrderByWithRelationInput | InsightActionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InsightActions.
     */
    cursor?: InsightActionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightActions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightActions.
     */
    skip?: number
    distinct?: InsightActionScalarFieldEnum | InsightActionScalarFieldEnum[]
  }

  /**
   * InsightAction create
   */
  export type InsightActionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightAction
     */
    select?: InsightActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightActionInclude<ExtArgs> | null
    /**
     * The data needed to create a InsightAction.
     */
    data: XOR<InsightActionCreateInput, InsightActionUncheckedCreateInput>
  }

  /**
   * InsightAction createMany
   */
  export type InsightActionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InsightActions.
     */
    data: InsightActionCreateManyInput | InsightActionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InsightAction createManyAndReturn
   */
  export type InsightActionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightAction
     */
    select?: InsightActionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InsightActions.
     */
    data: InsightActionCreateManyInput | InsightActionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightActionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsightAction update
   */
  export type InsightActionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightAction
     */
    select?: InsightActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightActionInclude<ExtArgs> | null
    /**
     * The data needed to update a InsightAction.
     */
    data: XOR<InsightActionUpdateInput, InsightActionUncheckedUpdateInput>
    /**
     * Choose, which InsightAction to update.
     */
    where: InsightActionWhereUniqueInput
  }

  /**
   * InsightAction updateMany
   */
  export type InsightActionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InsightActions.
     */
    data: XOR<InsightActionUpdateManyMutationInput, InsightActionUncheckedUpdateManyInput>
    /**
     * Filter which InsightActions to update
     */
    where?: InsightActionWhereInput
  }

  /**
   * InsightAction upsert
   */
  export type InsightActionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightAction
     */
    select?: InsightActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightActionInclude<ExtArgs> | null
    /**
     * The filter to search for the InsightAction to update in case it exists.
     */
    where: InsightActionWhereUniqueInput
    /**
     * In case the InsightAction found by the `where` argument doesn't exist, create a new InsightAction with this data.
     */
    create: XOR<InsightActionCreateInput, InsightActionUncheckedCreateInput>
    /**
     * In case the InsightAction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsightActionUpdateInput, InsightActionUncheckedUpdateInput>
  }

  /**
   * InsightAction delete
   */
  export type InsightActionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightAction
     */
    select?: InsightActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightActionInclude<ExtArgs> | null
    /**
     * Filter which InsightAction to delete.
     */
    where: InsightActionWhereUniqueInput
  }

  /**
   * InsightAction deleteMany
   */
  export type InsightActionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsightActions to delete
     */
    where?: InsightActionWhereInput
  }

  /**
   * InsightAction.actor
   */
  export type InsightAction$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * InsightAction without action
   */
  export type InsightActionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightAction
     */
    select?: InsightActionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightActionInclude<ExtArgs> | null
  }


  /**
   * Model InsightGenerationJob
   */

  export type AggregateInsightGenerationJob = {
    _count: InsightGenerationJobCountAggregateOutputType | null
    _min: InsightGenerationJobMinAggregateOutputType | null
    _max: InsightGenerationJobMaxAggregateOutputType | null
  }

  export type InsightGenerationJobMinAggregateOutputType = {
    id: string | null
    insightId: string | null
    requestedById: string | null
    status: $Enums.InsightGenerationStatus | null
    cloudTaskName: string | null
    queue: string | null
    scheduledAt: Date | null
    dispatchedAt: Date | null
    completedAt: Date | null
    errorCode: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InsightGenerationJobMaxAggregateOutputType = {
    id: string | null
    insightId: string | null
    requestedById: string | null
    status: $Enums.InsightGenerationStatus | null
    cloudTaskName: string | null
    queue: string | null
    scheduledAt: Date | null
    dispatchedAt: Date | null
    completedAt: Date | null
    errorCode: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InsightGenerationJobCountAggregateOutputType = {
    id: number
    insightId: number
    requestedById: number
    status: number
    cloudTaskName: number
    queue: number
    payload: number
    scheduledAt: number
    dispatchedAt: number
    completedAt: number
    errorCode: number
    errorMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InsightGenerationJobMinAggregateInputType = {
    id?: true
    insightId?: true
    requestedById?: true
    status?: true
    cloudTaskName?: true
    queue?: true
    scheduledAt?: true
    dispatchedAt?: true
    completedAt?: true
    errorCode?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InsightGenerationJobMaxAggregateInputType = {
    id?: true
    insightId?: true
    requestedById?: true
    status?: true
    cloudTaskName?: true
    queue?: true
    scheduledAt?: true
    dispatchedAt?: true
    completedAt?: true
    errorCode?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InsightGenerationJobCountAggregateInputType = {
    id?: true
    insightId?: true
    requestedById?: true
    status?: true
    cloudTaskName?: true
    queue?: true
    payload?: true
    scheduledAt?: true
    dispatchedAt?: true
    completedAt?: true
    errorCode?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InsightGenerationJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsightGenerationJob to aggregate.
     */
    where?: InsightGenerationJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightGenerationJobs to fetch.
     */
    orderBy?: InsightGenerationJobOrderByWithRelationInput | InsightGenerationJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InsightGenerationJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightGenerationJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightGenerationJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InsightGenerationJobs
    **/
    _count?: true | InsightGenerationJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InsightGenerationJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InsightGenerationJobMaxAggregateInputType
  }

  export type GetInsightGenerationJobAggregateType<T extends InsightGenerationJobAggregateArgs> = {
        [P in keyof T & keyof AggregateInsightGenerationJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInsightGenerationJob[P]>
      : GetScalarType<T[P], AggregateInsightGenerationJob[P]>
  }




  export type InsightGenerationJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InsightGenerationJobWhereInput
    orderBy?: InsightGenerationJobOrderByWithAggregationInput | InsightGenerationJobOrderByWithAggregationInput[]
    by: InsightGenerationJobScalarFieldEnum[] | InsightGenerationJobScalarFieldEnum
    having?: InsightGenerationJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InsightGenerationJobCountAggregateInputType | true
    _min?: InsightGenerationJobMinAggregateInputType
    _max?: InsightGenerationJobMaxAggregateInputType
  }

  export type InsightGenerationJobGroupByOutputType = {
    id: string
    insightId: string | null
    requestedById: string | null
    status: $Enums.InsightGenerationStatus
    cloudTaskName: string | null
    queue: string | null
    payload: JsonValue | null
    scheduledAt: Date | null
    dispatchedAt: Date | null
    completedAt: Date | null
    errorCode: string | null
    errorMessage: string | null
    createdAt: Date
    updatedAt: Date
    _count: InsightGenerationJobCountAggregateOutputType | null
    _min: InsightGenerationJobMinAggregateOutputType | null
    _max: InsightGenerationJobMaxAggregateOutputType | null
  }

  type GetInsightGenerationJobGroupByPayload<T extends InsightGenerationJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InsightGenerationJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InsightGenerationJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InsightGenerationJobGroupByOutputType[P]>
            : GetScalarType<T[P], InsightGenerationJobGroupByOutputType[P]>
        }
      >
    >


  export type InsightGenerationJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insightId?: boolean
    requestedById?: boolean
    status?: boolean
    cloudTaskName?: boolean
    queue?: boolean
    payload?: boolean
    scheduledAt?: boolean
    dispatchedAt?: boolean
    completedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    insight?: boolean | InsightGenerationJob$insightArgs<ExtArgs>
    requestedBy?: boolean | InsightGenerationJob$requestedByArgs<ExtArgs>
    cloudTask?: boolean | InsightGenerationJob$cloudTaskArgs<ExtArgs>
  }, ExtArgs["result"]["insightGenerationJob"]>

  export type InsightGenerationJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    insightId?: boolean
    requestedById?: boolean
    status?: boolean
    cloudTaskName?: boolean
    queue?: boolean
    payload?: boolean
    scheduledAt?: boolean
    dispatchedAt?: boolean
    completedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    insight?: boolean | InsightGenerationJob$insightArgs<ExtArgs>
    requestedBy?: boolean | InsightGenerationJob$requestedByArgs<ExtArgs>
  }, ExtArgs["result"]["insightGenerationJob"]>

  export type InsightGenerationJobSelectScalar = {
    id?: boolean
    insightId?: boolean
    requestedById?: boolean
    status?: boolean
    cloudTaskName?: boolean
    queue?: boolean
    payload?: boolean
    scheduledAt?: boolean
    dispatchedAt?: boolean
    completedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InsightGenerationJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insight?: boolean | InsightGenerationJob$insightArgs<ExtArgs>
    requestedBy?: boolean | InsightGenerationJob$requestedByArgs<ExtArgs>
    cloudTask?: boolean | InsightGenerationJob$cloudTaskArgs<ExtArgs>
  }
  export type InsightGenerationJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    insight?: boolean | InsightGenerationJob$insightArgs<ExtArgs>
    requestedBy?: boolean | InsightGenerationJob$requestedByArgs<ExtArgs>
  }

  export type $InsightGenerationJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InsightGenerationJob"
    objects: {
      insight: Prisma.$InsightPayload<ExtArgs> | null
      requestedBy: Prisma.$UserPayload<ExtArgs> | null
      cloudTask: Prisma.$CloudTaskMetadataPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      insightId: string | null
      requestedById: string | null
      status: $Enums.InsightGenerationStatus
      cloudTaskName: string | null
      queue: string | null
      payload: Prisma.JsonValue | null
      scheduledAt: Date | null
      dispatchedAt: Date | null
      completedAt: Date | null
      errorCode: string | null
      errorMessage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["insightGenerationJob"]>
    composites: {}
  }

  type InsightGenerationJobGetPayload<S extends boolean | null | undefined | InsightGenerationJobDefaultArgs> = $Result.GetResult<Prisma.$InsightGenerationJobPayload, S>

  type InsightGenerationJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InsightGenerationJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InsightGenerationJobCountAggregateInputType | true
    }

  export interface InsightGenerationJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InsightGenerationJob'], meta: { name: 'InsightGenerationJob' } }
    /**
     * Find zero or one InsightGenerationJob that matches the filter.
     * @param {InsightGenerationJobFindUniqueArgs} args - Arguments to find a InsightGenerationJob
     * @example
     * // Get one InsightGenerationJob
     * const insightGenerationJob = await prisma.insightGenerationJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InsightGenerationJobFindUniqueArgs>(args: SelectSubset<T, InsightGenerationJobFindUniqueArgs<ExtArgs>>): Prisma__InsightGenerationJobClient<$Result.GetResult<Prisma.$InsightGenerationJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InsightGenerationJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InsightGenerationJobFindUniqueOrThrowArgs} args - Arguments to find a InsightGenerationJob
     * @example
     * // Get one InsightGenerationJob
     * const insightGenerationJob = await prisma.insightGenerationJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InsightGenerationJobFindUniqueOrThrowArgs>(args: SelectSubset<T, InsightGenerationJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InsightGenerationJobClient<$Result.GetResult<Prisma.$InsightGenerationJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InsightGenerationJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightGenerationJobFindFirstArgs} args - Arguments to find a InsightGenerationJob
     * @example
     * // Get one InsightGenerationJob
     * const insightGenerationJob = await prisma.insightGenerationJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InsightGenerationJobFindFirstArgs>(args?: SelectSubset<T, InsightGenerationJobFindFirstArgs<ExtArgs>>): Prisma__InsightGenerationJobClient<$Result.GetResult<Prisma.$InsightGenerationJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InsightGenerationJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightGenerationJobFindFirstOrThrowArgs} args - Arguments to find a InsightGenerationJob
     * @example
     * // Get one InsightGenerationJob
     * const insightGenerationJob = await prisma.insightGenerationJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InsightGenerationJobFindFirstOrThrowArgs>(args?: SelectSubset<T, InsightGenerationJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__InsightGenerationJobClient<$Result.GetResult<Prisma.$InsightGenerationJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InsightGenerationJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightGenerationJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InsightGenerationJobs
     * const insightGenerationJobs = await prisma.insightGenerationJob.findMany()
     * 
     * // Get first 10 InsightGenerationJobs
     * const insightGenerationJobs = await prisma.insightGenerationJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const insightGenerationJobWithIdOnly = await prisma.insightGenerationJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InsightGenerationJobFindManyArgs>(args?: SelectSubset<T, InsightGenerationJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightGenerationJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InsightGenerationJob.
     * @param {InsightGenerationJobCreateArgs} args - Arguments to create a InsightGenerationJob.
     * @example
     * // Create one InsightGenerationJob
     * const InsightGenerationJob = await prisma.insightGenerationJob.create({
     *   data: {
     *     // ... data to create a InsightGenerationJob
     *   }
     * })
     * 
     */
    create<T extends InsightGenerationJobCreateArgs>(args: SelectSubset<T, InsightGenerationJobCreateArgs<ExtArgs>>): Prisma__InsightGenerationJobClient<$Result.GetResult<Prisma.$InsightGenerationJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InsightGenerationJobs.
     * @param {InsightGenerationJobCreateManyArgs} args - Arguments to create many InsightGenerationJobs.
     * @example
     * // Create many InsightGenerationJobs
     * const insightGenerationJob = await prisma.insightGenerationJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InsightGenerationJobCreateManyArgs>(args?: SelectSubset<T, InsightGenerationJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InsightGenerationJobs and returns the data saved in the database.
     * @param {InsightGenerationJobCreateManyAndReturnArgs} args - Arguments to create many InsightGenerationJobs.
     * @example
     * // Create many InsightGenerationJobs
     * const insightGenerationJob = await prisma.insightGenerationJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InsightGenerationJobs and only return the `id`
     * const insightGenerationJobWithIdOnly = await prisma.insightGenerationJob.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InsightGenerationJobCreateManyAndReturnArgs>(args?: SelectSubset<T, InsightGenerationJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InsightGenerationJobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InsightGenerationJob.
     * @param {InsightGenerationJobDeleteArgs} args - Arguments to delete one InsightGenerationJob.
     * @example
     * // Delete one InsightGenerationJob
     * const InsightGenerationJob = await prisma.insightGenerationJob.delete({
     *   where: {
     *     // ... filter to delete one InsightGenerationJob
     *   }
     * })
     * 
     */
    delete<T extends InsightGenerationJobDeleteArgs>(args: SelectSubset<T, InsightGenerationJobDeleteArgs<ExtArgs>>): Prisma__InsightGenerationJobClient<$Result.GetResult<Prisma.$InsightGenerationJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InsightGenerationJob.
     * @param {InsightGenerationJobUpdateArgs} args - Arguments to update one InsightGenerationJob.
     * @example
     * // Update one InsightGenerationJob
     * const insightGenerationJob = await prisma.insightGenerationJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InsightGenerationJobUpdateArgs>(args: SelectSubset<T, InsightGenerationJobUpdateArgs<ExtArgs>>): Prisma__InsightGenerationJobClient<$Result.GetResult<Prisma.$InsightGenerationJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InsightGenerationJobs.
     * @param {InsightGenerationJobDeleteManyArgs} args - Arguments to filter InsightGenerationJobs to delete.
     * @example
     * // Delete a few InsightGenerationJobs
     * const { count } = await prisma.insightGenerationJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InsightGenerationJobDeleteManyArgs>(args?: SelectSubset<T, InsightGenerationJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InsightGenerationJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightGenerationJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InsightGenerationJobs
     * const insightGenerationJob = await prisma.insightGenerationJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InsightGenerationJobUpdateManyArgs>(args: SelectSubset<T, InsightGenerationJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InsightGenerationJob.
     * @param {InsightGenerationJobUpsertArgs} args - Arguments to update or create a InsightGenerationJob.
     * @example
     * // Update or create a InsightGenerationJob
     * const insightGenerationJob = await prisma.insightGenerationJob.upsert({
     *   create: {
     *     // ... data to create a InsightGenerationJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InsightGenerationJob we want to update
     *   }
     * })
     */
    upsert<T extends InsightGenerationJobUpsertArgs>(args: SelectSubset<T, InsightGenerationJobUpsertArgs<ExtArgs>>): Prisma__InsightGenerationJobClient<$Result.GetResult<Prisma.$InsightGenerationJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InsightGenerationJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightGenerationJobCountArgs} args - Arguments to filter InsightGenerationJobs to count.
     * @example
     * // Count the number of InsightGenerationJobs
     * const count = await prisma.insightGenerationJob.count({
     *   where: {
     *     // ... the filter for the InsightGenerationJobs we want to count
     *   }
     * })
    **/
    count<T extends InsightGenerationJobCountArgs>(
      args?: Subset<T, InsightGenerationJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InsightGenerationJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InsightGenerationJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightGenerationJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InsightGenerationJobAggregateArgs>(args: Subset<T, InsightGenerationJobAggregateArgs>): Prisma.PrismaPromise<GetInsightGenerationJobAggregateType<T>>

    /**
     * Group by InsightGenerationJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InsightGenerationJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InsightGenerationJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InsightGenerationJobGroupByArgs['orderBy'] }
        : { orderBy?: InsightGenerationJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InsightGenerationJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInsightGenerationJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InsightGenerationJob model
   */
  readonly fields: InsightGenerationJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InsightGenerationJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InsightGenerationJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    insight<T extends InsightGenerationJob$insightArgs<ExtArgs> = {}>(args?: Subset<T, InsightGenerationJob$insightArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    requestedBy<T extends InsightGenerationJob$requestedByArgs<ExtArgs> = {}>(args?: Subset<T, InsightGenerationJob$requestedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    cloudTask<T extends InsightGenerationJob$cloudTaskArgs<ExtArgs> = {}>(args?: Subset<T, InsightGenerationJob$cloudTaskArgs<ExtArgs>>): Prisma__CloudTaskMetadataClient<$Result.GetResult<Prisma.$CloudTaskMetadataPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InsightGenerationJob model
   */ 
  interface InsightGenerationJobFieldRefs {
    readonly id: FieldRef<"InsightGenerationJob", 'String'>
    readonly insightId: FieldRef<"InsightGenerationJob", 'String'>
    readonly requestedById: FieldRef<"InsightGenerationJob", 'String'>
    readonly status: FieldRef<"InsightGenerationJob", 'InsightGenerationStatus'>
    readonly cloudTaskName: FieldRef<"InsightGenerationJob", 'String'>
    readonly queue: FieldRef<"InsightGenerationJob", 'String'>
    readonly payload: FieldRef<"InsightGenerationJob", 'Json'>
    readonly scheduledAt: FieldRef<"InsightGenerationJob", 'DateTime'>
    readonly dispatchedAt: FieldRef<"InsightGenerationJob", 'DateTime'>
    readonly completedAt: FieldRef<"InsightGenerationJob", 'DateTime'>
    readonly errorCode: FieldRef<"InsightGenerationJob", 'String'>
    readonly errorMessage: FieldRef<"InsightGenerationJob", 'String'>
    readonly createdAt: FieldRef<"InsightGenerationJob", 'DateTime'>
    readonly updatedAt: FieldRef<"InsightGenerationJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InsightGenerationJob findUnique
   */
  export type InsightGenerationJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightGenerationJob
     */
    select?: InsightGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightGenerationJobInclude<ExtArgs> | null
    /**
     * Filter, which InsightGenerationJob to fetch.
     */
    where: InsightGenerationJobWhereUniqueInput
  }

  /**
   * InsightGenerationJob findUniqueOrThrow
   */
  export type InsightGenerationJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightGenerationJob
     */
    select?: InsightGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightGenerationJobInclude<ExtArgs> | null
    /**
     * Filter, which InsightGenerationJob to fetch.
     */
    where: InsightGenerationJobWhereUniqueInput
  }

  /**
   * InsightGenerationJob findFirst
   */
  export type InsightGenerationJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightGenerationJob
     */
    select?: InsightGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightGenerationJobInclude<ExtArgs> | null
    /**
     * Filter, which InsightGenerationJob to fetch.
     */
    where?: InsightGenerationJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightGenerationJobs to fetch.
     */
    orderBy?: InsightGenerationJobOrderByWithRelationInput | InsightGenerationJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsightGenerationJobs.
     */
    cursor?: InsightGenerationJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightGenerationJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightGenerationJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsightGenerationJobs.
     */
    distinct?: InsightGenerationJobScalarFieldEnum | InsightGenerationJobScalarFieldEnum[]
  }

  /**
   * InsightGenerationJob findFirstOrThrow
   */
  export type InsightGenerationJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightGenerationJob
     */
    select?: InsightGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightGenerationJobInclude<ExtArgs> | null
    /**
     * Filter, which InsightGenerationJob to fetch.
     */
    where?: InsightGenerationJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightGenerationJobs to fetch.
     */
    orderBy?: InsightGenerationJobOrderByWithRelationInput | InsightGenerationJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InsightGenerationJobs.
     */
    cursor?: InsightGenerationJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightGenerationJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightGenerationJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InsightGenerationJobs.
     */
    distinct?: InsightGenerationJobScalarFieldEnum | InsightGenerationJobScalarFieldEnum[]
  }

  /**
   * InsightGenerationJob findMany
   */
  export type InsightGenerationJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightGenerationJob
     */
    select?: InsightGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightGenerationJobInclude<ExtArgs> | null
    /**
     * Filter, which InsightGenerationJobs to fetch.
     */
    where?: InsightGenerationJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InsightGenerationJobs to fetch.
     */
    orderBy?: InsightGenerationJobOrderByWithRelationInput | InsightGenerationJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InsightGenerationJobs.
     */
    cursor?: InsightGenerationJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InsightGenerationJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InsightGenerationJobs.
     */
    skip?: number
    distinct?: InsightGenerationJobScalarFieldEnum | InsightGenerationJobScalarFieldEnum[]
  }

  /**
   * InsightGenerationJob create
   */
  export type InsightGenerationJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightGenerationJob
     */
    select?: InsightGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightGenerationJobInclude<ExtArgs> | null
    /**
     * The data needed to create a InsightGenerationJob.
     */
    data: XOR<InsightGenerationJobCreateInput, InsightGenerationJobUncheckedCreateInput>
  }

  /**
   * InsightGenerationJob createMany
   */
  export type InsightGenerationJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InsightGenerationJobs.
     */
    data: InsightGenerationJobCreateManyInput | InsightGenerationJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InsightGenerationJob createManyAndReturn
   */
  export type InsightGenerationJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightGenerationJob
     */
    select?: InsightGenerationJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InsightGenerationJobs.
     */
    data: InsightGenerationJobCreateManyInput | InsightGenerationJobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightGenerationJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InsightGenerationJob update
   */
  export type InsightGenerationJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightGenerationJob
     */
    select?: InsightGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightGenerationJobInclude<ExtArgs> | null
    /**
     * The data needed to update a InsightGenerationJob.
     */
    data: XOR<InsightGenerationJobUpdateInput, InsightGenerationJobUncheckedUpdateInput>
    /**
     * Choose, which InsightGenerationJob to update.
     */
    where: InsightGenerationJobWhereUniqueInput
  }

  /**
   * InsightGenerationJob updateMany
   */
  export type InsightGenerationJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InsightGenerationJobs.
     */
    data: XOR<InsightGenerationJobUpdateManyMutationInput, InsightGenerationJobUncheckedUpdateManyInput>
    /**
     * Filter which InsightGenerationJobs to update
     */
    where?: InsightGenerationJobWhereInput
  }

  /**
   * InsightGenerationJob upsert
   */
  export type InsightGenerationJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightGenerationJob
     */
    select?: InsightGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightGenerationJobInclude<ExtArgs> | null
    /**
     * The filter to search for the InsightGenerationJob to update in case it exists.
     */
    where: InsightGenerationJobWhereUniqueInput
    /**
     * In case the InsightGenerationJob found by the `where` argument doesn't exist, create a new InsightGenerationJob with this data.
     */
    create: XOR<InsightGenerationJobCreateInput, InsightGenerationJobUncheckedCreateInput>
    /**
     * In case the InsightGenerationJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InsightGenerationJobUpdateInput, InsightGenerationJobUncheckedUpdateInput>
  }

  /**
   * InsightGenerationJob delete
   */
  export type InsightGenerationJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightGenerationJob
     */
    select?: InsightGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightGenerationJobInclude<ExtArgs> | null
    /**
     * Filter which InsightGenerationJob to delete.
     */
    where: InsightGenerationJobWhereUniqueInput
  }

  /**
   * InsightGenerationJob deleteMany
   */
  export type InsightGenerationJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InsightGenerationJobs to delete
     */
    where?: InsightGenerationJobWhereInput
  }

  /**
   * InsightGenerationJob.insight
   */
  export type InsightGenerationJob$insightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    where?: InsightWhereInput
  }

  /**
   * InsightGenerationJob.requestedBy
   */
  export type InsightGenerationJob$requestedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * InsightGenerationJob.cloudTask
   */
  export type InsightGenerationJob$cloudTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudTaskMetadata
     */
    select?: CloudTaskMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudTaskMetadataInclude<ExtArgs> | null
    where?: CloudTaskMetadataWhereInput
  }

  /**
   * InsightGenerationJob without action
   */
  export type InsightGenerationJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightGenerationJob
     */
    select?: InsightGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightGenerationJobInclude<ExtArgs> | null
  }


  /**
   * Model LongevityPlanJob
   */

  export type AggregateLongevityPlanJob = {
    _count: LongevityPlanJobCountAggregateOutputType | null
    _min: LongevityPlanJobMinAggregateOutputType | null
    _max: LongevityPlanJobMaxAggregateOutputType | null
  }

  export type LongevityPlanJobMinAggregateOutputType = {
    id: string | null
    planId: string | null
    requestedById: string | null
    status: $Enums.LongevityPlanJobStatus | null
    cloudTaskName: string | null
    queue: string | null
    scheduledAt: Date | null
    dispatchedAt: Date | null
    completedAt: Date | null
    errorCode: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LongevityPlanJobMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    requestedById: string | null
    status: $Enums.LongevityPlanJobStatus | null
    cloudTaskName: string | null
    queue: string | null
    scheduledAt: Date | null
    dispatchedAt: Date | null
    completedAt: Date | null
    errorCode: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LongevityPlanJobCountAggregateOutputType = {
    id: number
    planId: number
    requestedById: number
    status: number
    cloudTaskName: number
    queue: number
    payload: number
    scheduledAt: number
    dispatchedAt: number
    completedAt: number
    errorCode: number
    errorMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LongevityPlanJobMinAggregateInputType = {
    id?: true
    planId?: true
    requestedById?: true
    status?: true
    cloudTaskName?: true
    queue?: true
    scheduledAt?: true
    dispatchedAt?: true
    completedAt?: true
    errorCode?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LongevityPlanJobMaxAggregateInputType = {
    id?: true
    planId?: true
    requestedById?: true
    status?: true
    cloudTaskName?: true
    queue?: true
    scheduledAt?: true
    dispatchedAt?: true
    completedAt?: true
    errorCode?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LongevityPlanJobCountAggregateInputType = {
    id?: true
    planId?: true
    requestedById?: true
    status?: true
    cloudTaskName?: true
    queue?: true
    payload?: true
    scheduledAt?: true
    dispatchedAt?: true
    completedAt?: true
    errorCode?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LongevityPlanJobAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LongevityPlanJob to aggregate.
     */
    where?: LongevityPlanJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LongevityPlanJobs to fetch.
     */
    orderBy?: LongevityPlanJobOrderByWithRelationInput | LongevityPlanJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LongevityPlanJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LongevityPlanJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LongevityPlanJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LongevityPlanJobs
    **/
    _count?: true | LongevityPlanJobCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LongevityPlanJobMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LongevityPlanJobMaxAggregateInputType
  }

  export type GetLongevityPlanJobAggregateType<T extends LongevityPlanJobAggregateArgs> = {
        [P in keyof T & keyof AggregateLongevityPlanJob]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLongevityPlanJob[P]>
      : GetScalarType<T[P], AggregateLongevityPlanJob[P]>
  }




  export type LongevityPlanJobGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LongevityPlanJobWhereInput
    orderBy?: LongevityPlanJobOrderByWithAggregationInput | LongevityPlanJobOrderByWithAggregationInput[]
    by: LongevityPlanJobScalarFieldEnum[] | LongevityPlanJobScalarFieldEnum
    having?: LongevityPlanJobScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LongevityPlanJobCountAggregateInputType | true
    _min?: LongevityPlanJobMinAggregateInputType
    _max?: LongevityPlanJobMaxAggregateInputType
  }

  export type LongevityPlanJobGroupByOutputType = {
    id: string
    planId: string | null
    requestedById: string | null
    status: $Enums.LongevityPlanJobStatus
    cloudTaskName: string | null
    queue: string | null
    payload: JsonValue | null
    scheduledAt: Date | null
    dispatchedAt: Date | null
    completedAt: Date | null
    errorCode: string | null
    errorMessage: string | null
    createdAt: Date
    updatedAt: Date
    _count: LongevityPlanJobCountAggregateOutputType | null
    _min: LongevityPlanJobMinAggregateOutputType | null
    _max: LongevityPlanJobMaxAggregateOutputType | null
  }

  type GetLongevityPlanJobGroupByPayload<T extends LongevityPlanJobGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LongevityPlanJobGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LongevityPlanJobGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LongevityPlanJobGroupByOutputType[P]>
            : GetScalarType<T[P], LongevityPlanJobGroupByOutputType[P]>
        }
      >
    >


  export type LongevityPlanJobSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    requestedById?: boolean
    status?: boolean
    cloudTaskName?: boolean
    queue?: boolean
    payload?: boolean
    scheduledAt?: boolean
    dispatchedAt?: boolean
    completedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | LongevityPlanJob$planArgs<ExtArgs>
    requestedBy?: boolean | LongevityPlanJob$requestedByArgs<ExtArgs>
    cloudTask?: boolean | LongevityPlanJob$cloudTaskArgs<ExtArgs>
  }, ExtArgs["result"]["longevityPlanJob"]>

  export type LongevityPlanJobSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    requestedById?: boolean
    status?: boolean
    cloudTaskName?: boolean
    queue?: boolean
    payload?: boolean
    scheduledAt?: boolean
    dispatchedAt?: boolean
    completedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    plan?: boolean | LongevityPlanJob$planArgs<ExtArgs>
    requestedBy?: boolean | LongevityPlanJob$requestedByArgs<ExtArgs>
  }, ExtArgs["result"]["longevityPlanJob"]>

  export type LongevityPlanJobSelectScalar = {
    id?: boolean
    planId?: boolean
    requestedById?: boolean
    status?: boolean
    cloudTaskName?: boolean
    queue?: boolean
    payload?: boolean
    scheduledAt?: boolean
    dispatchedAt?: boolean
    completedAt?: boolean
    errorCode?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LongevityPlanJobInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | LongevityPlanJob$planArgs<ExtArgs>
    requestedBy?: boolean | LongevityPlanJob$requestedByArgs<ExtArgs>
    cloudTask?: boolean | LongevityPlanJob$cloudTaskArgs<ExtArgs>
  }
  export type LongevityPlanJobIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | LongevityPlanJob$planArgs<ExtArgs>
    requestedBy?: boolean | LongevityPlanJob$requestedByArgs<ExtArgs>
  }

  export type $LongevityPlanJobPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LongevityPlanJob"
    objects: {
      plan: Prisma.$LongevityPlanPayload<ExtArgs> | null
      requestedBy: Prisma.$UserPayload<ExtArgs> | null
      cloudTask: Prisma.$CloudTaskMetadataPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string | null
      requestedById: string | null
      status: $Enums.LongevityPlanJobStatus
      cloudTaskName: string | null
      queue: string | null
      payload: Prisma.JsonValue | null
      scheduledAt: Date | null
      dispatchedAt: Date | null
      completedAt: Date | null
      errorCode: string | null
      errorMessage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["longevityPlanJob"]>
    composites: {}
  }

  type LongevityPlanJobGetPayload<S extends boolean | null | undefined | LongevityPlanJobDefaultArgs> = $Result.GetResult<Prisma.$LongevityPlanJobPayload, S>

  type LongevityPlanJobCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LongevityPlanJobFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LongevityPlanJobCountAggregateInputType | true
    }

  export interface LongevityPlanJobDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LongevityPlanJob'], meta: { name: 'LongevityPlanJob' } }
    /**
     * Find zero or one LongevityPlanJob that matches the filter.
     * @param {LongevityPlanJobFindUniqueArgs} args - Arguments to find a LongevityPlanJob
     * @example
     * // Get one LongevityPlanJob
     * const longevityPlanJob = await prisma.longevityPlanJob.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LongevityPlanJobFindUniqueArgs>(args: SelectSubset<T, LongevityPlanJobFindUniqueArgs<ExtArgs>>): Prisma__LongevityPlanJobClient<$Result.GetResult<Prisma.$LongevityPlanJobPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LongevityPlanJob that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LongevityPlanJobFindUniqueOrThrowArgs} args - Arguments to find a LongevityPlanJob
     * @example
     * // Get one LongevityPlanJob
     * const longevityPlanJob = await prisma.longevityPlanJob.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LongevityPlanJobFindUniqueOrThrowArgs>(args: SelectSubset<T, LongevityPlanJobFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LongevityPlanJobClient<$Result.GetResult<Prisma.$LongevityPlanJobPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LongevityPlanJob that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LongevityPlanJobFindFirstArgs} args - Arguments to find a LongevityPlanJob
     * @example
     * // Get one LongevityPlanJob
     * const longevityPlanJob = await prisma.longevityPlanJob.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LongevityPlanJobFindFirstArgs>(args?: SelectSubset<T, LongevityPlanJobFindFirstArgs<ExtArgs>>): Prisma__LongevityPlanJobClient<$Result.GetResult<Prisma.$LongevityPlanJobPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LongevityPlanJob that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LongevityPlanJobFindFirstOrThrowArgs} args - Arguments to find a LongevityPlanJob
     * @example
     * // Get one LongevityPlanJob
     * const longevityPlanJob = await prisma.longevityPlanJob.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LongevityPlanJobFindFirstOrThrowArgs>(args?: SelectSubset<T, LongevityPlanJobFindFirstOrThrowArgs<ExtArgs>>): Prisma__LongevityPlanJobClient<$Result.GetResult<Prisma.$LongevityPlanJobPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LongevityPlanJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LongevityPlanJobFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LongevityPlanJobs
     * const longevityPlanJobs = await prisma.longevityPlanJob.findMany()
     * 
     * // Get first 10 LongevityPlanJobs
     * const longevityPlanJobs = await prisma.longevityPlanJob.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const longevityPlanJobWithIdOnly = await prisma.longevityPlanJob.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LongevityPlanJobFindManyArgs>(args?: SelectSubset<T, LongevityPlanJobFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LongevityPlanJobPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LongevityPlanJob.
     * @param {LongevityPlanJobCreateArgs} args - Arguments to create a LongevityPlanJob.
     * @example
     * // Create one LongevityPlanJob
     * const LongevityPlanJob = await prisma.longevityPlanJob.create({
     *   data: {
     *     // ... data to create a LongevityPlanJob
     *   }
     * })
     * 
     */
    create<T extends LongevityPlanJobCreateArgs>(args: SelectSubset<T, LongevityPlanJobCreateArgs<ExtArgs>>): Prisma__LongevityPlanJobClient<$Result.GetResult<Prisma.$LongevityPlanJobPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LongevityPlanJobs.
     * @param {LongevityPlanJobCreateManyArgs} args - Arguments to create many LongevityPlanJobs.
     * @example
     * // Create many LongevityPlanJobs
     * const longevityPlanJob = await prisma.longevityPlanJob.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LongevityPlanJobCreateManyArgs>(args?: SelectSubset<T, LongevityPlanJobCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LongevityPlanJobs and returns the data saved in the database.
     * @param {LongevityPlanJobCreateManyAndReturnArgs} args - Arguments to create many LongevityPlanJobs.
     * @example
     * // Create many LongevityPlanJobs
     * const longevityPlanJob = await prisma.longevityPlanJob.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LongevityPlanJobs and only return the `id`
     * const longevityPlanJobWithIdOnly = await prisma.longevityPlanJob.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LongevityPlanJobCreateManyAndReturnArgs>(args?: SelectSubset<T, LongevityPlanJobCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LongevityPlanJobPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LongevityPlanJob.
     * @param {LongevityPlanJobDeleteArgs} args - Arguments to delete one LongevityPlanJob.
     * @example
     * // Delete one LongevityPlanJob
     * const LongevityPlanJob = await prisma.longevityPlanJob.delete({
     *   where: {
     *     // ... filter to delete one LongevityPlanJob
     *   }
     * })
     * 
     */
    delete<T extends LongevityPlanJobDeleteArgs>(args: SelectSubset<T, LongevityPlanJobDeleteArgs<ExtArgs>>): Prisma__LongevityPlanJobClient<$Result.GetResult<Prisma.$LongevityPlanJobPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LongevityPlanJob.
     * @param {LongevityPlanJobUpdateArgs} args - Arguments to update one LongevityPlanJob.
     * @example
     * // Update one LongevityPlanJob
     * const longevityPlanJob = await prisma.longevityPlanJob.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LongevityPlanJobUpdateArgs>(args: SelectSubset<T, LongevityPlanJobUpdateArgs<ExtArgs>>): Prisma__LongevityPlanJobClient<$Result.GetResult<Prisma.$LongevityPlanJobPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LongevityPlanJobs.
     * @param {LongevityPlanJobDeleteManyArgs} args - Arguments to filter LongevityPlanJobs to delete.
     * @example
     * // Delete a few LongevityPlanJobs
     * const { count } = await prisma.longevityPlanJob.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LongevityPlanJobDeleteManyArgs>(args?: SelectSubset<T, LongevityPlanJobDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LongevityPlanJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LongevityPlanJobUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LongevityPlanJobs
     * const longevityPlanJob = await prisma.longevityPlanJob.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LongevityPlanJobUpdateManyArgs>(args: SelectSubset<T, LongevityPlanJobUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LongevityPlanJob.
     * @param {LongevityPlanJobUpsertArgs} args - Arguments to update or create a LongevityPlanJob.
     * @example
     * // Update or create a LongevityPlanJob
     * const longevityPlanJob = await prisma.longevityPlanJob.upsert({
     *   create: {
     *     // ... data to create a LongevityPlanJob
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LongevityPlanJob we want to update
     *   }
     * })
     */
    upsert<T extends LongevityPlanJobUpsertArgs>(args: SelectSubset<T, LongevityPlanJobUpsertArgs<ExtArgs>>): Prisma__LongevityPlanJobClient<$Result.GetResult<Prisma.$LongevityPlanJobPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LongevityPlanJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LongevityPlanJobCountArgs} args - Arguments to filter LongevityPlanJobs to count.
     * @example
     * // Count the number of LongevityPlanJobs
     * const count = await prisma.longevityPlanJob.count({
     *   where: {
     *     // ... the filter for the LongevityPlanJobs we want to count
     *   }
     * })
    **/
    count<T extends LongevityPlanJobCountArgs>(
      args?: Subset<T, LongevityPlanJobCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LongevityPlanJobCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LongevityPlanJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LongevityPlanJobAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LongevityPlanJobAggregateArgs>(args: Subset<T, LongevityPlanJobAggregateArgs>): Prisma.PrismaPromise<GetLongevityPlanJobAggregateType<T>>

    /**
     * Group by LongevityPlanJob.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LongevityPlanJobGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LongevityPlanJobGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LongevityPlanJobGroupByArgs['orderBy'] }
        : { orderBy?: LongevityPlanJobGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LongevityPlanJobGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLongevityPlanJobGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LongevityPlanJob model
   */
  readonly fields: LongevityPlanJobFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LongevityPlanJob.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LongevityPlanJobClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends LongevityPlanJob$planArgs<ExtArgs> = {}>(args?: Subset<T, LongevityPlanJob$planArgs<ExtArgs>>): Prisma__LongevityPlanClient<$Result.GetResult<Prisma.$LongevityPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    requestedBy<T extends LongevityPlanJob$requestedByArgs<ExtArgs> = {}>(args?: Subset<T, LongevityPlanJob$requestedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    cloudTask<T extends LongevityPlanJob$cloudTaskArgs<ExtArgs> = {}>(args?: Subset<T, LongevityPlanJob$cloudTaskArgs<ExtArgs>>): Prisma__CloudTaskMetadataClient<$Result.GetResult<Prisma.$CloudTaskMetadataPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LongevityPlanJob model
   */ 
  interface LongevityPlanJobFieldRefs {
    readonly id: FieldRef<"LongevityPlanJob", 'String'>
    readonly planId: FieldRef<"LongevityPlanJob", 'String'>
    readonly requestedById: FieldRef<"LongevityPlanJob", 'String'>
    readonly status: FieldRef<"LongevityPlanJob", 'LongevityPlanJobStatus'>
    readonly cloudTaskName: FieldRef<"LongevityPlanJob", 'String'>
    readonly queue: FieldRef<"LongevityPlanJob", 'String'>
    readonly payload: FieldRef<"LongevityPlanJob", 'Json'>
    readonly scheduledAt: FieldRef<"LongevityPlanJob", 'DateTime'>
    readonly dispatchedAt: FieldRef<"LongevityPlanJob", 'DateTime'>
    readonly completedAt: FieldRef<"LongevityPlanJob", 'DateTime'>
    readonly errorCode: FieldRef<"LongevityPlanJob", 'String'>
    readonly errorMessage: FieldRef<"LongevityPlanJob", 'String'>
    readonly createdAt: FieldRef<"LongevityPlanJob", 'DateTime'>
    readonly updatedAt: FieldRef<"LongevityPlanJob", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LongevityPlanJob findUnique
   */
  export type LongevityPlanJobFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlanJob
     */
    select?: LongevityPlanJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanJobInclude<ExtArgs> | null
    /**
     * Filter, which LongevityPlanJob to fetch.
     */
    where: LongevityPlanJobWhereUniqueInput
  }

  /**
   * LongevityPlanJob findUniqueOrThrow
   */
  export type LongevityPlanJobFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlanJob
     */
    select?: LongevityPlanJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanJobInclude<ExtArgs> | null
    /**
     * Filter, which LongevityPlanJob to fetch.
     */
    where: LongevityPlanJobWhereUniqueInput
  }

  /**
   * LongevityPlanJob findFirst
   */
  export type LongevityPlanJobFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlanJob
     */
    select?: LongevityPlanJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanJobInclude<ExtArgs> | null
    /**
     * Filter, which LongevityPlanJob to fetch.
     */
    where?: LongevityPlanJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LongevityPlanJobs to fetch.
     */
    orderBy?: LongevityPlanJobOrderByWithRelationInput | LongevityPlanJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LongevityPlanJobs.
     */
    cursor?: LongevityPlanJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LongevityPlanJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LongevityPlanJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LongevityPlanJobs.
     */
    distinct?: LongevityPlanJobScalarFieldEnum | LongevityPlanJobScalarFieldEnum[]
  }

  /**
   * LongevityPlanJob findFirstOrThrow
   */
  export type LongevityPlanJobFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlanJob
     */
    select?: LongevityPlanJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanJobInclude<ExtArgs> | null
    /**
     * Filter, which LongevityPlanJob to fetch.
     */
    where?: LongevityPlanJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LongevityPlanJobs to fetch.
     */
    orderBy?: LongevityPlanJobOrderByWithRelationInput | LongevityPlanJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LongevityPlanJobs.
     */
    cursor?: LongevityPlanJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LongevityPlanJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LongevityPlanJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LongevityPlanJobs.
     */
    distinct?: LongevityPlanJobScalarFieldEnum | LongevityPlanJobScalarFieldEnum[]
  }

  /**
   * LongevityPlanJob findMany
   */
  export type LongevityPlanJobFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlanJob
     */
    select?: LongevityPlanJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanJobInclude<ExtArgs> | null
    /**
     * Filter, which LongevityPlanJobs to fetch.
     */
    where?: LongevityPlanJobWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LongevityPlanJobs to fetch.
     */
    orderBy?: LongevityPlanJobOrderByWithRelationInput | LongevityPlanJobOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LongevityPlanJobs.
     */
    cursor?: LongevityPlanJobWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LongevityPlanJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LongevityPlanJobs.
     */
    skip?: number
    distinct?: LongevityPlanJobScalarFieldEnum | LongevityPlanJobScalarFieldEnum[]
  }

  /**
   * LongevityPlanJob create
   */
  export type LongevityPlanJobCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlanJob
     */
    select?: LongevityPlanJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanJobInclude<ExtArgs> | null
    /**
     * The data needed to create a LongevityPlanJob.
     */
    data: XOR<LongevityPlanJobCreateInput, LongevityPlanJobUncheckedCreateInput>
  }

  /**
   * LongevityPlanJob createMany
   */
  export type LongevityPlanJobCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LongevityPlanJobs.
     */
    data: LongevityPlanJobCreateManyInput | LongevityPlanJobCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LongevityPlanJob createManyAndReturn
   */
  export type LongevityPlanJobCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlanJob
     */
    select?: LongevityPlanJobSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LongevityPlanJobs.
     */
    data: LongevityPlanJobCreateManyInput | LongevityPlanJobCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanJobIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LongevityPlanJob update
   */
  export type LongevityPlanJobUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlanJob
     */
    select?: LongevityPlanJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanJobInclude<ExtArgs> | null
    /**
     * The data needed to update a LongevityPlanJob.
     */
    data: XOR<LongevityPlanJobUpdateInput, LongevityPlanJobUncheckedUpdateInput>
    /**
     * Choose, which LongevityPlanJob to update.
     */
    where: LongevityPlanJobWhereUniqueInput
  }

  /**
   * LongevityPlanJob updateMany
   */
  export type LongevityPlanJobUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LongevityPlanJobs.
     */
    data: XOR<LongevityPlanJobUpdateManyMutationInput, LongevityPlanJobUncheckedUpdateManyInput>
    /**
     * Filter which LongevityPlanJobs to update
     */
    where?: LongevityPlanJobWhereInput
  }

  /**
   * LongevityPlanJob upsert
   */
  export type LongevityPlanJobUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlanJob
     */
    select?: LongevityPlanJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanJobInclude<ExtArgs> | null
    /**
     * The filter to search for the LongevityPlanJob to update in case it exists.
     */
    where: LongevityPlanJobWhereUniqueInput
    /**
     * In case the LongevityPlanJob found by the `where` argument doesn't exist, create a new LongevityPlanJob with this data.
     */
    create: XOR<LongevityPlanJobCreateInput, LongevityPlanJobUncheckedCreateInput>
    /**
     * In case the LongevityPlanJob was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LongevityPlanJobUpdateInput, LongevityPlanJobUncheckedUpdateInput>
  }

  /**
   * LongevityPlanJob delete
   */
  export type LongevityPlanJobDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlanJob
     */
    select?: LongevityPlanJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanJobInclude<ExtArgs> | null
    /**
     * Filter which LongevityPlanJob to delete.
     */
    where: LongevityPlanJobWhereUniqueInput
  }

  /**
   * LongevityPlanJob deleteMany
   */
  export type LongevityPlanJobDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LongevityPlanJobs to delete
     */
    where?: LongevityPlanJobWhereInput
  }

  /**
   * LongevityPlanJob.plan
   */
  export type LongevityPlanJob$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlan
     */
    select?: LongevityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanInclude<ExtArgs> | null
    where?: LongevityPlanWhereInput
  }

  /**
   * LongevityPlanJob.requestedBy
   */
  export type LongevityPlanJob$requestedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LongevityPlanJob.cloudTask
   */
  export type LongevityPlanJob$cloudTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudTaskMetadata
     */
    select?: CloudTaskMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudTaskMetadataInclude<ExtArgs> | null
    where?: CloudTaskMetadataWhereInput
  }

  /**
   * LongevityPlanJob without action
   */
  export type LongevityPlanJobDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlanJob
     */
    select?: LongevityPlanJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanJobInclude<ExtArgs> | null
  }


  /**
   * Model CloudTaskMetadata
   */

  export type AggregateCloudTaskMetadata = {
    _count: CloudTaskMetadataCountAggregateOutputType | null
    _avg: CloudTaskMetadataAvgAggregateOutputType | null
    _sum: CloudTaskMetadataSumAggregateOutputType | null
    _min: CloudTaskMetadataMinAggregateOutputType | null
    _max: CloudTaskMetadataMaxAggregateOutputType | null
  }

  export type CloudTaskMetadataAvgAggregateOutputType = {
    attemptCount: number | null
  }

  export type CloudTaskMetadataSumAggregateOutputType = {
    attemptCount: number | null
  }

  export type CloudTaskMetadataMinAggregateOutputType = {
    id: string | null
    taskName: string | null
    queue: string | null
    status: $Enums.CloudTaskStatus | null
    jobId: string | null
    planJobId: string | null
    scheduleTime: Date | null
    firstAttemptAt: Date | null
    lastAttemptAt: Date | null
    attemptCount: number | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CloudTaskMetadataMaxAggregateOutputType = {
    id: string | null
    taskName: string | null
    queue: string | null
    status: $Enums.CloudTaskStatus | null
    jobId: string | null
    planJobId: string | null
    scheduleTime: Date | null
    firstAttemptAt: Date | null
    lastAttemptAt: Date | null
    attemptCount: number | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CloudTaskMetadataCountAggregateOutputType = {
    id: number
    taskName: number
    queue: number
    status: number
    jobId: number
    planJobId: number
    payload: number
    scheduleTime: number
    firstAttemptAt: number
    lastAttemptAt: number
    attemptCount: number
    errorMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CloudTaskMetadataAvgAggregateInputType = {
    attemptCount?: true
  }

  export type CloudTaskMetadataSumAggregateInputType = {
    attemptCount?: true
  }

  export type CloudTaskMetadataMinAggregateInputType = {
    id?: true
    taskName?: true
    queue?: true
    status?: true
    jobId?: true
    planJobId?: true
    scheduleTime?: true
    firstAttemptAt?: true
    lastAttemptAt?: true
    attemptCount?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CloudTaskMetadataMaxAggregateInputType = {
    id?: true
    taskName?: true
    queue?: true
    status?: true
    jobId?: true
    planJobId?: true
    scheduleTime?: true
    firstAttemptAt?: true
    lastAttemptAt?: true
    attemptCount?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CloudTaskMetadataCountAggregateInputType = {
    id?: true
    taskName?: true
    queue?: true
    status?: true
    jobId?: true
    planJobId?: true
    payload?: true
    scheduleTime?: true
    firstAttemptAt?: true
    lastAttemptAt?: true
    attemptCount?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CloudTaskMetadataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CloudTaskMetadata to aggregate.
     */
    where?: CloudTaskMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CloudTaskMetadata to fetch.
     */
    orderBy?: CloudTaskMetadataOrderByWithRelationInput | CloudTaskMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CloudTaskMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CloudTaskMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CloudTaskMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CloudTaskMetadata
    **/
    _count?: true | CloudTaskMetadataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CloudTaskMetadataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CloudTaskMetadataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CloudTaskMetadataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CloudTaskMetadataMaxAggregateInputType
  }

  export type GetCloudTaskMetadataAggregateType<T extends CloudTaskMetadataAggregateArgs> = {
        [P in keyof T & keyof AggregateCloudTaskMetadata]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCloudTaskMetadata[P]>
      : GetScalarType<T[P], AggregateCloudTaskMetadata[P]>
  }




  export type CloudTaskMetadataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CloudTaskMetadataWhereInput
    orderBy?: CloudTaskMetadataOrderByWithAggregationInput | CloudTaskMetadataOrderByWithAggregationInput[]
    by: CloudTaskMetadataScalarFieldEnum[] | CloudTaskMetadataScalarFieldEnum
    having?: CloudTaskMetadataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CloudTaskMetadataCountAggregateInputType | true
    _avg?: CloudTaskMetadataAvgAggregateInputType
    _sum?: CloudTaskMetadataSumAggregateInputType
    _min?: CloudTaskMetadataMinAggregateInputType
    _max?: CloudTaskMetadataMaxAggregateInputType
  }

  export type CloudTaskMetadataGroupByOutputType = {
    id: string
    taskName: string
    queue: string
    status: $Enums.CloudTaskStatus
    jobId: string | null
    planJobId: string | null
    payload: JsonValue | null
    scheduleTime: Date | null
    firstAttemptAt: Date | null
    lastAttemptAt: Date | null
    attemptCount: number
    errorMessage: string | null
    createdAt: Date
    updatedAt: Date
    _count: CloudTaskMetadataCountAggregateOutputType | null
    _avg: CloudTaskMetadataAvgAggregateOutputType | null
    _sum: CloudTaskMetadataSumAggregateOutputType | null
    _min: CloudTaskMetadataMinAggregateOutputType | null
    _max: CloudTaskMetadataMaxAggregateOutputType | null
  }

  type GetCloudTaskMetadataGroupByPayload<T extends CloudTaskMetadataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CloudTaskMetadataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CloudTaskMetadataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CloudTaskMetadataGroupByOutputType[P]>
            : GetScalarType<T[P], CloudTaskMetadataGroupByOutputType[P]>
        }
      >
    >


  export type CloudTaskMetadataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskName?: boolean
    queue?: boolean
    status?: boolean
    jobId?: boolean
    planJobId?: boolean
    payload?: boolean
    scheduleTime?: boolean
    firstAttemptAt?: boolean
    lastAttemptAt?: boolean
    attemptCount?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    job?: boolean | CloudTaskMetadata$jobArgs<ExtArgs>
    planJob?: boolean | CloudTaskMetadata$planJobArgs<ExtArgs>
  }, ExtArgs["result"]["cloudTaskMetadata"]>

  export type CloudTaskMetadataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskName?: boolean
    queue?: boolean
    status?: boolean
    jobId?: boolean
    planJobId?: boolean
    payload?: boolean
    scheduleTime?: boolean
    firstAttemptAt?: boolean
    lastAttemptAt?: boolean
    attemptCount?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    job?: boolean | CloudTaskMetadata$jobArgs<ExtArgs>
    planJob?: boolean | CloudTaskMetadata$planJobArgs<ExtArgs>
  }, ExtArgs["result"]["cloudTaskMetadata"]>

  export type CloudTaskMetadataSelectScalar = {
    id?: boolean
    taskName?: boolean
    queue?: boolean
    status?: boolean
    jobId?: boolean
    planJobId?: boolean
    payload?: boolean
    scheduleTime?: boolean
    firstAttemptAt?: boolean
    lastAttemptAt?: boolean
    attemptCount?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CloudTaskMetadataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | CloudTaskMetadata$jobArgs<ExtArgs>
    planJob?: boolean | CloudTaskMetadata$planJobArgs<ExtArgs>
  }
  export type CloudTaskMetadataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    job?: boolean | CloudTaskMetadata$jobArgs<ExtArgs>
    planJob?: boolean | CloudTaskMetadata$planJobArgs<ExtArgs>
  }

  export type $CloudTaskMetadataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CloudTaskMetadata"
    objects: {
      job: Prisma.$InsightGenerationJobPayload<ExtArgs> | null
      planJob: Prisma.$LongevityPlanJobPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskName: string
      queue: string
      status: $Enums.CloudTaskStatus
      jobId: string | null
      planJobId: string | null
      payload: Prisma.JsonValue | null
      scheduleTime: Date | null
      firstAttemptAt: Date | null
      lastAttemptAt: Date | null
      attemptCount: number
      errorMessage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cloudTaskMetadata"]>
    composites: {}
  }

  type CloudTaskMetadataGetPayload<S extends boolean | null | undefined | CloudTaskMetadataDefaultArgs> = $Result.GetResult<Prisma.$CloudTaskMetadataPayload, S>

  type CloudTaskMetadataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CloudTaskMetadataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CloudTaskMetadataCountAggregateInputType | true
    }

  export interface CloudTaskMetadataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CloudTaskMetadata'], meta: { name: 'CloudTaskMetadata' } }
    /**
     * Find zero or one CloudTaskMetadata that matches the filter.
     * @param {CloudTaskMetadataFindUniqueArgs} args - Arguments to find a CloudTaskMetadata
     * @example
     * // Get one CloudTaskMetadata
     * const cloudTaskMetadata = await prisma.cloudTaskMetadata.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CloudTaskMetadataFindUniqueArgs>(args: SelectSubset<T, CloudTaskMetadataFindUniqueArgs<ExtArgs>>): Prisma__CloudTaskMetadataClient<$Result.GetResult<Prisma.$CloudTaskMetadataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CloudTaskMetadata that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CloudTaskMetadataFindUniqueOrThrowArgs} args - Arguments to find a CloudTaskMetadata
     * @example
     * // Get one CloudTaskMetadata
     * const cloudTaskMetadata = await prisma.cloudTaskMetadata.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CloudTaskMetadataFindUniqueOrThrowArgs>(args: SelectSubset<T, CloudTaskMetadataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CloudTaskMetadataClient<$Result.GetResult<Prisma.$CloudTaskMetadataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CloudTaskMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloudTaskMetadataFindFirstArgs} args - Arguments to find a CloudTaskMetadata
     * @example
     * // Get one CloudTaskMetadata
     * const cloudTaskMetadata = await prisma.cloudTaskMetadata.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CloudTaskMetadataFindFirstArgs>(args?: SelectSubset<T, CloudTaskMetadataFindFirstArgs<ExtArgs>>): Prisma__CloudTaskMetadataClient<$Result.GetResult<Prisma.$CloudTaskMetadataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CloudTaskMetadata that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloudTaskMetadataFindFirstOrThrowArgs} args - Arguments to find a CloudTaskMetadata
     * @example
     * // Get one CloudTaskMetadata
     * const cloudTaskMetadata = await prisma.cloudTaskMetadata.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CloudTaskMetadataFindFirstOrThrowArgs>(args?: SelectSubset<T, CloudTaskMetadataFindFirstOrThrowArgs<ExtArgs>>): Prisma__CloudTaskMetadataClient<$Result.GetResult<Prisma.$CloudTaskMetadataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CloudTaskMetadata that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloudTaskMetadataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CloudTaskMetadata
     * const cloudTaskMetadata = await prisma.cloudTaskMetadata.findMany()
     * 
     * // Get first 10 CloudTaskMetadata
     * const cloudTaskMetadata = await prisma.cloudTaskMetadata.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cloudTaskMetadataWithIdOnly = await prisma.cloudTaskMetadata.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CloudTaskMetadataFindManyArgs>(args?: SelectSubset<T, CloudTaskMetadataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CloudTaskMetadataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CloudTaskMetadata.
     * @param {CloudTaskMetadataCreateArgs} args - Arguments to create a CloudTaskMetadata.
     * @example
     * // Create one CloudTaskMetadata
     * const CloudTaskMetadata = await prisma.cloudTaskMetadata.create({
     *   data: {
     *     // ... data to create a CloudTaskMetadata
     *   }
     * })
     * 
     */
    create<T extends CloudTaskMetadataCreateArgs>(args: SelectSubset<T, CloudTaskMetadataCreateArgs<ExtArgs>>): Prisma__CloudTaskMetadataClient<$Result.GetResult<Prisma.$CloudTaskMetadataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CloudTaskMetadata.
     * @param {CloudTaskMetadataCreateManyArgs} args - Arguments to create many CloudTaskMetadata.
     * @example
     * // Create many CloudTaskMetadata
     * const cloudTaskMetadata = await prisma.cloudTaskMetadata.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CloudTaskMetadataCreateManyArgs>(args?: SelectSubset<T, CloudTaskMetadataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CloudTaskMetadata and returns the data saved in the database.
     * @param {CloudTaskMetadataCreateManyAndReturnArgs} args - Arguments to create many CloudTaskMetadata.
     * @example
     * // Create many CloudTaskMetadata
     * const cloudTaskMetadata = await prisma.cloudTaskMetadata.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CloudTaskMetadata and only return the `id`
     * const cloudTaskMetadataWithIdOnly = await prisma.cloudTaskMetadata.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CloudTaskMetadataCreateManyAndReturnArgs>(args?: SelectSubset<T, CloudTaskMetadataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CloudTaskMetadataPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CloudTaskMetadata.
     * @param {CloudTaskMetadataDeleteArgs} args - Arguments to delete one CloudTaskMetadata.
     * @example
     * // Delete one CloudTaskMetadata
     * const CloudTaskMetadata = await prisma.cloudTaskMetadata.delete({
     *   where: {
     *     // ... filter to delete one CloudTaskMetadata
     *   }
     * })
     * 
     */
    delete<T extends CloudTaskMetadataDeleteArgs>(args: SelectSubset<T, CloudTaskMetadataDeleteArgs<ExtArgs>>): Prisma__CloudTaskMetadataClient<$Result.GetResult<Prisma.$CloudTaskMetadataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CloudTaskMetadata.
     * @param {CloudTaskMetadataUpdateArgs} args - Arguments to update one CloudTaskMetadata.
     * @example
     * // Update one CloudTaskMetadata
     * const cloudTaskMetadata = await prisma.cloudTaskMetadata.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CloudTaskMetadataUpdateArgs>(args: SelectSubset<T, CloudTaskMetadataUpdateArgs<ExtArgs>>): Prisma__CloudTaskMetadataClient<$Result.GetResult<Prisma.$CloudTaskMetadataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CloudTaskMetadata.
     * @param {CloudTaskMetadataDeleteManyArgs} args - Arguments to filter CloudTaskMetadata to delete.
     * @example
     * // Delete a few CloudTaskMetadata
     * const { count } = await prisma.cloudTaskMetadata.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CloudTaskMetadataDeleteManyArgs>(args?: SelectSubset<T, CloudTaskMetadataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CloudTaskMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloudTaskMetadataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CloudTaskMetadata
     * const cloudTaskMetadata = await prisma.cloudTaskMetadata.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CloudTaskMetadataUpdateManyArgs>(args: SelectSubset<T, CloudTaskMetadataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CloudTaskMetadata.
     * @param {CloudTaskMetadataUpsertArgs} args - Arguments to update or create a CloudTaskMetadata.
     * @example
     * // Update or create a CloudTaskMetadata
     * const cloudTaskMetadata = await prisma.cloudTaskMetadata.upsert({
     *   create: {
     *     // ... data to create a CloudTaskMetadata
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CloudTaskMetadata we want to update
     *   }
     * })
     */
    upsert<T extends CloudTaskMetadataUpsertArgs>(args: SelectSubset<T, CloudTaskMetadataUpsertArgs<ExtArgs>>): Prisma__CloudTaskMetadataClient<$Result.GetResult<Prisma.$CloudTaskMetadataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CloudTaskMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloudTaskMetadataCountArgs} args - Arguments to filter CloudTaskMetadata to count.
     * @example
     * // Count the number of CloudTaskMetadata
     * const count = await prisma.cloudTaskMetadata.count({
     *   where: {
     *     // ... the filter for the CloudTaskMetadata we want to count
     *   }
     * })
    **/
    count<T extends CloudTaskMetadataCountArgs>(
      args?: Subset<T, CloudTaskMetadataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CloudTaskMetadataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CloudTaskMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloudTaskMetadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CloudTaskMetadataAggregateArgs>(args: Subset<T, CloudTaskMetadataAggregateArgs>): Prisma.PrismaPromise<GetCloudTaskMetadataAggregateType<T>>

    /**
     * Group by CloudTaskMetadata.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CloudTaskMetadataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CloudTaskMetadataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CloudTaskMetadataGroupByArgs['orderBy'] }
        : { orderBy?: CloudTaskMetadataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CloudTaskMetadataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCloudTaskMetadataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CloudTaskMetadata model
   */
  readonly fields: CloudTaskMetadataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CloudTaskMetadata.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CloudTaskMetadataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    job<T extends CloudTaskMetadata$jobArgs<ExtArgs> = {}>(args?: Subset<T, CloudTaskMetadata$jobArgs<ExtArgs>>): Prisma__InsightGenerationJobClient<$Result.GetResult<Prisma.$InsightGenerationJobPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    planJob<T extends CloudTaskMetadata$planJobArgs<ExtArgs> = {}>(args?: Subset<T, CloudTaskMetadata$planJobArgs<ExtArgs>>): Prisma__LongevityPlanJobClient<$Result.GetResult<Prisma.$LongevityPlanJobPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CloudTaskMetadata model
   */ 
  interface CloudTaskMetadataFieldRefs {
    readonly id: FieldRef<"CloudTaskMetadata", 'String'>
    readonly taskName: FieldRef<"CloudTaskMetadata", 'String'>
    readonly queue: FieldRef<"CloudTaskMetadata", 'String'>
    readonly status: FieldRef<"CloudTaskMetadata", 'CloudTaskStatus'>
    readonly jobId: FieldRef<"CloudTaskMetadata", 'String'>
    readonly planJobId: FieldRef<"CloudTaskMetadata", 'String'>
    readonly payload: FieldRef<"CloudTaskMetadata", 'Json'>
    readonly scheduleTime: FieldRef<"CloudTaskMetadata", 'DateTime'>
    readonly firstAttemptAt: FieldRef<"CloudTaskMetadata", 'DateTime'>
    readonly lastAttemptAt: FieldRef<"CloudTaskMetadata", 'DateTime'>
    readonly attemptCount: FieldRef<"CloudTaskMetadata", 'Int'>
    readonly errorMessage: FieldRef<"CloudTaskMetadata", 'String'>
    readonly createdAt: FieldRef<"CloudTaskMetadata", 'DateTime'>
    readonly updatedAt: FieldRef<"CloudTaskMetadata", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CloudTaskMetadata findUnique
   */
  export type CloudTaskMetadataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudTaskMetadata
     */
    select?: CloudTaskMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudTaskMetadataInclude<ExtArgs> | null
    /**
     * Filter, which CloudTaskMetadata to fetch.
     */
    where: CloudTaskMetadataWhereUniqueInput
  }

  /**
   * CloudTaskMetadata findUniqueOrThrow
   */
  export type CloudTaskMetadataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudTaskMetadata
     */
    select?: CloudTaskMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudTaskMetadataInclude<ExtArgs> | null
    /**
     * Filter, which CloudTaskMetadata to fetch.
     */
    where: CloudTaskMetadataWhereUniqueInput
  }

  /**
   * CloudTaskMetadata findFirst
   */
  export type CloudTaskMetadataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudTaskMetadata
     */
    select?: CloudTaskMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudTaskMetadataInclude<ExtArgs> | null
    /**
     * Filter, which CloudTaskMetadata to fetch.
     */
    where?: CloudTaskMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CloudTaskMetadata to fetch.
     */
    orderBy?: CloudTaskMetadataOrderByWithRelationInput | CloudTaskMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CloudTaskMetadata.
     */
    cursor?: CloudTaskMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CloudTaskMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CloudTaskMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CloudTaskMetadata.
     */
    distinct?: CloudTaskMetadataScalarFieldEnum | CloudTaskMetadataScalarFieldEnum[]
  }

  /**
   * CloudTaskMetadata findFirstOrThrow
   */
  export type CloudTaskMetadataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudTaskMetadata
     */
    select?: CloudTaskMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudTaskMetadataInclude<ExtArgs> | null
    /**
     * Filter, which CloudTaskMetadata to fetch.
     */
    where?: CloudTaskMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CloudTaskMetadata to fetch.
     */
    orderBy?: CloudTaskMetadataOrderByWithRelationInput | CloudTaskMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CloudTaskMetadata.
     */
    cursor?: CloudTaskMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CloudTaskMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CloudTaskMetadata.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CloudTaskMetadata.
     */
    distinct?: CloudTaskMetadataScalarFieldEnum | CloudTaskMetadataScalarFieldEnum[]
  }

  /**
   * CloudTaskMetadata findMany
   */
  export type CloudTaskMetadataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudTaskMetadata
     */
    select?: CloudTaskMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudTaskMetadataInclude<ExtArgs> | null
    /**
     * Filter, which CloudTaskMetadata to fetch.
     */
    where?: CloudTaskMetadataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CloudTaskMetadata to fetch.
     */
    orderBy?: CloudTaskMetadataOrderByWithRelationInput | CloudTaskMetadataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CloudTaskMetadata.
     */
    cursor?: CloudTaskMetadataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CloudTaskMetadata from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CloudTaskMetadata.
     */
    skip?: number
    distinct?: CloudTaskMetadataScalarFieldEnum | CloudTaskMetadataScalarFieldEnum[]
  }

  /**
   * CloudTaskMetadata create
   */
  export type CloudTaskMetadataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudTaskMetadata
     */
    select?: CloudTaskMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudTaskMetadataInclude<ExtArgs> | null
    /**
     * The data needed to create a CloudTaskMetadata.
     */
    data: XOR<CloudTaskMetadataCreateInput, CloudTaskMetadataUncheckedCreateInput>
  }

  /**
   * CloudTaskMetadata createMany
   */
  export type CloudTaskMetadataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CloudTaskMetadata.
     */
    data: CloudTaskMetadataCreateManyInput | CloudTaskMetadataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CloudTaskMetadata createManyAndReturn
   */
  export type CloudTaskMetadataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudTaskMetadata
     */
    select?: CloudTaskMetadataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CloudTaskMetadata.
     */
    data: CloudTaskMetadataCreateManyInput | CloudTaskMetadataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudTaskMetadataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CloudTaskMetadata update
   */
  export type CloudTaskMetadataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudTaskMetadata
     */
    select?: CloudTaskMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudTaskMetadataInclude<ExtArgs> | null
    /**
     * The data needed to update a CloudTaskMetadata.
     */
    data: XOR<CloudTaskMetadataUpdateInput, CloudTaskMetadataUncheckedUpdateInput>
    /**
     * Choose, which CloudTaskMetadata to update.
     */
    where: CloudTaskMetadataWhereUniqueInput
  }

  /**
   * CloudTaskMetadata updateMany
   */
  export type CloudTaskMetadataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CloudTaskMetadata.
     */
    data: XOR<CloudTaskMetadataUpdateManyMutationInput, CloudTaskMetadataUncheckedUpdateManyInput>
    /**
     * Filter which CloudTaskMetadata to update
     */
    where?: CloudTaskMetadataWhereInput
  }

  /**
   * CloudTaskMetadata upsert
   */
  export type CloudTaskMetadataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudTaskMetadata
     */
    select?: CloudTaskMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudTaskMetadataInclude<ExtArgs> | null
    /**
     * The filter to search for the CloudTaskMetadata to update in case it exists.
     */
    where: CloudTaskMetadataWhereUniqueInput
    /**
     * In case the CloudTaskMetadata found by the `where` argument doesn't exist, create a new CloudTaskMetadata with this data.
     */
    create: XOR<CloudTaskMetadataCreateInput, CloudTaskMetadataUncheckedCreateInput>
    /**
     * In case the CloudTaskMetadata was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CloudTaskMetadataUpdateInput, CloudTaskMetadataUncheckedUpdateInput>
  }

  /**
   * CloudTaskMetadata delete
   */
  export type CloudTaskMetadataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudTaskMetadata
     */
    select?: CloudTaskMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudTaskMetadataInclude<ExtArgs> | null
    /**
     * Filter which CloudTaskMetadata to delete.
     */
    where: CloudTaskMetadataWhereUniqueInput
  }

  /**
   * CloudTaskMetadata deleteMany
   */
  export type CloudTaskMetadataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CloudTaskMetadata to delete
     */
    where?: CloudTaskMetadataWhereInput
  }

  /**
   * CloudTaskMetadata.job
   */
  export type CloudTaskMetadata$jobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InsightGenerationJob
     */
    select?: InsightGenerationJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightGenerationJobInclude<ExtArgs> | null
    where?: InsightGenerationJobWhereInput
  }

  /**
   * CloudTaskMetadata.planJob
   */
  export type CloudTaskMetadata$planJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlanJob
     */
    select?: LongevityPlanJobSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanJobInclude<ExtArgs> | null
    where?: LongevityPlanJobWhereInput
  }

  /**
   * CloudTaskMetadata without action
   */
  export type CloudTaskMetadataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CloudTaskMetadata
     */
    select?: CloudTaskMetadataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CloudTaskMetadataInclude<ExtArgs> | null
  }


  /**
   * Model WhoopIntegration
   */

  export type AggregateWhoopIntegration = {
    _count: WhoopIntegrationCountAggregateOutputType | null
    _min: WhoopIntegrationMinAggregateOutputType | null
    _max: WhoopIntegrationMaxAggregateOutputType | null
  }

  export type WhoopIntegrationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    whoopUserId: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    tokenKeyId: string | null
    tokenRotatedAt: Date | null
    syncStatus: $Enums.WhoopSyncStatus | null
    lastSyncedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhoopIntegrationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    whoopUserId: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    tokenKeyId: string | null
    tokenRotatedAt: Date | null
    syncStatus: $Enums.WhoopSyncStatus | null
    lastSyncedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type WhoopIntegrationCountAggregateOutputType = {
    id: number
    userId: number
    whoopUserId: number
    accessToken: number
    refreshToken: number
    expiresAt: number
    scope: number
    tokenKeyId: number
    tokenRotatedAt: number
    syncStatus: number
    lastSyncedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type WhoopIntegrationMinAggregateInputType = {
    id?: true
    userId?: true
    whoopUserId?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    tokenKeyId?: true
    tokenRotatedAt?: true
    syncStatus?: true
    lastSyncedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhoopIntegrationMaxAggregateInputType = {
    id?: true
    userId?: true
    whoopUserId?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    tokenKeyId?: true
    tokenRotatedAt?: true
    syncStatus?: true
    lastSyncedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type WhoopIntegrationCountAggregateInputType = {
    id?: true
    userId?: true
    whoopUserId?: true
    accessToken?: true
    refreshToken?: true
    expiresAt?: true
    scope?: true
    tokenKeyId?: true
    tokenRotatedAt?: true
    syncStatus?: true
    lastSyncedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type WhoopIntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhoopIntegration to aggregate.
     */
    where?: WhoopIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhoopIntegrations to fetch.
     */
    orderBy?: WhoopIntegrationOrderByWithRelationInput | WhoopIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhoopIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhoopIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhoopIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhoopIntegrations
    **/
    _count?: true | WhoopIntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhoopIntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhoopIntegrationMaxAggregateInputType
  }

  export type GetWhoopIntegrationAggregateType<T extends WhoopIntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateWhoopIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhoopIntegration[P]>
      : GetScalarType<T[P], AggregateWhoopIntegration[P]>
  }




  export type WhoopIntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhoopIntegrationWhereInput
    orderBy?: WhoopIntegrationOrderByWithAggregationInput | WhoopIntegrationOrderByWithAggregationInput[]
    by: WhoopIntegrationScalarFieldEnum[] | WhoopIntegrationScalarFieldEnum
    having?: WhoopIntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhoopIntegrationCountAggregateInputType | true
    _min?: WhoopIntegrationMinAggregateInputType
    _max?: WhoopIntegrationMaxAggregateInputType
  }

  export type WhoopIntegrationGroupByOutputType = {
    id: string
    userId: string
    whoopUserId: string | null
    accessToken: string | null
    refreshToken: string | null
    expiresAt: Date | null
    scope: string[]
    tokenKeyId: string | null
    tokenRotatedAt: Date | null
    syncStatus: $Enums.WhoopSyncStatus
    lastSyncedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: WhoopIntegrationCountAggregateOutputType | null
    _min: WhoopIntegrationMinAggregateOutputType | null
    _max: WhoopIntegrationMaxAggregateOutputType | null
  }

  type GetWhoopIntegrationGroupByPayload<T extends WhoopIntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhoopIntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhoopIntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhoopIntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], WhoopIntegrationGroupByOutputType[P]>
        }
      >
    >


  export type WhoopIntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    whoopUserId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    scope?: boolean
    tokenKeyId?: boolean
    tokenRotatedAt?: boolean
    syncStatus?: boolean
    lastSyncedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whoopIntegration"]>

  export type WhoopIntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    whoopUserId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    scope?: boolean
    tokenKeyId?: boolean
    tokenRotatedAt?: boolean
    syncStatus?: boolean
    lastSyncedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whoopIntegration"]>

  export type WhoopIntegrationSelectScalar = {
    id?: boolean
    userId?: boolean
    whoopUserId?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    expiresAt?: boolean
    scope?: boolean
    tokenKeyId?: boolean
    tokenRotatedAt?: boolean
    syncStatus?: boolean
    lastSyncedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type WhoopIntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WhoopIntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WhoopIntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhoopIntegration"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      whoopUserId: string | null
      accessToken: string | null
      refreshToken: string | null
      expiresAt: Date | null
      scope: string[]
      tokenKeyId: string | null
      tokenRotatedAt: Date | null
      syncStatus: $Enums.WhoopSyncStatus
      lastSyncedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["whoopIntegration"]>
    composites: {}
  }

  type WhoopIntegrationGetPayload<S extends boolean | null | undefined | WhoopIntegrationDefaultArgs> = $Result.GetResult<Prisma.$WhoopIntegrationPayload, S>

  type WhoopIntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WhoopIntegrationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WhoopIntegrationCountAggregateInputType | true
    }

  export interface WhoopIntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhoopIntegration'], meta: { name: 'WhoopIntegration' } }
    /**
     * Find zero or one WhoopIntegration that matches the filter.
     * @param {WhoopIntegrationFindUniqueArgs} args - Arguments to find a WhoopIntegration
     * @example
     * // Get one WhoopIntegration
     * const whoopIntegration = await prisma.whoopIntegration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhoopIntegrationFindUniqueArgs>(args: SelectSubset<T, WhoopIntegrationFindUniqueArgs<ExtArgs>>): Prisma__WhoopIntegrationClient<$Result.GetResult<Prisma.$WhoopIntegrationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WhoopIntegration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WhoopIntegrationFindUniqueOrThrowArgs} args - Arguments to find a WhoopIntegration
     * @example
     * // Get one WhoopIntegration
     * const whoopIntegration = await prisma.whoopIntegration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhoopIntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, WhoopIntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhoopIntegrationClient<$Result.GetResult<Prisma.$WhoopIntegrationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WhoopIntegration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhoopIntegrationFindFirstArgs} args - Arguments to find a WhoopIntegration
     * @example
     * // Get one WhoopIntegration
     * const whoopIntegration = await prisma.whoopIntegration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhoopIntegrationFindFirstArgs>(args?: SelectSubset<T, WhoopIntegrationFindFirstArgs<ExtArgs>>): Prisma__WhoopIntegrationClient<$Result.GetResult<Prisma.$WhoopIntegrationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WhoopIntegration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhoopIntegrationFindFirstOrThrowArgs} args - Arguments to find a WhoopIntegration
     * @example
     * // Get one WhoopIntegration
     * const whoopIntegration = await prisma.whoopIntegration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhoopIntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, WhoopIntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhoopIntegrationClient<$Result.GetResult<Prisma.$WhoopIntegrationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WhoopIntegrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhoopIntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhoopIntegrations
     * const whoopIntegrations = await prisma.whoopIntegration.findMany()
     * 
     * // Get first 10 WhoopIntegrations
     * const whoopIntegrations = await prisma.whoopIntegration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whoopIntegrationWithIdOnly = await prisma.whoopIntegration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhoopIntegrationFindManyArgs>(args?: SelectSubset<T, WhoopIntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhoopIntegrationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WhoopIntegration.
     * @param {WhoopIntegrationCreateArgs} args - Arguments to create a WhoopIntegration.
     * @example
     * // Create one WhoopIntegration
     * const WhoopIntegration = await prisma.whoopIntegration.create({
     *   data: {
     *     // ... data to create a WhoopIntegration
     *   }
     * })
     * 
     */
    create<T extends WhoopIntegrationCreateArgs>(args: SelectSubset<T, WhoopIntegrationCreateArgs<ExtArgs>>): Prisma__WhoopIntegrationClient<$Result.GetResult<Prisma.$WhoopIntegrationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WhoopIntegrations.
     * @param {WhoopIntegrationCreateManyArgs} args - Arguments to create many WhoopIntegrations.
     * @example
     * // Create many WhoopIntegrations
     * const whoopIntegration = await prisma.whoopIntegration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhoopIntegrationCreateManyArgs>(args?: SelectSubset<T, WhoopIntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhoopIntegrations and returns the data saved in the database.
     * @param {WhoopIntegrationCreateManyAndReturnArgs} args - Arguments to create many WhoopIntegrations.
     * @example
     * // Create many WhoopIntegrations
     * const whoopIntegration = await prisma.whoopIntegration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhoopIntegrations and only return the `id`
     * const whoopIntegrationWithIdOnly = await prisma.whoopIntegration.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhoopIntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, WhoopIntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhoopIntegrationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WhoopIntegration.
     * @param {WhoopIntegrationDeleteArgs} args - Arguments to delete one WhoopIntegration.
     * @example
     * // Delete one WhoopIntegration
     * const WhoopIntegration = await prisma.whoopIntegration.delete({
     *   where: {
     *     // ... filter to delete one WhoopIntegration
     *   }
     * })
     * 
     */
    delete<T extends WhoopIntegrationDeleteArgs>(args: SelectSubset<T, WhoopIntegrationDeleteArgs<ExtArgs>>): Prisma__WhoopIntegrationClient<$Result.GetResult<Prisma.$WhoopIntegrationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WhoopIntegration.
     * @param {WhoopIntegrationUpdateArgs} args - Arguments to update one WhoopIntegration.
     * @example
     * // Update one WhoopIntegration
     * const whoopIntegration = await prisma.whoopIntegration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhoopIntegrationUpdateArgs>(args: SelectSubset<T, WhoopIntegrationUpdateArgs<ExtArgs>>): Prisma__WhoopIntegrationClient<$Result.GetResult<Prisma.$WhoopIntegrationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WhoopIntegrations.
     * @param {WhoopIntegrationDeleteManyArgs} args - Arguments to filter WhoopIntegrations to delete.
     * @example
     * // Delete a few WhoopIntegrations
     * const { count } = await prisma.whoopIntegration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhoopIntegrationDeleteManyArgs>(args?: SelectSubset<T, WhoopIntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhoopIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhoopIntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhoopIntegrations
     * const whoopIntegration = await prisma.whoopIntegration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhoopIntegrationUpdateManyArgs>(args: SelectSubset<T, WhoopIntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WhoopIntegration.
     * @param {WhoopIntegrationUpsertArgs} args - Arguments to update or create a WhoopIntegration.
     * @example
     * // Update or create a WhoopIntegration
     * const whoopIntegration = await prisma.whoopIntegration.upsert({
     *   create: {
     *     // ... data to create a WhoopIntegration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhoopIntegration we want to update
     *   }
     * })
     */
    upsert<T extends WhoopIntegrationUpsertArgs>(args: SelectSubset<T, WhoopIntegrationUpsertArgs<ExtArgs>>): Prisma__WhoopIntegrationClient<$Result.GetResult<Prisma.$WhoopIntegrationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WhoopIntegrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhoopIntegrationCountArgs} args - Arguments to filter WhoopIntegrations to count.
     * @example
     * // Count the number of WhoopIntegrations
     * const count = await prisma.whoopIntegration.count({
     *   where: {
     *     // ... the filter for the WhoopIntegrations we want to count
     *   }
     * })
    **/
    count<T extends WhoopIntegrationCountArgs>(
      args?: Subset<T, WhoopIntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhoopIntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhoopIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhoopIntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhoopIntegrationAggregateArgs>(args: Subset<T, WhoopIntegrationAggregateArgs>): Prisma.PrismaPromise<GetWhoopIntegrationAggregateType<T>>

    /**
     * Group by WhoopIntegration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhoopIntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhoopIntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhoopIntegrationGroupByArgs['orderBy'] }
        : { orderBy?: WhoopIntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhoopIntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhoopIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhoopIntegration model
   */
  readonly fields: WhoopIntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhoopIntegration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhoopIntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhoopIntegration model
   */ 
  interface WhoopIntegrationFieldRefs {
    readonly id: FieldRef<"WhoopIntegration", 'String'>
    readonly userId: FieldRef<"WhoopIntegration", 'String'>
    readonly whoopUserId: FieldRef<"WhoopIntegration", 'String'>
    readonly accessToken: FieldRef<"WhoopIntegration", 'String'>
    readonly refreshToken: FieldRef<"WhoopIntegration", 'String'>
    readonly expiresAt: FieldRef<"WhoopIntegration", 'DateTime'>
    readonly scope: FieldRef<"WhoopIntegration", 'String[]'>
    readonly tokenKeyId: FieldRef<"WhoopIntegration", 'String'>
    readonly tokenRotatedAt: FieldRef<"WhoopIntegration", 'DateTime'>
    readonly syncStatus: FieldRef<"WhoopIntegration", 'WhoopSyncStatus'>
    readonly lastSyncedAt: FieldRef<"WhoopIntegration", 'DateTime'>
    readonly createdAt: FieldRef<"WhoopIntegration", 'DateTime'>
    readonly updatedAt: FieldRef<"WhoopIntegration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhoopIntegration findUnique
   */
  export type WhoopIntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopIntegration
     */
    select?: WhoopIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which WhoopIntegration to fetch.
     */
    where: WhoopIntegrationWhereUniqueInput
  }

  /**
   * WhoopIntegration findUniqueOrThrow
   */
  export type WhoopIntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopIntegration
     */
    select?: WhoopIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which WhoopIntegration to fetch.
     */
    where: WhoopIntegrationWhereUniqueInput
  }

  /**
   * WhoopIntegration findFirst
   */
  export type WhoopIntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopIntegration
     */
    select?: WhoopIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which WhoopIntegration to fetch.
     */
    where?: WhoopIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhoopIntegrations to fetch.
     */
    orderBy?: WhoopIntegrationOrderByWithRelationInput | WhoopIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhoopIntegrations.
     */
    cursor?: WhoopIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhoopIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhoopIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhoopIntegrations.
     */
    distinct?: WhoopIntegrationScalarFieldEnum | WhoopIntegrationScalarFieldEnum[]
  }

  /**
   * WhoopIntegration findFirstOrThrow
   */
  export type WhoopIntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopIntegration
     */
    select?: WhoopIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which WhoopIntegration to fetch.
     */
    where?: WhoopIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhoopIntegrations to fetch.
     */
    orderBy?: WhoopIntegrationOrderByWithRelationInput | WhoopIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhoopIntegrations.
     */
    cursor?: WhoopIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhoopIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhoopIntegrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhoopIntegrations.
     */
    distinct?: WhoopIntegrationScalarFieldEnum | WhoopIntegrationScalarFieldEnum[]
  }

  /**
   * WhoopIntegration findMany
   */
  export type WhoopIntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopIntegration
     */
    select?: WhoopIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopIntegrationInclude<ExtArgs> | null
    /**
     * Filter, which WhoopIntegrations to fetch.
     */
    where?: WhoopIntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhoopIntegrations to fetch.
     */
    orderBy?: WhoopIntegrationOrderByWithRelationInput | WhoopIntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhoopIntegrations.
     */
    cursor?: WhoopIntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhoopIntegrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhoopIntegrations.
     */
    skip?: number
    distinct?: WhoopIntegrationScalarFieldEnum | WhoopIntegrationScalarFieldEnum[]
  }

  /**
   * WhoopIntegration create
   */
  export type WhoopIntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopIntegration
     */
    select?: WhoopIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a WhoopIntegration.
     */
    data: XOR<WhoopIntegrationCreateInput, WhoopIntegrationUncheckedCreateInput>
  }

  /**
   * WhoopIntegration createMany
   */
  export type WhoopIntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhoopIntegrations.
     */
    data: WhoopIntegrationCreateManyInput | WhoopIntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhoopIntegration createManyAndReturn
   */
  export type WhoopIntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopIntegration
     */
    select?: WhoopIntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WhoopIntegrations.
     */
    data: WhoopIntegrationCreateManyInput | WhoopIntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopIntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhoopIntegration update
   */
  export type WhoopIntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopIntegration
     */
    select?: WhoopIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopIntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a WhoopIntegration.
     */
    data: XOR<WhoopIntegrationUpdateInput, WhoopIntegrationUncheckedUpdateInput>
    /**
     * Choose, which WhoopIntegration to update.
     */
    where: WhoopIntegrationWhereUniqueInput
  }

  /**
   * WhoopIntegration updateMany
   */
  export type WhoopIntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhoopIntegrations.
     */
    data: XOR<WhoopIntegrationUpdateManyMutationInput, WhoopIntegrationUncheckedUpdateManyInput>
    /**
     * Filter which WhoopIntegrations to update
     */
    where?: WhoopIntegrationWhereInput
  }

  /**
   * WhoopIntegration upsert
   */
  export type WhoopIntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopIntegration
     */
    select?: WhoopIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopIntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the WhoopIntegration to update in case it exists.
     */
    where: WhoopIntegrationWhereUniqueInput
    /**
     * In case the WhoopIntegration found by the `where` argument doesn't exist, create a new WhoopIntegration with this data.
     */
    create: XOR<WhoopIntegrationCreateInput, WhoopIntegrationUncheckedCreateInput>
    /**
     * In case the WhoopIntegration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhoopIntegrationUpdateInput, WhoopIntegrationUncheckedUpdateInput>
  }

  /**
   * WhoopIntegration delete
   */
  export type WhoopIntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopIntegration
     */
    select?: WhoopIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopIntegrationInclude<ExtArgs> | null
    /**
     * Filter which WhoopIntegration to delete.
     */
    where: WhoopIntegrationWhereUniqueInput
  }

  /**
   * WhoopIntegration deleteMany
   */
  export type WhoopIntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhoopIntegrations to delete
     */
    where?: WhoopIntegrationWhereInput
  }

  /**
   * WhoopIntegration without action
   */
  export type WhoopIntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopIntegration
     */
    select?: WhoopIntegrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopIntegrationInclude<ExtArgs> | null
  }


  /**
   * Model WhoopLinkSession
   */

  export type AggregateWhoopLinkSession = {
    _count: WhoopLinkSessionCountAggregateOutputType | null
    _min: WhoopLinkSessionMinAggregateOutputType | null
    _max: WhoopLinkSessionMaxAggregateOutputType | null
  }

  export type WhoopLinkSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    state: string | null
    redirectUri: string | null
    expiresAt: Date | null
    createdAt: Date | null
    completedAt: Date | null
    cancelledAt: Date | null
  }

  export type WhoopLinkSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    state: string | null
    redirectUri: string | null
    expiresAt: Date | null
    createdAt: Date | null
    completedAt: Date | null
    cancelledAt: Date | null
  }

  export type WhoopLinkSessionCountAggregateOutputType = {
    id: number
    userId: number
    state: number
    redirectUri: number
    scope: number
    expiresAt: number
    createdAt: number
    completedAt: number
    cancelledAt: number
    _all: number
  }


  export type WhoopLinkSessionMinAggregateInputType = {
    id?: true
    userId?: true
    state?: true
    redirectUri?: true
    expiresAt?: true
    createdAt?: true
    completedAt?: true
    cancelledAt?: true
  }

  export type WhoopLinkSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    state?: true
    redirectUri?: true
    expiresAt?: true
    createdAt?: true
    completedAt?: true
    cancelledAt?: true
  }

  export type WhoopLinkSessionCountAggregateInputType = {
    id?: true
    userId?: true
    state?: true
    redirectUri?: true
    scope?: true
    expiresAt?: true
    createdAt?: true
    completedAt?: true
    cancelledAt?: true
    _all?: true
  }

  export type WhoopLinkSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhoopLinkSession to aggregate.
     */
    where?: WhoopLinkSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhoopLinkSessions to fetch.
     */
    orderBy?: WhoopLinkSessionOrderByWithRelationInput | WhoopLinkSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WhoopLinkSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhoopLinkSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhoopLinkSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WhoopLinkSessions
    **/
    _count?: true | WhoopLinkSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WhoopLinkSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WhoopLinkSessionMaxAggregateInputType
  }

  export type GetWhoopLinkSessionAggregateType<T extends WhoopLinkSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateWhoopLinkSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWhoopLinkSession[P]>
      : GetScalarType<T[P], AggregateWhoopLinkSession[P]>
  }




  export type WhoopLinkSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WhoopLinkSessionWhereInput
    orderBy?: WhoopLinkSessionOrderByWithAggregationInput | WhoopLinkSessionOrderByWithAggregationInput[]
    by: WhoopLinkSessionScalarFieldEnum[] | WhoopLinkSessionScalarFieldEnum
    having?: WhoopLinkSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WhoopLinkSessionCountAggregateInputType | true
    _min?: WhoopLinkSessionMinAggregateInputType
    _max?: WhoopLinkSessionMaxAggregateInputType
  }

  export type WhoopLinkSessionGroupByOutputType = {
    id: string
    userId: string
    state: string
    redirectUri: string
    scope: string[]
    expiresAt: Date
    createdAt: Date
    completedAt: Date | null
    cancelledAt: Date | null
    _count: WhoopLinkSessionCountAggregateOutputType | null
    _min: WhoopLinkSessionMinAggregateOutputType | null
    _max: WhoopLinkSessionMaxAggregateOutputType | null
  }

  type GetWhoopLinkSessionGroupByPayload<T extends WhoopLinkSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WhoopLinkSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WhoopLinkSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WhoopLinkSessionGroupByOutputType[P]>
            : GetScalarType<T[P], WhoopLinkSessionGroupByOutputType[P]>
        }
      >
    >


  export type WhoopLinkSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    state?: boolean
    redirectUri?: boolean
    scope?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    completedAt?: boolean
    cancelledAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whoopLinkSession"]>

  export type WhoopLinkSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    state?: boolean
    redirectUri?: boolean
    scope?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    completedAt?: boolean
    cancelledAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["whoopLinkSession"]>

  export type WhoopLinkSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    state?: boolean
    redirectUri?: boolean
    scope?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    completedAt?: boolean
    cancelledAt?: boolean
  }

  export type WhoopLinkSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type WhoopLinkSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $WhoopLinkSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WhoopLinkSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      state: string
      redirectUri: string
      scope: string[]
      expiresAt: Date
      createdAt: Date
      completedAt: Date | null
      cancelledAt: Date | null
    }, ExtArgs["result"]["whoopLinkSession"]>
    composites: {}
  }

  type WhoopLinkSessionGetPayload<S extends boolean | null | undefined | WhoopLinkSessionDefaultArgs> = $Result.GetResult<Prisma.$WhoopLinkSessionPayload, S>

  type WhoopLinkSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WhoopLinkSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WhoopLinkSessionCountAggregateInputType | true
    }

  export interface WhoopLinkSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WhoopLinkSession'], meta: { name: 'WhoopLinkSession' } }
    /**
     * Find zero or one WhoopLinkSession that matches the filter.
     * @param {WhoopLinkSessionFindUniqueArgs} args - Arguments to find a WhoopLinkSession
     * @example
     * // Get one WhoopLinkSession
     * const whoopLinkSession = await prisma.whoopLinkSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WhoopLinkSessionFindUniqueArgs>(args: SelectSubset<T, WhoopLinkSessionFindUniqueArgs<ExtArgs>>): Prisma__WhoopLinkSessionClient<$Result.GetResult<Prisma.$WhoopLinkSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WhoopLinkSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WhoopLinkSessionFindUniqueOrThrowArgs} args - Arguments to find a WhoopLinkSession
     * @example
     * // Get one WhoopLinkSession
     * const whoopLinkSession = await prisma.whoopLinkSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WhoopLinkSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, WhoopLinkSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WhoopLinkSessionClient<$Result.GetResult<Prisma.$WhoopLinkSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WhoopLinkSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhoopLinkSessionFindFirstArgs} args - Arguments to find a WhoopLinkSession
     * @example
     * // Get one WhoopLinkSession
     * const whoopLinkSession = await prisma.whoopLinkSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WhoopLinkSessionFindFirstArgs>(args?: SelectSubset<T, WhoopLinkSessionFindFirstArgs<ExtArgs>>): Prisma__WhoopLinkSessionClient<$Result.GetResult<Prisma.$WhoopLinkSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WhoopLinkSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhoopLinkSessionFindFirstOrThrowArgs} args - Arguments to find a WhoopLinkSession
     * @example
     * // Get one WhoopLinkSession
     * const whoopLinkSession = await prisma.whoopLinkSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WhoopLinkSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, WhoopLinkSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__WhoopLinkSessionClient<$Result.GetResult<Prisma.$WhoopLinkSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WhoopLinkSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhoopLinkSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WhoopLinkSessions
     * const whoopLinkSessions = await prisma.whoopLinkSession.findMany()
     * 
     * // Get first 10 WhoopLinkSessions
     * const whoopLinkSessions = await prisma.whoopLinkSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const whoopLinkSessionWithIdOnly = await prisma.whoopLinkSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WhoopLinkSessionFindManyArgs>(args?: SelectSubset<T, WhoopLinkSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhoopLinkSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WhoopLinkSession.
     * @param {WhoopLinkSessionCreateArgs} args - Arguments to create a WhoopLinkSession.
     * @example
     * // Create one WhoopLinkSession
     * const WhoopLinkSession = await prisma.whoopLinkSession.create({
     *   data: {
     *     // ... data to create a WhoopLinkSession
     *   }
     * })
     * 
     */
    create<T extends WhoopLinkSessionCreateArgs>(args: SelectSubset<T, WhoopLinkSessionCreateArgs<ExtArgs>>): Prisma__WhoopLinkSessionClient<$Result.GetResult<Prisma.$WhoopLinkSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WhoopLinkSessions.
     * @param {WhoopLinkSessionCreateManyArgs} args - Arguments to create many WhoopLinkSessions.
     * @example
     * // Create many WhoopLinkSessions
     * const whoopLinkSession = await prisma.whoopLinkSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WhoopLinkSessionCreateManyArgs>(args?: SelectSubset<T, WhoopLinkSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WhoopLinkSessions and returns the data saved in the database.
     * @param {WhoopLinkSessionCreateManyAndReturnArgs} args - Arguments to create many WhoopLinkSessions.
     * @example
     * // Create many WhoopLinkSessions
     * const whoopLinkSession = await prisma.whoopLinkSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WhoopLinkSessions and only return the `id`
     * const whoopLinkSessionWithIdOnly = await prisma.whoopLinkSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WhoopLinkSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, WhoopLinkSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WhoopLinkSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a WhoopLinkSession.
     * @param {WhoopLinkSessionDeleteArgs} args - Arguments to delete one WhoopLinkSession.
     * @example
     * // Delete one WhoopLinkSession
     * const WhoopLinkSession = await prisma.whoopLinkSession.delete({
     *   where: {
     *     // ... filter to delete one WhoopLinkSession
     *   }
     * })
     * 
     */
    delete<T extends WhoopLinkSessionDeleteArgs>(args: SelectSubset<T, WhoopLinkSessionDeleteArgs<ExtArgs>>): Prisma__WhoopLinkSessionClient<$Result.GetResult<Prisma.$WhoopLinkSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WhoopLinkSession.
     * @param {WhoopLinkSessionUpdateArgs} args - Arguments to update one WhoopLinkSession.
     * @example
     * // Update one WhoopLinkSession
     * const whoopLinkSession = await prisma.whoopLinkSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WhoopLinkSessionUpdateArgs>(args: SelectSubset<T, WhoopLinkSessionUpdateArgs<ExtArgs>>): Prisma__WhoopLinkSessionClient<$Result.GetResult<Prisma.$WhoopLinkSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WhoopLinkSessions.
     * @param {WhoopLinkSessionDeleteManyArgs} args - Arguments to filter WhoopLinkSessions to delete.
     * @example
     * // Delete a few WhoopLinkSessions
     * const { count } = await prisma.whoopLinkSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WhoopLinkSessionDeleteManyArgs>(args?: SelectSubset<T, WhoopLinkSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WhoopLinkSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhoopLinkSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WhoopLinkSessions
     * const whoopLinkSession = await prisma.whoopLinkSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WhoopLinkSessionUpdateManyArgs>(args: SelectSubset<T, WhoopLinkSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WhoopLinkSession.
     * @param {WhoopLinkSessionUpsertArgs} args - Arguments to update or create a WhoopLinkSession.
     * @example
     * // Update or create a WhoopLinkSession
     * const whoopLinkSession = await prisma.whoopLinkSession.upsert({
     *   create: {
     *     // ... data to create a WhoopLinkSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WhoopLinkSession we want to update
     *   }
     * })
     */
    upsert<T extends WhoopLinkSessionUpsertArgs>(args: SelectSubset<T, WhoopLinkSessionUpsertArgs<ExtArgs>>): Prisma__WhoopLinkSessionClient<$Result.GetResult<Prisma.$WhoopLinkSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of WhoopLinkSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhoopLinkSessionCountArgs} args - Arguments to filter WhoopLinkSessions to count.
     * @example
     * // Count the number of WhoopLinkSessions
     * const count = await prisma.whoopLinkSession.count({
     *   where: {
     *     // ... the filter for the WhoopLinkSessions we want to count
     *   }
     * })
    **/
    count<T extends WhoopLinkSessionCountArgs>(
      args?: Subset<T, WhoopLinkSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WhoopLinkSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WhoopLinkSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhoopLinkSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WhoopLinkSessionAggregateArgs>(args: Subset<T, WhoopLinkSessionAggregateArgs>): Prisma.PrismaPromise<GetWhoopLinkSessionAggregateType<T>>

    /**
     * Group by WhoopLinkSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WhoopLinkSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WhoopLinkSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WhoopLinkSessionGroupByArgs['orderBy'] }
        : { orderBy?: WhoopLinkSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WhoopLinkSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWhoopLinkSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WhoopLinkSession model
   */
  readonly fields: WhoopLinkSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WhoopLinkSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WhoopLinkSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WhoopLinkSession model
   */ 
  interface WhoopLinkSessionFieldRefs {
    readonly id: FieldRef<"WhoopLinkSession", 'String'>
    readonly userId: FieldRef<"WhoopLinkSession", 'String'>
    readonly state: FieldRef<"WhoopLinkSession", 'String'>
    readonly redirectUri: FieldRef<"WhoopLinkSession", 'String'>
    readonly scope: FieldRef<"WhoopLinkSession", 'String[]'>
    readonly expiresAt: FieldRef<"WhoopLinkSession", 'DateTime'>
    readonly createdAt: FieldRef<"WhoopLinkSession", 'DateTime'>
    readonly completedAt: FieldRef<"WhoopLinkSession", 'DateTime'>
    readonly cancelledAt: FieldRef<"WhoopLinkSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WhoopLinkSession findUnique
   */
  export type WhoopLinkSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopLinkSession
     */
    select?: WhoopLinkSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopLinkSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhoopLinkSession to fetch.
     */
    where: WhoopLinkSessionWhereUniqueInput
  }

  /**
   * WhoopLinkSession findUniqueOrThrow
   */
  export type WhoopLinkSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopLinkSession
     */
    select?: WhoopLinkSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopLinkSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhoopLinkSession to fetch.
     */
    where: WhoopLinkSessionWhereUniqueInput
  }

  /**
   * WhoopLinkSession findFirst
   */
  export type WhoopLinkSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopLinkSession
     */
    select?: WhoopLinkSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopLinkSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhoopLinkSession to fetch.
     */
    where?: WhoopLinkSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhoopLinkSessions to fetch.
     */
    orderBy?: WhoopLinkSessionOrderByWithRelationInput | WhoopLinkSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhoopLinkSessions.
     */
    cursor?: WhoopLinkSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhoopLinkSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhoopLinkSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhoopLinkSessions.
     */
    distinct?: WhoopLinkSessionScalarFieldEnum | WhoopLinkSessionScalarFieldEnum[]
  }

  /**
   * WhoopLinkSession findFirstOrThrow
   */
  export type WhoopLinkSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopLinkSession
     */
    select?: WhoopLinkSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopLinkSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhoopLinkSession to fetch.
     */
    where?: WhoopLinkSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhoopLinkSessions to fetch.
     */
    orderBy?: WhoopLinkSessionOrderByWithRelationInput | WhoopLinkSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WhoopLinkSessions.
     */
    cursor?: WhoopLinkSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhoopLinkSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhoopLinkSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WhoopLinkSessions.
     */
    distinct?: WhoopLinkSessionScalarFieldEnum | WhoopLinkSessionScalarFieldEnum[]
  }

  /**
   * WhoopLinkSession findMany
   */
  export type WhoopLinkSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopLinkSession
     */
    select?: WhoopLinkSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopLinkSessionInclude<ExtArgs> | null
    /**
     * Filter, which WhoopLinkSessions to fetch.
     */
    where?: WhoopLinkSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WhoopLinkSessions to fetch.
     */
    orderBy?: WhoopLinkSessionOrderByWithRelationInput | WhoopLinkSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WhoopLinkSessions.
     */
    cursor?: WhoopLinkSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WhoopLinkSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WhoopLinkSessions.
     */
    skip?: number
    distinct?: WhoopLinkSessionScalarFieldEnum | WhoopLinkSessionScalarFieldEnum[]
  }

  /**
   * WhoopLinkSession create
   */
  export type WhoopLinkSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopLinkSession
     */
    select?: WhoopLinkSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopLinkSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a WhoopLinkSession.
     */
    data: XOR<WhoopLinkSessionCreateInput, WhoopLinkSessionUncheckedCreateInput>
  }

  /**
   * WhoopLinkSession createMany
   */
  export type WhoopLinkSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WhoopLinkSessions.
     */
    data: WhoopLinkSessionCreateManyInput | WhoopLinkSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WhoopLinkSession createManyAndReturn
   */
  export type WhoopLinkSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopLinkSession
     */
    select?: WhoopLinkSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many WhoopLinkSessions.
     */
    data: WhoopLinkSessionCreateManyInput | WhoopLinkSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopLinkSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WhoopLinkSession update
   */
  export type WhoopLinkSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopLinkSession
     */
    select?: WhoopLinkSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopLinkSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a WhoopLinkSession.
     */
    data: XOR<WhoopLinkSessionUpdateInput, WhoopLinkSessionUncheckedUpdateInput>
    /**
     * Choose, which WhoopLinkSession to update.
     */
    where: WhoopLinkSessionWhereUniqueInput
  }

  /**
   * WhoopLinkSession updateMany
   */
  export type WhoopLinkSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WhoopLinkSessions.
     */
    data: XOR<WhoopLinkSessionUpdateManyMutationInput, WhoopLinkSessionUncheckedUpdateManyInput>
    /**
     * Filter which WhoopLinkSessions to update
     */
    where?: WhoopLinkSessionWhereInput
  }

  /**
   * WhoopLinkSession upsert
   */
  export type WhoopLinkSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopLinkSession
     */
    select?: WhoopLinkSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopLinkSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the WhoopLinkSession to update in case it exists.
     */
    where: WhoopLinkSessionWhereUniqueInput
    /**
     * In case the WhoopLinkSession found by the `where` argument doesn't exist, create a new WhoopLinkSession with this data.
     */
    create: XOR<WhoopLinkSessionCreateInput, WhoopLinkSessionUncheckedCreateInput>
    /**
     * In case the WhoopLinkSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WhoopLinkSessionUpdateInput, WhoopLinkSessionUncheckedUpdateInput>
  }

  /**
   * WhoopLinkSession delete
   */
  export type WhoopLinkSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopLinkSession
     */
    select?: WhoopLinkSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopLinkSessionInclude<ExtArgs> | null
    /**
     * Filter which WhoopLinkSession to delete.
     */
    where: WhoopLinkSessionWhereUniqueInput
  }

  /**
   * WhoopLinkSession deleteMany
   */
  export type WhoopLinkSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WhoopLinkSessions to delete
     */
    where?: WhoopLinkSessionWhereInput
  }

  /**
   * WhoopLinkSession without action
   */
  export type WhoopLinkSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WhoopLinkSession
     */
    select?: WhoopLinkSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WhoopLinkSessionInclude<ExtArgs> | null
  }


  /**
   * Model FeedPost
   */

  export type AggregateFeedPost = {
    _count: FeedPostCountAggregateOutputType | null
    _avg: FeedPostAvgAggregateOutputType | null
    _sum: FeedPostSumAggregateOutputType | null
    _min: FeedPostMinAggregateOutputType | null
    _max: FeedPostMaxAggregateOutputType | null
  }

  export type FeedPostAvgAggregateOutputType = {
    commentCount: number | null
  }

  export type FeedPostSumAggregateOutputType = {
    commentCount: number | null
  }

  export type FeedPostMinAggregateOutputType = {
    id: string | null
    authorId: string | null
    body: string | null
    visibility: $Enums.PostVisibility | null
    flagged: boolean | null
    commentCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedPostMaxAggregateOutputType = {
    id: string | null
    authorId: string | null
    body: string | null
    visibility: $Enums.PostVisibility | null
    flagged: boolean | null
    commentCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FeedPostCountAggregateOutputType = {
    id: number
    authorId: number
    body: number
    tags: number
    visibility: number
    flagged: number
    reactionSummary: number
    commentCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FeedPostAvgAggregateInputType = {
    commentCount?: true
  }

  export type FeedPostSumAggregateInputType = {
    commentCount?: true
  }

  export type FeedPostMinAggregateInputType = {
    id?: true
    authorId?: true
    body?: true
    visibility?: true
    flagged?: true
    commentCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedPostMaxAggregateInputType = {
    id?: true
    authorId?: true
    body?: true
    visibility?: true
    flagged?: true
    commentCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FeedPostCountAggregateInputType = {
    id?: true
    authorId?: true
    body?: true
    tags?: true
    visibility?: true
    flagged?: true
    reactionSummary?: true
    commentCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FeedPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedPost to aggregate.
     */
    where?: FeedPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedPosts to fetch.
     */
    orderBy?: FeedPostOrderByWithRelationInput | FeedPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeedPosts
    **/
    _count?: true | FeedPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedPostMaxAggregateInputType
  }

  export type GetFeedPostAggregateType<T extends FeedPostAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedPost[P]>
      : GetScalarType<T[P], AggregateFeedPost[P]>
  }




  export type FeedPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedPostWhereInput
    orderBy?: FeedPostOrderByWithAggregationInput | FeedPostOrderByWithAggregationInput[]
    by: FeedPostScalarFieldEnum[] | FeedPostScalarFieldEnum
    having?: FeedPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedPostCountAggregateInputType | true
    _avg?: FeedPostAvgAggregateInputType
    _sum?: FeedPostSumAggregateInputType
    _min?: FeedPostMinAggregateInputType
    _max?: FeedPostMaxAggregateInputType
  }

  export type FeedPostGroupByOutputType = {
    id: string
    authorId: string
    body: string
    tags: string[]
    visibility: $Enums.PostVisibility
    flagged: boolean
    reactionSummary: JsonValue | null
    commentCount: number
    createdAt: Date
    updatedAt: Date
    _count: FeedPostCountAggregateOutputType | null
    _avg: FeedPostAvgAggregateOutputType | null
    _sum: FeedPostSumAggregateOutputType | null
    _min: FeedPostMinAggregateOutputType | null
    _max: FeedPostMaxAggregateOutputType | null
  }

  type GetFeedPostGroupByPayload<T extends FeedPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedPostGroupByOutputType[P]>
            : GetScalarType<T[P], FeedPostGroupByOutputType[P]>
        }
      >
    >


  export type FeedPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    body?: boolean
    tags?: boolean
    visibility?: boolean
    flagged?: boolean
    reactionSummary?: boolean
    commentCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | FeedPost$commentsArgs<ExtArgs>
    reactions?: boolean | FeedPost$reactionsArgs<ExtArgs>
    flags?: boolean | FeedPost$flagsArgs<ExtArgs>
    engagementEvents?: boolean | FeedPost$engagementEventsArgs<ExtArgs>
    _count?: boolean | FeedPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedPost"]>

  export type FeedPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    authorId?: boolean
    body?: boolean
    tags?: boolean
    visibility?: boolean
    flagged?: boolean
    reactionSummary?: boolean
    commentCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedPost"]>

  export type FeedPostSelectScalar = {
    id?: boolean
    authorId?: boolean
    body?: boolean
    tags?: boolean
    visibility?: boolean
    flagged?: boolean
    reactionSummary?: boolean
    commentCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FeedPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | FeedPost$commentsArgs<ExtArgs>
    reactions?: boolean | FeedPost$reactionsArgs<ExtArgs>
    flags?: boolean | FeedPost$flagsArgs<ExtArgs>
    engagementEvents?: boolean | FeedPost$engagementEventsArgs<ExtArgs>
    _count?: boolean | FeedPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FeedPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FeedPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeedPost"
    objects: {
      author: Prisma.$UserPayload<ExtArgs>
      comments: Prisma.$CommentPayload<ExtArgs>[]
      reactions: Prisma.$ReactionPayload<ExtArgs>[]
      flags: Prisma.$FlagPayload<ExtArgs>[]
      engagementEvents: Prisma.$EngagementEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      authorId: string
      body: string
      tags: string[]
      visibility: $Enums.PostVisibility
      flagged: boolean
      reactionSummary: Prisma.JsonValue | null
      commentCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["feedPost"]>
    composites: {}
  }

  type FeedPostGetPayload<S extends boolean | null | undefined | FeedPostDefaultArgs> = $Result.GetResult<Prisma.$FeedPostPayload, S>

  type FeedPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeedPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeedPostCountAggregateInputType | true
    }

  export interface FeedPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeedPost'], meta: { name: 'FeedPost' } }
    /**
     * Find zero or one FeedPost that matches the filter.
     * @param {FeedPostFindUniqueArgs} args - Arguments to find a FeedPost
     * @example
     * // Get one FeedPost
     * const feedPost = await prisma.feedPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedPostFindUniqueArgs>(args: SelectSubset<T, FeedPostFindUniqueArgs<ExtArgs>>): Prisma__FeedPostClient<$Result.GetResult<Prisma.$FeedPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FeedPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeedPostFindUniqueOrThrowArgs} args - Arguments to find a FeedPost
     * @example
     * // Get one FeedPost
     * const feedPost = await prisma.feedPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedPostFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedPostClient<$Result.GetResult<Prisma.$FeedPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FeedPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedPostFindFirstArgs} args - Arguments to find a FeedPost
     * @example
     * // Get one FeedPost
     * const feedPost = await prisma.feedPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedPostFindFirstArgs>(args?: SelectSubset<T, FeedPostFindFirstArgs<ExtArgs>>): Prisma__FeedPostClient<$Result.GetResult<Prisma.$FeedPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FeedPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedPostFindFirstOrThrowArgs} args - Arguments to find a FeedPost
     * @example
     * // Get one FeedPost
     * const feedPost = await prisma.feedPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedPostFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedPostClient<$Result.GetResult<Prisma.$FeedPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FeedPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedPosts
     * const feedPosts = await prisma.feedPost.findMany()
     * 
     * // Get first 10 FeedPosts
     * const feedPosts = await prisma.feedPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const feedPostWithIdOnly = await prisma.feedPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FeedPostFindManyArgs>(args?: SelectSubset<T, FeedPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FeedPost.
     * @param {FeedPostCreateArgs} args - Arguments to create a FeedPost.
     * @example
     * // Create one FeedPost
     * const FeedPost = await prisma.feedPost.create({
     *   data: {
     *     // ... data to create a FeedPost
     *   }
     * })
     * 
     */
    create<T extends FeedPostCreateArgs>(args: SelectSubset<T, FeedPostCreateArgs<ExtArgs>>): Prisma__FeedPostClient<$Result.GetResult<Prisma.$FeedPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FeedPosts.
     * @param {FeedPostCreateManyArgs} args - Arguments to create many FeedPosts.
     * @example
     * // Create many FeedPosts
     * const feedPost = await prisma.feedPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedPostCreateManyArgs>(args?: SelectSubset<T, FeedPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FeedPosts and returns the data saved in the database.
     * @param {FeedPostCreateManyAndReturnArgs} args - Arguments to create many FeedPosts.
     * @example
     * // Create many FeedPosts
     * const feedPost = await prisma.feedPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FeedPosts and only return the `id`
     * const feedPostWithIdOnly = await prisma.feedPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FeedPostCreateManyAndReturnArgs>(args?: SelectSubset<T, FeedPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FeedPost.
     * @param {FeedPostDeleteArgs} args - Arguments to delete one FeedPost.
     * @example
     * // Delete one FeedPost
     * const FeedPost = await prisma.feedPost.delete({
     *   where: {
     *     // ... filter to delete one FeedPost
     *   }
     * })
     * 
     */
    delete<T extends FeedPostDeleteArgs>(args: SelectSubset<T, FeedPostDeleteArgs<ExtArgs>>): Prisma__FeedPostClient<$Result.GetResult<Prisma.$FeedPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FeedPost.
     * @param {FeedPostUpdateArgs} args - Arguments to update one FeedPost.
     * @example
     * // Update one FeedPost
     * const feedPost = await prisma.feedPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedPostUpdateArgs>(args: SelectSubset<T, FeedPostUpdateArgs<ExtArgs>>): Prisma__FeedPostClient<$Result.GetResult<Prisma.$FeedPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FeedPosts.
     * @param {FeedPostDeleteManyArgs} args - Arguments to filter FeedPosts to delete.
     * @example
     * // Delete a few FeedPosts
     * const { count } = await prisma.feedPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedPostDeleteManyArgs>(args?: SelectSubset<T, FeedPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedPosts
     * const feedPost = await prisma.feedPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedPostUpdateManyArgs>(args: SelectSubset<T, FeedPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeedPost.
     * @param {FeedPostUpsertArgs} args - Arguments to update or create a FeedPost.
     * @example
     * // Update or create a FeedPost
     * const feedPost = await prisma.feedPost.upsert({
     *   create: {
     *     // ... data to create a FeedPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedPost we want to update
     *   }
     * })
     */
    upsert<T extends FeedPostUpsertArgs>(args: SelectSubset<T, FeedPostUpsertArgs<ExtArgs>>): Prisma__FeedPostClient<$Result.GetResult<Prisma.$FeedPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FeedPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedPostCountArgs} args - Arguments to filter FeedPosts to count.
     * @example
     * // Count the number of FeedPosts
     * const count = await prisma.feedPost.count({
     *   where: {
     *     // ... the filter for the FeedPosts we want to count
     *   }
     * })
    **/
    count<T extends FeedPostCountArgs>(
      args?: Subset<T, FeedPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedPostAggregateArgs>(args: Subset<T, FeedPostAggregateArgs>): Prisma.PrismaPromise<GetFeedPostAggregateType<T>>

    /**
     * Group by FeedPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedPostGroupByArgs['orderBy'] }
        : { orderBy?: FeedPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeedPost model
   */
  readonly fields: FeedPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeedPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comments<T extends FeedPost$commentsArgs<ExtArgs> = {}>(args?: Subset<T, FeedPost$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany"> | Null>
    reactions<T extends FeedPost$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, FeedPost$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany"> | Null>
    flags<T extends FeedPost$flagsArgs<ExtArgs> = {}>(args?: Subset<T, FeedPost$flagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "findMany"> | Null>
    engagementEvents<T extends FeedPost$engagementEventsArgs<ExtArgs> = {}>(args?: Subset<T, FeedPost$engagementEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EngagementEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeedPost model
   */ 
  interface FeedPostFieldRefs {
    readonly id: FieldRef<"FeedPost", 'String'>
    readonly authorId: FieldRef<"FeedPost", 'String'>
    readonly body: FieldRef<"FeedPost", 'String'>
    readonly tags: FieldRef<"FeedPost", 'String[]'>
    readonly visibility: FieldRef<"FeedPost", 'PostVisibility'>
    readonly flagged: FieldRef<"FeedPost", 'Boolean'>
    readonly reactionSummary: FieldRef<"FeedPost", 'Json'>
    readonly commentCount: FieldRef<"FeedPost", 'Int'>
    readonly createdAt: FieldRef<"FeedPost", 'DateTime'>
    readonly updatedAt: FieldRef<"FeedPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeedPost findUnique
   */
  export type FeedPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPost
     */
    select?: FeedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPostInclude<ExtArgs> | null
    /**
     * Filter, which FeedPost to fetch.
     */
    where: FeedPostWhereUniqueInput
  }

  /**
   * FeedPost findUniqueOrThrow
   */
  export type FeedPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPost
     */
    select?: FeedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPostInclude<ExtArgs> | null
    /**
     * Filter, which FeedPost to fetch.
     */
    where: FeedPostWhereUniqueInput
  }

  /**
   * FeedPost findFirst
   */
  export type FeedPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPost
     */
    select?: FeedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPostInclude<ExtArgs> | null
    /**
     * Filter, which FeedPost to fetch.
     */
    where?: FeedPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedPosts to fetch.
     */
    orderBy?: FeedPostOrderByWithRelationInput | FeedPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedPosts.
     */
    cursor?: FeedPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedPosts.
     */
    distinct?: FeedPostScalarFieldEnum | FeedPostScalarFieldEnum[]
  }

  /**
   * FeedPost findFirstOrThrow
   */
  export type FeedPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPost
     */
    select?: FeedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPostInclude<ExtArgs> | null
    /**
     * Filter, which FeedPost to fetch.
     */
    where?: FeedPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedPosts to fetch.
     */
    orderBy?: FeedPostOrderByWithRelationInput | FeedPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedPosts.
     */
    cursor?: FeedPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedPosts.
     */
    distinct?: FeedPostScalarFieldEnum | FeedPostScalarFieldEnum[]
  }

  /**
   * FeedPost findMany
   */
  export type FeedPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPost
     */
    select?: FeedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPostInclude<ExtArgs> | null
    /**
     * Filter, which FeedPosts to fetch.
     */
    where?: FeedPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedPosts to fetch.
     */
    orderBy?: FeedPostOrderByWithRelationInput | FeedPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeedPosts.
     */
    cursor?: FeedPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedPosts.
     */
    skip?: number
    distinct?: FeedPostScalarFieldEnum | FeedPostScalarFieldEnum[]
  }

  /**
   * FeedPost create
   */
  export type FeedPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPost
     */
    select?: FeedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPostInclude<ExtArgs> | null
    /**
     * The data needed to create a FeedPost.
     */
    data: XOR<FeedPostCreateInput, FeedPostUncheckedCreateInput>
  }

  /**
   * FeedPost createMany
   */
  export type FeedPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeedPosts.
     */
    data: FeedPostCreateManyInput | FeedPostCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeedPost createManyAndReturn
   */
  export type FeedPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPost
     */
    select?: FeedPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FeedPosts.
     */
    data: FeedPostCreateManyInput | FeedPostCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FeedPost update
   */
  export type FeedPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPost
     */
    select?: FeedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPostInclude<ExtArgs> | null
    /**
     * The data needed to update a FeedPost.
     */
    data: XOR<FeedPostUpdateInput, FeedPostUncheckedUpdateInput>
    /**
     * Choose, which FeedPost to update.
     */
    where: FeedPostWhereUniqueInput
  }

  /**
   * FeedPost updateMany
   */
  export type FeedPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeedPosts.
     */
    data: XOR<FeedPostUpdateManyMutationInput, FeedPostUncheckedUpdateManyInput>
    /**
     * Filter which FeedPosts to update
     */
    where?: FeedPostWhereInput
  }

  /**
   * FeedPost upsert
   */
  export type FeedPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPost
     */
    select?: FeedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPostInclude<ExtArgs> | null
    /**
     * The filter to search for the FeedPost to update in case it exists.
     */
    where: FeedPostWhereUniqueInput
    /**
     * In case the FeedPost found by the `where` argument doesn't exist, create a new FeedPost with this data.
     */
    create: XOR<FeedPostCreateInput, FeedPostUncheckedCreateInput>
    /**
     * In case the FeedPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedPostUpdateInput, FeedPostUncheckedUpdateInput>
  }

  /**
   * FeedPost delete
   */
  export type FeedPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPost
     */
    select?: FeedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPostInclude<ExtArgs> | null
    /**
     * Filter which FeedPost to delete.
     */
    where: FeedPostWhereUniqueInput
  }

  /**
   * FeedPost deleteMany
   */
  export type FeedPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedPosts to delete
     */
    where?: FeedPostWhereInput
  }

  /**
   * FeedPost.comments
   */
  export type FeedPost$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    cursor?: CommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * FeedPost.reactions
   */
  export type FeedPost$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    cursor?: ReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * FeedPost.flags
   */
  export type FeedPost$flagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    where?: FlagWhereInput
    orderBy?: FlagOrderByWithRelationInput | FlagOrderByWithRelationInput[]
    cursor?: FlagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlagScalarFieldEnum | FlagScalarFieldEnum[]
  }

  /**
   * FeedPost.engagementEvents
   */
  export type FeedPost$engagementEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementEvent
     */
    select?: EngagementEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementEventInclude<ExtArgs> | null
    where?: EngagementEventWhereInput
    orderBy?: EngagementEventOrderByWithRelationInput | EngagementEventOrderByWithRelationInput[]
    cursor?: EngagementEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EngagementEventScalarFieldEnum | EngagementEventScalarFieldEnum[]
  }

  /**
   * FeedPost without action
   */
  export type FeedPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPost
     */
    select?: FeedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPostInclude<ExtArgs> | null
  }


  /**
   * Model Comment
   */

  export type AggregateComment = {
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  export type CommentMinAggregateOutputType = {
    id: string | null
    postId: string | null
    authorId: string | null
    body: string | null
    flagged: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentMaxAggregateOutputType = {
    id: string | null
    postId: string | null
    authorId: string | null
    body: string | null
    flagged: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CommentCountAggregateOutputType = {
    id: number
    postId: number
    authorId: number
    body: number
    flagged: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CommentMinAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    body?: true
    flagged?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentMaxAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    body?: true
    flagged?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CommentCountAggregateInputType = {
    id?: true
    postId?: true
    authorId?: true
    body?: true
    flagged?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comment to aggregate.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Comments
    **/
    _count?: true | CommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentMaxAggregateInputType
  }

  export type GetCommentAggregateType<T extends CommentAggregateArgs> = {
        [P in keyof T & keyof AggregateComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComment[P]>
      : GetScalarType<T[P], AggregateComment[P]>
  }




  export type CommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentWhereInput
    orderBy?: CommentOrderByWithAggregationInput | CommentOrderByWithAggregationInput[]
    by: CommentScalarFieldEnum[] | CommentScalarFieldEnum
    having?: CommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentCountAggregateInputType | true
    _min?: CommentMinAggregateInputType
    _max?: CommentMaxAggregateInputType
  }

  export type CommentGroupByOutputType = {
    id: string
    postId: string
    authorId: string
    body: string
    flagged: boolean
    createdAt: Date
    updatedAt: Date
    _count: CommentCountAggregateOutputType | null
    _min: CommentMinAggregateOutputType | null
    _max: CommentMaxAggregateOutputType | null
  }

  type GetCommentGroupByPayload<T extends CommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentGroupByOutputType[P]>
            : GetScalarType<T[P], CommentGroupByOutputType[P]>
        }
      >
    >


  export type CommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    authorId?: boolean
    body?: boolean
    flagged?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | FeedPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    reactions?: boolean | Comment$reactionsArgs<ExtArgs>
    flags?: boolean | Comment$flagsArgs<ExtArgs>
    engagementEvents?: boolean | Comment$engagementEventsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    authorId?: boolean
    body?: boolean
    flagged?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | FeedPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["comment"]>

  export type CommentSelectScalar = {
    id?: boolean
    postId?: boolean
    authorId?: boolean
    body?: boolean
    flagged?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | FeedPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    reactions?: boolean | Comment$reactionsArgs<ExtArgs>
    flags?: boolean | Comment$flagsArgs<ExtArgs>
    engagementEvents?: boolean | Comment$engagementEventsArgs<ExtArgs>
    _count?: boolean | CommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | FeedPostDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Comment"
    objects: {
      post: Prisma.$FeedPostPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
      reactions: Prisma.$ReactionPayload<ExtArgs>[]
      flags: Prisma.$FlagPayload<ExtArgs>[]
      engagementEvents: Prisma.$EngagementEventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      postId: string
      authorId: string
      body: string
      flagged: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["comment"]>
    composites: {}
  }

  type CommentGetPayload<S extends boolean | null | undefined | CommentDefaultArgs> = $Result.GetResult<Prisma.$CommentPayload, S>

  type CommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentCountAggregateInputType | true
    }

  export interface CommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Comment'], meta: { name: 'Comment' } }
    /**
     * Find zero or one Comment that matches the filter.
     * @param {CommentFindUniqueArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentFindUniqueArgs>(args: SelectSubset<T, CommentFindUniqueArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Comment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentFindUniqueOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Comment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentFindFirstArgs>(args?: SelectSubset<T, CommentFindFirstArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Comment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindFirstOrThrowArgs} args - Arguments to find a Comment
     * @example
     * // Get one Comment
     * const comment = await prisma.comment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Comments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Comments
     * const comments = await prisma.comment.findMany()
     * 
     * // Get first 10 Comments
     * const comments = await prisma.comment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentWithIdOnly = await prisma.comment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentFindManyArgs>(args?: SelectSubset<T, CommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Comment.
     * @param {CommentCreateArgs} args - Arguments to create a Comment.
     * @example
     * // Create one Comment
     * const Comment = await prisma.comment.create({
     *   data: {
     *     // ... data to create a Comment
     *   }
     * })
     * 
     */
    create<T extends CommentCreateArgs>(args: SelectSubset<T, CommentCreateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Comments.
     * @param {CommentCreateManyArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentCreateManyArgs>(args?: SelectSubset<T, CommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Comments and returns the data saved in the database.
     * @param {CommentCreateManyAndReturnArgs} args - Arguments to create many Comments.
     * @example
     * // Create many Comments
     * const comment = await prisma.comment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Comments and only return the `id`
     * const commentWithIdOnly = await prisma.comment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Comment.
     * @param {CommentDeleteArgs} args - Arguments to delete one Comment.
     * @example
     * // Delete one Comment
     * const Comment = await prisma.comment.delete({
     *   where: {
     *     // ... filter to delete one Comment
     *   }
     * })
     * 
     */
    delete<T extends CommentDeleteArgs>(args: SelectSubset<T, CommentDeleteArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Comment.
     * @param {CommentUpdateArgs} args - Arguments to update one Comment.
     * @example
     * // Update one Comment
     * const comment = await prisma.comment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpdateArgs>(args: SelectSubset<T, CommentUpdateArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Comments.
     * @param {CommentDeleteManyArgs} args - Arguments to filter Comments to delete.
     * @example
     * // Delete a few Comments
     * const { count } = await prisma.comment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentDeleteManyArgs>(args?: SelectSubset<T, CommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Comments
     * const comment = await prisma.comment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpdateManyArgs>(args: SelectSubset<T, CommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Comment.
     * @param {CommentUpsertArgs} args - Arguments to update or create a Comment.
     * @example
     * // Update or create a Comment
     * const comment = await prisma.comment.upsert({
     *   create: {
     *     // ... data to create a Comment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Comment we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpsertArgs>(args: SelectSubset<T, CommentUpsertArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Comments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentCountArgs} args - Arguments to filter Comments to count.
     * @example
     * // Count the number of Comments
     * const count = await prisma.comment.count({
     *   where: {
     *     // ... the filter for the Comments we want to count
     *   }
     * })
    **/
    count<T extends CommentCountArgs>(
      args?: Subset<T, CommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentAggregateArgs>(args: Subset<T, CommentAggregateArgs>): Prisma.PrismaPromise<GetCommentAggregateType<T>>

    /**
     * Group by Comment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentGroupByArgs['orderBy'] }
        : { orderBy?: CommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Comment model
   */
  readonly fields: CommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Comment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends FeedPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FeedPostDefaultArgs<ExtArgs>>): Prisma__FeedPostClient<$Result.GetResult<Prisma.$FeedPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    reactions<T extends Comment$reactionsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$reactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany"> | Null>
    flags<T extends Comment$flagsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$flagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "findMany"> | Null>
    engagementEvents<T extends Comment$engagementEventsArgs<ExtArgs> = {}>(args?: Subset<T, Comment$engagementEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EngagementEventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Comment model
   */ 
  interface CommentFieldRefs {
    readonly id: FieldRef<"Comment", 'String'>
    readonly postId: FieldRef<"Comment", 'String'>
    readonly authorId: FieldRef<"Comment", 'String'>
    readonly body: FieldRef<"Comment", 'String'>
    readonly flagged: FieldRef<"Comment", 'Boolean'>
    readonly createdAt: FieldRef<"Comment", 'DateTime'>
    readonly updatedAt: FieldRef<"Comment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Comment findUnique
   */
  export type CommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findUniqueOrThrow
   */
  export type CommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment findFirst
   */
  export type CommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findFirstOrThrow
   */
  export type CommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comment to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Comments.
     */
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment findMany
   */
  export type CommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter, which Comments to fetch.
     */
    where?: CommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Comments to fetch.
     */
    orderBy?: CommentOrderByWithRelationInput | CommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Comments.
     */
    cursor?: CommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Comments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Comments.
     */
    skip?: number
    distinct?: CommentScalarFieldEnum | CommentScalarFieldEnum[]
  }

  /**
   * Comment create
   */
  export type CommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to create a Comment.
     */
    data: XOR<CommentCreateInput, CommentUncheckedCreateInput>
  }

  /**
   * Comment createMany
   */
  export type CommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Comment createManyAndReturn
   */
  export type CommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Comments.
     */
    data: CommentCreateManyInput | CommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Comment update
   */
  export type CommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The data needed to update a Comment.
     */
    data: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
    /**
     * Choose, which Comment to update.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment updateMany
   */
  export type CommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Comments.
     */
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyInput>
    /**
     * Filter which Comments to update
     */
    where?: CommentWhereInput
  }

  /**
   * Comment upsert
   */
  export type CommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * The filter to search for the Comment to update in case it exists.
     */
    where: CommentWhereUniqueInput
    /**
     * In case the Comment found by the `where` argument doesn't exist, create a new Comment with this data.
     */
    create: XOR<CommentCreateInput, CommentUncheckedCreateInput>
    /**
     * In case the Comment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpdateInput, CommentUncheckedUpdateInput>
  }

  /**
   * Comment delete
   */
  export type CommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    /**
     * Filter which Comment to delete.
     */
    where: CommentWhereUniqueInput
  }

  /**
   * Comment deleteMany
   */
  export type CommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Comments to delete
     */
    where?: CommentWhereInput
  }

  /**
   * Comment.reactions
   */
  export type Comment$reactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    cursor?: ReactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Comment.flags
   */
  export type Comment$flagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    where?: FlagWhereInput
    orderBy?: FlagOrderByWithRelationInput | FlagOrderByWithRelationInput[]
    cursor?: FlagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FlagScalarFieldEnum | FlagScalarFieldEnum[]
  }

  /**
   * Comment.engagementEvents
   */
  export type Comment$engagementEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementEvent
     */
    select?: EngagementEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementEventInclude<ExtArgs> | null
    where?: EngagementEventWhereInput
    orderBy?: EngagementEventOrderByWithRelationInput | EngagementEventOrderByWithRelationInput[]
    cursor?: EngagementEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EngagementEventScalarFieldEnum | EngagementEventScalarFieldEnum[]
  }

  /**
   * Comment without action
   */
  export type CommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
  }


  /**
   * Model Reaction
   */

  export type AggregateReaction = {
    _count: ReactionCountAggregateOutputType | null
    _min: ReactionMinAggregateOutputType | null
    _max: ReactionMaxAggregateOutputType | null
  }

  export type ReactionMinAggregateOutputType = {
    id: string | null
    type: $Enums.ReactionType | null
    postId: string | null
    commentId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type ReactionMaxAggregateOutputType = {
    id: string | null
    type: $Enums.ReactionType | null
    postId: string | null
    commentId: string | null
    userId: string | null
    createdAt: Date | null
  }

  export type ReactionCountAggregateOutputType = {
    id: number
    type: number
    postId: number
    commentId: number
    userId: number
    createdAt: number
    _all: number
  }


  export type ReactionMinAggregateInputType = {
    id?: true
    type?: true
    postId?: true
    commentId?: true
    userId?: true
    createdAt?: true
  }

  export type ReactionMaxAggregateInputType = {
    id?: true
    type?: true
    postId?: true
    commentId?: true
    userId?: true
    createdAt?: true
  }

  export type ReactionCountAggregateInputType = {
    id?: true
    type?: true
    postId?: true
    commentId?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type ReactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reaction to aggregate.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reactions
    **/
    _count?: true | ReactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReactionMaxAggregateInputType
  }

  export type GetReactionAggregateType<T extends ReactionAggregateArgs> = {
        [P in keyof T & keyof AggregateReaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReaction[P]>
      : GetScalarType<T[P], AggregateReaction[P]>
  }




  export type ReactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReactionWhereInput
    orderBy?: ReactionOrderByWithAggregationInput | ReactionOrderByWithAggregationInput[]
    by: ReactionScalarFieldEnum[] | ReactionScalarFieldEnum
    having?: ReactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReactionCountAggregateInputType | true
    _min?: ReactionMinAggregateInputType
    _max?: ReactionMaxAggregateInputType
  }

  export type ReactionGroupByOutputType = {
    id: string
    type: $Enums.ReactionType
    postId: string | null
    commentId: string | null
    userId: string
    createdAt: Date
    _count: ReactionCountAggregateOutputType | null
    _min: ReactionMinAggregateOutputType | null
    _max: ReactionMaxAggregateOutputType | null
  }

  type GetReactionGroupByPayload<T extends ReactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReactionGroupByOutputType[P]>
            : GetScalarType<T[P], ReactionGroupByOutputType[P]>
        }
      >
    >


  export type ReactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    postId?: boolean
    commentId?: boolean
    userId?: boolean
    createdAt?: boolean
    post?: boolean | Reaction$postArgs<ExtArgs>
    comment?: boolean | Reaction$commentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reaction"]>

  export type ReactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    postId?: boolean
    commentId?: boolean
    userId?: boolean
    createdAt?: boolean
    post?: boolean | Reaction$postArgs<ExtArgs>
    comment?: boolean | Reaction$commentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reaction"]>

  export type ReactionSelectScalar = {
    id?: boolean
    type?: boolean
    postId?: boolean
    commentId?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type ReactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | Reaction$postArgs<ExtArgs>
    comment?: boolean | Reaction$commentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | Reaction$postArgs<ExtArgs>
    comment?: boolean | Reaction$commentArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reaction"
    objects: {
      post: Prisma.$FeedPostPayload<ExtArgs> | null
      comment: Prisma.$CommentPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.ReactionType
      postId: string | null
      commentId: string | null
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["reaction"]>
    composites: {}
  }

  type ReactionGetPayload<S extends boolean | null | undefined | ReactionDefaultArgs> = $Result.GetResult<Prisma.$ReactionPayload, S>

  type ReactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReactionCountAggregateInputType | true
    }

  export interface ReactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reaction'], meta: { name: 'Reaction' } }
    /**
     * Find zero or one Reaction that matches the filter.
     * @param {ReactionFindUniqueArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReactionFindUniqueArgs>(args: SelectSubset<T, ReactionFindUniqueArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReactionFindUniqueOrThrowArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReactionFindUniqueOrThrowArgs>(args: SelectSubset<T, ReactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindFirstArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReactionFindFirstArgs>(args?: SelectSubset<T, ReactionFindFirstArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindFirstOrThrowArgs} args - Arguments to find a Reaction
     * @example
     * // Get one Reaction
     * const reaction = await prisma.reaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReactionFindFirstOrThrowArgs>(args?: SelectSubset<T, ReactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reactions
     * const reactions = await prisma.reaction.findMany()
     * 
     * // Get first 10 Reactions
     * const reactions = await prisma.reaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reactionWithIdOnly = await prisma.reaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReactionFindManyArgs>(args?: SelectSubset<T, ReactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reaction.
     * @param {ReactionCreateArgs} args - Arguments to create a Reaction.
     * @example
     * // Create one Reaction
     * const Reaction = await prisma.reaction.create({
     *   data: {
     *     // ... data to create a Reaction
     *   }
     * })
     * 
     */
    create<T extends ReactionCreateArgs>(args: SelectSubset<T, ReactionCreateArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reactions.
     * @param {ReactionCreateManyArgs} args - Arguments to create many Reactions.
     * @example
     * // Create many Reactions
     * const reaction = await prisma.reaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReactionCreateManyArgs>(args?: SelectSubset<T, ReactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reactions and returns the data saved in the database.
     * @param {ReactionCreateManyAndReturnArgs} args - Arguments to create many Reactions.
     * @example
     * // Create many Reactions
     * const reaction = await prisma.reaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reactions and only return the `id`
     * const reactionWithIdOnly = await prisma.reaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReactionCreateManyAndReturnArgs>(args?: SelectSubset<T, ReactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Reaction.
     * @param {ReactionDeleteArgs} args - Arguments to delete one Reaction.
     * @example
     * // Delete one Reaction
     * const Reaction = await prisma.reaction.delete({
     *   where: {
     *     // ... filter to delete one Reaction
     *   }
     * })
     * 
     */
    delete<T extends ReactionDeleteArgs>(args: SelectSubset<T, ReactionDeleteArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reaction.
     * @param {ReactionUpdateArgs} args - Arguments to update one Reaction.
     * @example
     * // Update one Reaction
     * const reaction = await prisma.reaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReactionUpdateArgs>(args: SelectSubset<T, ReactionUpdateArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reactions.
     * @param {ReactionDeleteManyArgs} args - Arguments to filter Reactions to delete.
     * @example
     * // Delete a few Reactions
     * const { count } = await prisma.reaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReactionDeleteManyArgs>(args?: SelectSubset<T, ReactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reactions
     * const reaction = await prisma.reaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReactionUpdateManyArgs>(args: SelectSubset<T, ReactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reaction.
     * @param {ReactionUpsertArgs} args - Arguments to update or create a Reaction.
     * @example
     * // Update or create a Reaction
     * const reaction = await prisma.reaction.upsert({
     *   create: {
     *     // ... data to create a Reaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reaction we want to update
     *   }
     * })
     */
    upsert<T extends ReactionUpsertArgs>(args: SelectSubset<T, ReactionUpsertArgs<ExtArgs>>): Prisma__ReactionClient<$Result.GetResult<Prisma.$ReactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionCountArgs} args - Arguments to filter Reactions to count.
     * @example
     * // Count the number of Reactions
     * const count = await prisma.reaction.count({
     *   where: {
     *     // ... the filter for the Reactions we want to count
     *   }
     * })
    **/
    count<T extends ReactionCountArgs>(
      args?: Subset<T, ReactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReactionAggregateArgs>(args: Subset<T, ReactionAggregateArgs>): Prisma.PrismaPromise<GetReactionAggregateType<T>>

    /**
     * Group by Reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReactionGroupByArgs['orderBy'] }
        : { orderBy?: ReactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reaction model
   */
  readonly fields: ReactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends Reaction$postArgs<ExtArgs> = {}>(args?: Subset<T, Reaction$postArgs<ExtArgs>>): Prisma__FeedPostClient<$Result.GetResult<Prisma.$FeedPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comment<T extends Reaction$commentArgs<ExtArgs> = {}>(args?: Subset<T, Reaction$commentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reaction model
   */ 
  interface ReactionFieldRefs {
    readonly id: FieldRef<"Reaction", 'String'>
    readonly type: FieldRef<"Reaction", 'ReactionType'>
    readonly postId: FieldRef<"Reaction", 'String'>
    readonly commentId: FieldRef<"Reaction", 'String'>
    readonly userId: FieldRef<"Reaction", 'String'>
    readonly createdAt: FieldRef<"Reaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reaction findUnique
   */
  export type ReactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction findUniqueOrThrow
   */
  export type ReactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction findFirst
   */
  export type ReactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reactions.
     */
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction findFirstOrThrow
   */
  export type ReactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reaction to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reactions.
     */
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction findMany
   */
  export type ReactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter, which Reactions to fetch.
     */
    where?: ReactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reactions to fetch.
     */
    orderBy?: ReactionOrderByWithRelationInput | ReactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reactions.
     */
    cursor?: ReactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reactions.
     */
    skip?: number
    distinct?: ReactionScalarFieldEnum | ReactionScalarFieldEnum[]
  }

  /**
   * Reaction create
   */
  export type ReactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Reaction.
     */
    data: XOR<ReactionCreateInput, ReactionUncheckedCreateInput>
  }

  /**
   * Reaction createMany
   */
  export type ReactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reactions.
     */
    data: ReactionCreateManyInput | ReactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reaction createManyAndReturn
   */
  export type ReactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reactions.
     */
    data: ReactionCreateManyInput | ReactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reaction update
   */
  export type ReactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Reaction.
     */
    data: XOR<ReactionUpdateInput, ReactionUncheckedUpdateInput>
    /**
     * Choose, which Reaction to update.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction updateMany
   */
  export type ReactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reactions.
     */
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyInput>
    /**
     * Filter which Reactions to update
     */
    where?: ReactionWhereInput
  }

  /**
   * Reaction upsert
   */
  export type ReactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Reaction to update in case it exists.
     */
    where: ReactionWhereUniqueInput
    /**
     * In case the Reaction found by the `where` argument doesn't exist, create a new Reaction with this data.
     */
    create: XOR<ReactionCreateInput, ReactionUncheckedCreateInput>
    /**
     * In case the Reaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReactionUpdateInput, ReactionUncheckedUpdateInput>
  }

  /**
   * Reaction delete
   */
  export type ReactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
    /**
     * Filter which Reaction to delete.
     */
    where: ReactionWhereUniqueInput
  }

  /**
   * Reaction deleteMany
   */
  export type ReactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reactions to delete
     */
    where?: ReactionWhereInput
  }

  /**
   * Reaction.post
   */
  export type Reaction$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPost
     */
    select?: FeedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPostInclude<ExtArgs> | null
    where?: FeedPostWhereInput
  }

  /**
   * Reaction.comment
   */
  export type Reaction$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Reaction without action
   */
  export type ReactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reaction
     */
    select?: ReactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReactionInclude<ExtArgs> | null
  }


  /**
   * Model EngagementEvent
   */

  export type AggregateEngagementEvent = {
    _count: EngagementEventCountAggregateOutputType | null
    _min: EngagementEventMinAggregateOutputType | null
    _max: EngagementEventMaxAggregateOutputType | null
  }

  export type EngagementEventMinAggregateOutputType = {
    id: string | null
    type: $Enums.EngagementEventType | null
    userId: string | null
    postId: string | null
    commentId: string | null
    reactionType: $Enums.ReactionType | null
    occurredAt: Date | null
  }

  export type EngagementEventMaxAggregateOutputType = {
    id: string | null
    type: $Enums.EngagementEventType | null
    userId: string | null
    postId: string | null
    commentId: string | null
    reactionType: $Enums.ReactionType | null
    occurredAt: Date | null
  }

  export type EngagementEventCountAggregateOutputType = {
    id: number
    type: number
    userId: number
    postId: number
    commentId: number
    reactionType: number
    occurredAt: number
    metadata: number
    _all: number
  }


  export type EngagementEventMinAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    postId?: true
    commentId?: true
    reactionType?: true
    occurredAt?: true
  }

  export type EngagementEventMaxAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    postId?: true
    commentId?: true
    reactionType?: true
    occurredAt?: true
  }

  export type EngagementEventCountAggregateInputType = {
    id?: true
    type?: true
    userId?: true
    postId?: true
    commentId?: true
    reactionType?: true
    occurredAt?: true
    metadata?: true
    _all?: true
  }

  export type EngagementEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EngagementEvent to aggregate.
     */
    where?: EngagementEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EngagementEvents to fetch.
     */
    orderBy?: EngagementEventOrderByWithRelationInput | EngagementEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EngagementEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EngagementEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EngagementEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EngagementEvents
    **/
    _count?: true | EngagementEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EngagementEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EngagementEventMaxAggregateInputType
  }

  export type GetEngagementEventAggregateType<T extends EngagementEventAggregateArgs> = {
        [P in keyof T & keyof AggregateEngagementEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEngagementEvent[P]>
      : GetScalarType<T[P], AggregateEngagementEvent[P]>
  }




  export type EngagementEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EngagementEventWhereInput
    orderBy?: EngagementEventOrderByWithAggregationInput | EngagementEventOrderByWithAggregationInput[]
    by: EngagementEventScalarFieldEnum[] | EngagementEventScalarFieldEnum
    having?: EngagementEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EngagementEventCountAggregateInputType | true
    _min?: EngagementEventMinAggregateInputType
    _max?: EngagementEventMaxAggregateInputType
  }

  export type EngagementEventGroupByOutputType = {
    id: string
    type: $Enums.EngagementEventType
    userId: string
    postId: string | null
    commentId: string | null
    reactionType: $Enums.ReactionType | null
    occurredAt: Date
    metadata: JsonValue | null
    _count: EngagementEventCountAggregateOutputType | null
    _min: EngagementEventMinAggregateOutputType | null
    _max: EngagementEventMaxAggregateOutputType | null
  }

  type GetEngagementEventGroupByPayload<T extends EngagementEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EngagementEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EngagementEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EngagementEventGroupByOutputType[P]>
            : GetScalarType<T[P], EngagementEventGroupByOutputType[P]>
        }
      >
    >


  export type EngagementEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    userId?: boolean
    postId?: boolean
    commentId?: boolean
    reactionType?: boolean
    occurredAt?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    post?: boolean | EngagementEvent$postArgs<ExtArgs>
    comment?: boolean | EngagementEvent$commentArgs<ExtArgs>
  }, ExtArgs["result"]["engagementEvent"]>

  export type EngagementEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    userId?: boolean
    postId?: boolean
    commentId?: boolean
    reactionType?: boolean
    occurredAt?: boolean
    metadata?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    post?: boolean | EngagementEvent$postArgs<ExtArgs>
    comment?: boolean | EngagementEvent$commentArgs<ExtArgs>
  }, ExtArgs["result"]["engagementEvent"]>

  export type EngagementEventSelectScalar = {
    id?: boolean
    type?: boolean
    userId?: boolean
    postId?: boolean
    commentId?: boolean
    reactionType?: boolean
    occurredAt?: boolean
    metadata?: boolean
  }

  export type EngagementEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    post?: boolean | EngagementEvent$postArgs<ExtArgs>
    comment?: boolean | EngagementEvent$commentArgs<ExtArgs>
  }
  export type EngagementEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    post?: boolean | EngagementEvent$postArgs<ExtArgs>
    comment?: boolean | EngagementEvent$commentArgs<ExtArgs>
  }

  export type $EngagementEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EngagementEvent"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      post: Prisma.$FeedPostPayload<ExtArgs> | null
      comment: Prisma.$CommentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.EngagementEventType
      userId: string
      postId: string | null
      commentId: string | null
      reactionType: $Enums.ReactionType | null
      occurredAt: Date
      metadata: Prisma.JsonValue | null
    }, ExtArgs["result"]["engagementEvent"]>
    composites: {}
  }

  type EngagementEventGetPayload<S extends boolean | null | undefined | EngagementEventDefaultArgs> = $Result.GetResult<Prisma.$EngagementEventPayload, S>

  type EngagementEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EngagementEventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EngagementEventCountAggregateInputType | true
    }

  export interface EngagementEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EngagementEvent'], meta: { name: 'EngagementEvent' } }
    /**
     * Find zero or one EngagementEvent that matches the filter.
     * @param {EngagementEventFindUniqueArgs} args - Arguments to find a EngagementEvent
     * @example
     * // Get one EngagementEvent
     * const engagementEvent = await prisma.engagementEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EngagementEventFindUniqueArgs>(args: SelectSubset<T, EngagementEventFindUniqueArgs<ExtArgs>>): Prisma__EngagementEventClient<$Result.GetResult<Prisma.$EngagementEventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EngagementEvent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EngagementEventFindUniqueOrThrowArgs} args - Arguments to find a EngagementEvent
     * @example
     * // Get one EngagementEvent
     * const engagementEvent = await prisma.engagementEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EngagementEventFindUniqueOrThrowArgs>(args: SelectSubset<T, EngagementEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EngagementEventClient<$Result.GetResult<Prisma.$EngagementEventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EngagementEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementEventFindFirstArgs} args - Arguments to find a EngagementEvent
     * @example
     * // Get one EngagementEvent
     * const engagementEvent = await prisma.engagementEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EngagementEventFindFirstArgs>(args?: SelectSubset<T, EngagementEventFindFirstArgs<ExtArgs>>): Prisma__EngagementEventClient<$Result.GetResult<Prisma.$EngagementEventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EngagementEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementEventFindFirstOrThrowArgs} args - Arguments to find a EngagementEvent
     * @example
     * // Get one EngagementEvent
     * const engagementEvent = await prisma.engagementEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EngagementEventFindFirstOrThrowArgs>(args?: SelectSubset<T, EngagementEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EngagementEventClient<$Result.GetResult<Prisma.$EngagementEventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EngagementEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EngagementEvents
     * const engagementEvents = await prisma.engagementEvent.findMany()
     * 
     * // Get first 10 EngagementEvents
     * const engagementEvents = await prisma.engagementEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const engagementEventWithIdOnly = await prisma.engagementEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EngagementEventFindManyArgs>(args?: SelectSubset<T, EngagementEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EngagementEventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EngagementEvent.
     * @param {EngagementEventCreateArgs} args - Arguments to create a EngagementEvent.
     * @example
     * // Create one EngagementEvent
     * const EngagementEvent = await prisma.engagementEvent.create({
     *   data: {
     *     // ... data to create a EngagementEvent
     *   }
     * })
     * 
     */
    create<T extends EngagementEventCreateArgs>(args: SelectSubset<T, EngagementEventCreateArgs<ExtArgs>>): Prisma__EngagementEventClient<$Result.GetResult<Prisma.$EngagementEventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EngagementEvents.
     * @param {EngagementEventCreateManyArgs} args - Arguments to create many EngagementEvents.
     * @example
     * // Create many EngagementEvents
     * const engagementEvent = await prisma.engagementEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EngagementEventCreateManyArgs>(args?: SelectSubset<T, EngagementEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EngagementEvents and returns the data saved in the database.
     * @param {EngagementEventCreateManyAndReturnArgs} args - Arguments to create many EngagementEvents.
     * @example
     * // Create many EngagementEvents
     * const engagementEvent = await prisma.engagementEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EngagementEvents and only return the `id`
     * const engagementEventWithIdOnly = await prisma.engagementEvent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EngagementEventCreateManyAndReturnArgs>(args?: SelectSubset<T, EngagementEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EngagementEventPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EngagementEvent.
     * @param {EngagementEventDeleteArgs} args - Arguments to delete one EngagementEvent.
     * @example
     * // Delete one EngagementEvent
     * const EngagementEvent = await prisma.engagementEvent.delete({
     *   where: {
     *     // ... filter to delete one EngagementEvent
     *   }
     * })
     * 
     */
    delete<T extends EngagementEventDeleteArgs>(args: SelectSubset<T, EngagementEventDeleteArgs<ExtArgs>>): Prisma__EngagementEventClient<$Result.GetResult<Prisma.$EngagementEventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EngagementEvent.
     * @param {EngagementEventUpdateArgs} args - Arguments to update one EngagementEvent.
     * @example
     * // Update one EngagementEvent
     * const engagementEvent = await prisma.engagementEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EngagementEventUpdateArgs>(args: SelectSubset<T, EngagementEventUpdateArgs<ExtArgs>>): Prisma__EngagementEventClient<$Result.GetResult<Prisma.$EngagementEventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EngagementEvents.
     * @param {EngagementEventDeleteManyArgs} args - Arguments to filter EngagementEvents to delete.
     * @example
     * // Delete a few EngagementEvents
     * const { count } = await prisma.engagementEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EngagementEventDeleteManyArgs>(args?: SelectSubset<T, EngagementEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EngagementEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EngagementEvents
     * const engagementEvent = await prisma.engagementEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EngagementEventUpdateManyArgs>(args: SelectSubset<T, EngagementEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EngagementEvent.
     * @param {EngagementEventUpsertArgs} args - Arguments to update or create a EngagementEvent.
     * @example
     * // Update or create a EngagementEvent
     * const engagementEvent = await prisma.engagementEvent.upsert({
     *   create: {
     *     // ... data to create a EngagementEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EngagementEvent we want to update
     *   }
     * })
     */
    upsert<T extends EngagementEventUpsertArgs>(args: SelectSubset<T, EngagementEventUpsertArgs<ExtArgs>>): Prisma__EngagementEventClient<$Result.GetResult<Prisma.$EngagementEventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EngagementEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementEventCountArgs} args - Arguments to filter EngagementEvents to count.
     * @example
     * // Count the number of EngagementEvents
     * const count = await prisma.engagementEvent.count({
     *   where: {
     *     // ... the filter for the EngagementEvents we want to count
     *   }
     * })
    **/
    count<T extends EngagementEventCountArgs>(
      args?: Subset<T, EngagementEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EngagementEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EngagementEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EngagementEventAggregateArgs>(args: Subset<T, EngagementEventAggregateArgs>): Prisma.PrismaPromise<GetEngagementEventAggregateType<T>>

    /**
     * Group by EngagementEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EngagementEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EngagementEventGroupByArgs['orderBy'] }
        : { orderBy?: EngagementEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EngagementEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEngagementEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EngagementEvent model
   */
  readonly fields: EngagementEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EngagementEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EngagementEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    post<T extends EngagementEvent$postArgs<ExtArgs> = {}>(args?: Subset<T, EngagementEvent$postArgs<ExtArgs>>): Prisma__FeedPostClient<$Result.GetResult<Prisma.$FeedPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comment<T extends EngagementEvent$commentArgs<ExtArgs> = {}>(args?: Subset<T, EngagementEvent$commentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EngagementEvent model
   */ 
  interface EngagementEventFieldRefs {
    readonly id: FieldRef<"EngagementEvent", 'String'>
    readonly type: FieldRef<"EngagementEvent", 'EngagementEventType'>
    readonly userId: FieldRef<"EngagementEvent", 'String'>
    readonly postId: FieldRef<"EngagementEvent", 'String'>
    readonly commentId: FieldRef<"EngagementEvent", 'String'>
    readonly reactionType: FieldRef<"EngagementEvent", 'ReactionType'>
    readonly occurredAt: FieldRef<"EngagementEvent", 'DateTime'>
    readonly metadata: FieldRef<"EngagementEvent", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * EngagementEvent findUnique
   */
  export type EngagementEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementEvent
     */
    select?: EngagementEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementEventInclude<ExtArgs> | null
    /**
     * Filter, which EngagementEvent to fetch.
     */
    where: EngagementEventWhereUniqueInput
  }

  /**
   * EngagementEvent findUniqueOrThrow
   */
  export type EngagementEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementEvent
     */
    select?: EngagementEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementEventInclude<ExtArgs> | null
    /**
     * Filter, which EngagementEvent to fetch.
     */
    where: EngagementEventWhereUniqueInput
  }

  /**
   * EngagementEvent findFirst
   */
  export type EngagementEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementEvent
     */
    select?: EngagementEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementEventInclude<ExtArgs> | null
    /**
     * Filter, which EngagementEvent to fetch.
     */
    where?: EngagementEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EngagementEvents to fetch.
     */
    orderBy?: EngagementEventOrderByWithRelationInput | EngagementEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EngagementEvents.
     */
    cursor?: EngagementEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EngagementEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EngagementEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EngagementEvents.
     */
    distinct?: EngagementEventScalarFieldEnum | EngagementEventScalarFieldEnum[]
  }

  /**
   * EngagementEvent findFirstOrThrow
   */
  export type EngagementEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementEvent
     */
    select?: EngagementEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementEventInclude<ExtArgs> | null
    /**
     * Filter, which EngagementEvent to fetch.
     */
    where?: EngagementEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EngagementEvents to fetch.
     */
    orderBy?: EngagementEventOrderByWithRelationInput | EngagementEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EngagementEvents.
     */
    cursor?: EngagementEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EngagementEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EngagementEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EngagementEvents.
     */
    distinct?: EngagementEventScalarFieldEnum | EngagementEventScalarFieldEnum[]
  }

  /**
   * EngagementEvent findMany
   */
  export type EngagementEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementEvent
     */
    select?: EngagementEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementEventInclude<ExtArgs> | null
    /**
     * Filter, which EngagementEvents to fetch.
     */
    where?: EngagementEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EngagementEvents to fetch.
     */
    orderBy?: EngagementEventOrderByWithRelationInput | EngagementEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EngagementEvents.
     */
    cursor?: EngagementEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EngagementEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EngagementEvents.
     */
    skip?: number
    distinct?: EngagementEventScalarFieldEnum | EngagementEventScalarFieldEnum[]
  }

  /**
   * EngagementEvent create
   */
  export type EngagementEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementEvent
     */
    select?: EngagementEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementEventInclude<ExtArgs> | null
    /**
     * The data needed to create a EngagementEvent.
     */
    data: XOR<EngagementEventCreateInput, EngagementEventUncheckedCreateInput>
  }

  /**
   * EngagementEvent createMany
   */
  export type EngagementEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EngagementEvents.
     */
    data: EngagementEventCreateManyInput | EngagementEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EngagementEvent createManyAndReturn
   */
  export type EngagementEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementEvent
     */
    select?: EngagementEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EngagementEvents.
     */
    data: EngagementEventCreateManyInput | EngagementEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EngagementEvent update
   */
  export type EngagementEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementEvent
     */
    select?: EngagementEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementEventInclude<ExtArgs> | null
    /**
     * The data needed to update a EngagementEvent.
     */
    data: XOR<EngagementEventUpdateInput, EngagementEventUncheckedUpdateInput>
    /**
     * Choose, which EngagementEvent to update.
     */
    where: EngagementEventWhereUniqueInput
  }

  /**
   * EngagementEvent updateMany
   */
  export type EngagementEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EngagementEvents.
     */
    data: XOR<EngagementEventUpdateManyMutationInput, EngagementEventUncheckedUpdateManyInput>
    /**
     * Filter which EngagementEvents to update
     */
    where?: EngagementEventWhereInput
  }

  /**
   * EngagementEvent upsert
   */
  export type EngagementEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementEvent
     */
    select?: EngagementEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementEventInclude<ExtArgs> | null
    /**
     * The filter to search for the EngagementEvent to update in case it exists.
     */
    where: EngagementEventWhereUniqueInput
    /**
     * In case the EngagementEvent found by the `where` argument doesn't exist, create a new EngagementEvent with this data.
     */
    create: XOR<EngagementEventCreateInput, EngagementEventUncheckedCreateInput>
    /**
     * In case the EngagementEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EngagementEventUpdateInput, EngagementEventUncheckedUpdateInput>
  }

  /**
   * EngagementEvent delete
   */
  export type EngagementEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementEvent
     */
    select?: EngagementEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementEventInclude<ExtArgs> | null
    /**
     * Filter which EngagementEvent to delete.
     */
    where: EngagementEventWhereUniqueInput
  }

  /**
   * EngagementEvent deleteMany
   */
  export type EngagementEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EngagementEvents to delete
     */
    where?: EngagementEventWhereInput
  }

  /**
   * EngagementEvent.post
   */
  export type EngagementEvent$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPost
     */
    select?: FeedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPostInclude<ExtArgs> | null
    where?: FeedPostWhereInput
  }

  /**
   * EngagementEvent.comment
   */
  export type EngagementEvent$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * EngagementEvent without action
   */
  export type EngagementEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementEvent
     */
    select?: EngagementEventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementEventInclude<ExtArgs> | null
  }


  /**
   * Model Flag
   */

  export type AggregateFlag = {
    _count: FlagCountAggregateOutputType | null
    _min: FlagMinAggregateOutputType | null
    _max: FlagMaxAggregateOutputType | null
  }

  export type FlagMinAggregateOutputType = {
    id: string | null
    targetType: $Enums.FlagTargetType | null
    status: $Enums.FlagStatus | null
    reason: string | null
    postId: string | null
    commentId: string | null
    insightId: string | null
    biomarkerLogId: string | null
    openedById: string | null
    resolvedById: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlagMaxAggregateOutputType = {
    id: string | null
    targetType: $Enums.FlagTargetType | null
    status: $Enums.FlagStatus | null
    reason: string | null
    postId: string | null
    commentId: string | null
    insightId: string | null
    biomarkerLogId: string | null
    openedById: string | null
    resolvedById: string | null
    resolvedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FlagCountAggregateOutputType = {
    id: number
    targetType: number
    status: number
    reason: number
    postId: number
    commentId: number
    insightId: number
    biomarkerLogId: number
    openedById: number
    resolvedById: number
    resolvedAt: number
    auditTrail: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FlagMinAggregateInputType = {
    id?: true
    targetType?: true
    status?: true
    reason?: true
    postId?: true
    commentId?: true
    insightId?: true
    biomarkerLogId?: true
    openedById?: true
    resolvedById?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlagMaxAggregateInputType = {
    id?: true
    targetType?: true
    status?: true
    reason?: true
    postId?: true
    commentId?: true
    insightId?: true
    biomarkerLogId?: true
    openedById?: true
    resolvedById?: true
    resolvedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FlagCountAggregateInputType = {
    id?: true
    targetType?: true
    status?: true
    reason?: true
    postId?: true
    commentId?: true
    insightId?: true
    biomarkerLogId?: true
    openedById?: true
    resolvedById?: true
    resolvedAt?: true
    auditTrail?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FlagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flag to aggregate.
     */
    where?: FlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flags to fetch.
     */
    orderBy?: FlagOrderByWithRelationInput | FlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Flags
    **/
    _count?: true | FlagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FlagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FlagMaxAggregateInputType
  }

  export type GetFlagAggregateType<T extends FlagAggregateArgs> = {
        [P in keyof T & keyof AggregateFlag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlag[P]>
      : GetScalarType<T[P], AggregateFlag[P]>
  }




  export type FlagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FlagWhereInput
    orderBy?: FlagOrderByWithAggregationInput | FlagOrderByWithAggregationInput[]
    by: FlagScalarFieldEnum[] | FlagScalarFieldEnum
    having?: FlagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FlagCountAggregateInputType | true
    _min?: FlagMinAggregateInputType
    _max?: FlagMaxAggregateInputType
  }

  export type FlagGroupByOutputType = {
    id: string
    targetType: $Enums.FlagTargetType
    status: $Enums.FlagStatus
    reason: string
    postId: string | null
    commentId: string | null
    insightId: string | null
    biomarkerLogId: string | null
    openedById: string
    resolvedById: string | null
    resolvedAt: Date | null
    auditTrail: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: FlagCountAggregateOutputType | null
    _min: FlagMinAggregateOutputType | null
    _max: FlagMaxAggregateOutputType | null
  }

  type GetFlagGroupByPayload<T extends FlagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FlagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FlagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FlagGroupByOutputType[P]>
            : GetScalarType<T[P], FlagGroupByOutputType[P]>
        }
      >
    >


  export type FlagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetType?: boolean
    status?: boolean
    reason?: boolean
    postId?: boolean
    commentId?: boolean
    insightId?: boolean
    biomarkerLogId?: boolean
    openedById?: boolean
    resolvedById?: boolean
    resolvedAt?: boolean
    auditTrail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | Flag$postArgs<ExtArgs>
    comment?: boolean | Flag$commentArgs<ExtArgs>
    insight?: boolean | Flag$insightArgs<ExtArgs>
    biomarkerLog?: boolean | Flag$biomarkerLogArgs<ExtArgs>
    openedBy?: boolean | UserDefaultArgs<ExtArgs>
    resolvedBy?: boolean | Flag$resolvedByArgs<ExtArgs>
  }, ExtArgs["result"]["flag"]>

  export type FlagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    targetType?: boolean
    status?: boolean
    reason?: boolean
    postId?: boolean
    commentId?: boolean
    insightId?: boolean
    biomarkerLogId?: boolean
    openedById?: boolean
    resolvedById?: boolean
    resolvedAt?: boolean
    auditTrail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | Flag$postArgs<ExtArgs>
    comment?: boolean | Flag$commentArgs<ExtArgs>
    insight?: boolean | Flag$insightArgs<ExtArgs>
    biomarkerLog?: boolean | Flag$biomarkerLogArgs<ExtArgs>
    openedBy?: boolean | UserDefaultArgs<ExtArgs>
    resolvedBy?: boolean | Flag$resolvedByArgs<ExtArgs>
  }, ExtArgs["result"]["flag"]>

  export type FlagSelectScalar = {
    id?: boolean
    targetType?: boolean
    status?: boolean
    reason?: boolean
    postId?: boolean
    commentId?: boolean
    insightId?: boolean
    biomarkerLogId?: boolean
    openedById?: boolean
    resolvedById?: boolean
    resolvedAt?: boolean
    auditTrail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FlagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | Flag$postArgs<ExtArgs>
    comment?: boolean | Flag$commentArgs<ExtArgs>
    insight?: boolean | Flag$insightArgs<ExtArgs>
    biomarkerLog?: boolean | Flag$biomarkerLogArgs<ExtArgs>
    openedBy?: boolean | UserDefaultArgs<ExtArgs>
    resolvedBy?: boolean | Flag$resolvedByArgs<ExtArgs>
  }
  export type FlagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | Flag$postArgs<ExtArgs>
    comment?: boolean | Flag$commentArgs<ExtArgs>
    insight?: boolean | Flag$insightArgs<ExtArgs>
    biomarkerLog?: boolean | Flag$biomarkerLogArgs<ExtArgs>
    openedBy?: boolean | UserDefaultArgs<ExtArgs>
    resolvedBy?: boolean | Flag$resolvedByArgs<ExtArgs>
  }

  export type $FlagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Flag"
    objects: {
      post: Prisma.$FeedPostPayload<ExtArgs> | null
      comment: Prisma.$CommentPayload<ExtArgs> | null
      insight: Prisma.$InsightPayload<ExtArgs> | null
      biomarkerLog: Prisma.$BiomarkerLogPayload<ExtArgs> | null
      openedBy: Prisma.$UserPayload<ExtArgs>
      resolvedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      targetType: $Enums.FlagTargetType
      status: $Enums.FlagStatus
      reason: string
      postId: string | null
      commentId: string | null
      insightId: string | null
      biomarkerLogId: string | null
      openedById: string
      resolvedById: string | null
      resolvedAt: Date | null
      auditTrail: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["flag"]>
    composites: {}
  }

  type FlagGetPayload<S extends boolean | null | undefined | FlagDefaultArgs> = $Result.GetResult<Prisma.$FlagPayload, S>

  type FlagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FlagFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FlagCountAggregateInputType | true
    }

  export interface FlagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Flag'], meta: { name: 'Flag' } }
    /**
     * Find zero or one Flag that matches the filter.
     * @param {FlagFindUniqueArgs} args - Arguments to find a Flag
     * @example
     * // Get one Flag
     * const flag = await prisma.flag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FlagFindUniqueArgs>(args: SelectSubset<T, FlagFindUniqueArgs<ExtArgs>>): Prisma__FlagClient<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Flag that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FlagFindUniqueOrThrowArgs} args - Arguments to find a Flag
     * @example
     * // Get one Flag
     * const flag = await prisma.flag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FlagFindUniqueOrThrowArgs>(args: SelectSubset<T, FlagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FlagClient<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Flag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagFindFirstArgs} args - Arguments to find a Flag
     * @example
     * // Get one Flag
     * const flag = await prisma.flag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FlagFindFirstArgs>(args?: SelectSubset<T, FlagFindFirstArgs<ExtArgs>>): Prisma__FlagClient<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Flag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagFindFirstOrThrowArgs} args - Arguments to find a Flag
     * @example
     * // Get one Flag
     * const flag = await prisma.flag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FlagFindFirstOrThrowArgs>(args?: SelectSubset<T, FlagFindFirstOrThrowArgs<ExtArgs>>): Prisma__FlagClient<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Flags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flags
     * const flags = await prisma.flag.findMany()
     * 
     * // Get first 10 Flags
     * const flags = await prisma.flag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const flagWithIdOnly = await prisma.flag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FlagFindManyArgs>(args?: SelectSubset<T, FlagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Flag.
     * @param {FlagCreateArgs} args - Arguments to create a Flag.
     * @example
     * // Create one Flag
     * const Flag = await prisma.flag.create({
     *   data: {
     *     // ... data to create a Flag
     *   }
     * })
     * 
     */
    create<T extends FlagCreateArgs>(args: SelectSubset<T, FlagCreateArgs<ExtArgs>>): Prisma__FlagClient<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Flags.
     * @param {FlagCreateManyArgs} args - Arguments to create many Flags.
     * @example
     * // Create many Flags
     * const flag = await prisma.flag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FlagCreateManyArgs>(args?: SelectSubset<T, FlagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Flags and returns the data saved in the database.
     * @param {FlagCreateManyAndReturnArgs} args - Arguments to create many Flags.
     * @example
     * // Create many Flags
     * const flag = await prisma.flag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Flags and only return the `id`
     * const flagWithIdOnly = await prisma.flag.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FlagCreateManyAndReturnArgs>(args?: SelectSubset<T, FlagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Flag.
     * @param {FlagDeleteArgs} args - Arguments to delete one Flag.
     * @example
     * // Delete one Flag
     * const Flag = await prisma.flag.delete({
     *   where: {
     *     // ... filter to delete one Flag
     *   }
     * })
     * 
     */
    delete<T extends FlagDeleteArgs>(args: SelectSubset<T, FlagDeleteArgs<ExtArgs>>): Prisma__FlagClient<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Flag.
     * @param {FlagUpdateArgs} args - Arguments to update one Flag.
     * @example
     * // Update one Flag
     * const flag = await prisma.flag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FlagUpdateArgs>(args: SelectSubset<T, FlagUpdateArgs<ExtArgs>>): Prisma__FlagClient<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Flags.
     * @param {FlagDeleteManyArgs} args - Arguments to filter Flags to delete.
     * @example
     * // Delete a few Flags
     * const { count } = await prisma.flag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FlagDeleteManyArgs>(args?: SelectSubset<T, FlagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flags
     * const flag = await prisma.flag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FlagUpdateManyArgs>(args: SelectSubset<T, FlagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Flag.
     * @param {FlagUpsertArgs} args - Arguments to update or create a Flag.
     * @example
     * // Update or create a Flag
     * const flag = await prisma.flag.upsert({
     *   create: {
     *     // ... data to create a Flag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flag we want to update
     *   }
     * })
     */
    upsert<T extends FlagUpsertArgs>(args: SelectSubset<T, FlagUpsertArgs<ExtArgs>>): Prisma__FlagClient<$Result.GetResult<Prisma.$FlagPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Flags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagCountArgs} args - Arguments to filter Flags to count.
     * @example
     * // Count the number of Flags
     * const count = await prisma.flag.count({
     *   where: {
     *     // ... the filter for the Flags we want to count
     *   }
     * })
    **/
    count<T extends FlagCountArgs>(
      args?: Subset<T, FlagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FlagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FlagAggregateArgs>(args: Subset<T, FlagAggregateArgs>): Prisma.PrismaPromise<GetFlagAggregateType<T>>

    /**
     * Group by Flag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FlagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FlagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FlagGroupByArgs['orderBy'] }
        : { orderBy?: FlagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FlagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Flag model
   */
  readonly fields: FlagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Flag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FlagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends Flag$postArgs<ExtArgs> = {}>(args?: Subset<T, Flag$postArgs<ExtArgs>>): Prisma__FeedPostClient<$Result.GetResult<Prisma.$FeedPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comment<T extends Flag$commentArgs<ExtArgs> = {}>(args?: Subset<T, Flag$commentArgs<ExtArgs>>): Prisma__CommentClient<$Result.GetResult<Prisma.$CommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    insight<T extends Flag$insightArgs<ExtArgs> = {}>(args?: Subset<T, Flag$insightArgs<ExtArgs>>): Prisma__InsightClient<$Result.GetResult<Prisma.$InsightPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    biomarkerLog<T extends Flag$biomarkerLogArgs<ExtArgs> = {}>(args?: Subset<T, Flag$biomarkerLogArgs<ExtArgs>>): Prisma__BiomarkerLogClient<$Result.GetResult<Prisma.$BiomarkerLogPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    openedBy<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    resolvedBy<T extends Flag$resolvedByArgs<ExtArgs> = {}>(args?: Subset<T, Flag$resolvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Flag model
   */ 
  interface FlagFieldRefs {
    readonly id: FieldRef<"Flag", 'String'>
    readonly targetType: FieldRef<"Flag", 'FlagTargetType'>
    readonly status: FieldRef<"Flag", 'FlagStatus'>
    readonly reason: FieldRef<"Flag", 'String'>
    readonly postId: FieldRef<"Flag", 'String'>
    readonly commentId: FieldRef<"Flag", 'String'>
    readonly insightId: FieldRef<"Flag", 'String'>
    readonly biomarkerLogId: FieldRef<"Flag", 'String'>
    readonly openedById: FieldRef<"Flag", 'String'>
    readonly resolvedById: FieldRef<"Flag", 'String'>
    readonly resolvedAt: FieldRef<"Flag", 'DateTime'>
    readonly auditTrail: FieldRef<"Flag", 'Json'>
    readonly createdAt: FieldRef<"Flag", 'DateTime'>
    readonly updatedAt: FieldRef<"Flag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Flag findUnique
   */
  export type FlagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    /**
     * Filter, which Flag to fetch.
     */
    where: FlagWhereUniqueInput
  }

  /**
   * Flag findUniqueOrThrow
   */
  export type FlagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    /**
     * Filter, which Flag to fetch.
     */
    where: FlagWhereUniqueInput
  }

  /**
   * Flag findFirst
   */
  export type FlagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    /**
     * Filter, which Flag to fetch.
     */
    where?: FlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flags to fetch.
     */
    orderBy?: FlagOrderByWithRelationInput | FlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flags.
     */
    cursor?: FlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flags.
     */
    distinct?: FlagScalarFieldEnum | FlagScalarFieldEnum[]
  }

  /**
   * Flag findFirstOrThrow
   */
  export type FlagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    /**
     * Filter, which Flag to fetch.
     */
    where?: FlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flags to fetch.
     */
    orderBy?: FlagOrderByWithRelationInput | FlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Flags.
     */
    cursor?: FlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Flags.
     */
    distinct?: FlagScalarFieldEnum | FlagScalarFieldEnum[]
  }

  /**
   * Flag findMany
   */
  export type FlagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    /**
     * Filter, which Flags to fetch.
     */
    where?: FlagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Flags to fetch.
     */
    orderBy?: FlagOrderByWithRelationInput | FlagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Flags.
     */
    cursor?: FlagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Flags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Flags.
     */
    skip?: number
    distinct?: FlagScalarFieldEnum | FlagScalarFieldEnum[]
  }

  /**
   * Flag create
   */
  export type FlagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    /**
     * The data needed to create a Flag.
     */
    data: XOR<FlagCreateInput, FlagUncheckedCreateInput>
  }

  /**
   * Flag createMany
   */
  export type FlagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Flags.
     */
    data: FlagCreateManyInput | FlagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Flag createManyAndReturn
   */
  export type FlagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Flags.
     */
    data: FlagCreateManyInput | FlagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Flag update
   */
  export type FlagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    /**
     * The data needed to update a Flag.
     */
    data: XOR<FlagUpdateInput, FlagUncheckedUpdateInput>
    /**
     * Choose, which Flag to update.
     */
    where: FlagWhereUniqueInput
  }

  /**
   * Flag updateMany
   */
  export type FlagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Flags.
     */
    data: XOR<FlagUpdateManyMutationInput, FlagUncheckedUpdateManyInput>
    /**
     * Filter which Flags to update
     */
    where?: FlagWhereInput
  }

  /**
   * Flag upsert
   */
  export type FlagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    /**
     * The filter to search for the Flag to update in case it exists.
     */
    where: FlagWhereUniqueInput
    /**
     * In case the Flag found by the `where` argument doesn't exist, create a new Flag with this data.
     */
    create: XOR<FlagCreateInput, FlagUncheckedCreateInput>
    /**
     * In case the Flag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FlagUpdateInput, FlagUncheckedUpdateInput>
  }

  /**
   * Flag delete
   */
  export type FlagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
    /**
     * Filter which Flag to delete.
     */
    where: FlagWhereUniqueInput
  }

  /**
   * Flag deleteMany
   */
  export type FlagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Flags to delete
     */
    where?: FlagWhereInput
  }

  /**
   * Flag.post
   */
  export type Flag$postArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedPost
     */
    select?: FeedPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedPostInclude<ExtArgs> | null
    where?: FeedPostWhereInput
  }

  /**
   * Flag.comment
   */
  export type Flag$commentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Comment
     */
    select?: CommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentInclude<ExtArgs> | null
    where?: CommentWhereInput
  }

  /**
   * Flag.insight
   */
  export type Flag$insightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Insight
     */
    select?: InsightSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InsightInclude<ExtArgs> | null
    where?: InsightWhereInput
  }

  /**
   * Flag.biomarkerLog
   */
  export type Flag$biomarkerLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiomarkerLog
     */
    select?: BiomarkerLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiomarkerLogInclude<ExtArgs> | null
    where?: BiomarkerLogWhereInput
  }

  /**
   * Flag.resolvedBy
   */
  export type Flag$resolvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Flag without action
   */
  export type FlagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Flag
     */
    select?: FlagSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FlagInclude<ExtArgs> | null
  }


  /**
   * Model AdminAuditLog
   */

  export type AggregateAdminAuditLog = {
    _count: AdminAuditLogCountAggregateOutputType | null
    _min: AdminAuditLogMinAggregateOutputType | null
    _max: AdminAuditLogMaxAggregateOutputType | null
  }

  export type AdminAuditLogMinAggregateOutputType = {
    id: string | null
    actorId: string | null
    action: string | null
    targetType: string | null
    targetId: string | null
    createdAt: Date | null
  }

  export type AdminAuditLogMaxAggregateOutputType = {
    id: string | null
    actorId: string | null
    action: string | null
    targetType: string | null
    targetId: string | null
    createdAt: Date | null
  }

  export type AdminAuditLogCountAggregateOutputType = {
    id: number
    actorId: number
    action: number
    targetType: number
    targetId: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AdminAuditLogMinAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    targetType?: true
    targetId?: true
    createdAt?: true
  }

  export type AdminAuditLogMaxAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    targetType?: true
    targetId?: true
    createdAt?: true
  }

  export type AdminAuditLogCountAggregateInputType = {
    id?: true
    actorId?: true
    action?: true
    targetType?: true
    targetId?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AdminAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuditLog to aggregate.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AdminAuditLogs
    **/
    _count?: true | AdminAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdminAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdminAuditLogMaxAggregateInputType
  }

  export type GetAdminAuditLogAggregateType<T extends AdminAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAdminAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdminAuditLog[P]>
      : GetScalarType<T[P], AggregateAdminAuditLog[P]>
  }




  export type AdminAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AdminAuditLogWhereInput
    orderBy?: AdminAuditLogOrderByWithAggregationInput | AdminAuditLogOrderByWithAggregationInput[]
    by: AdminAuditLogScalarFieldEnum[] | AdminAuditLogScalarFieldEnum
    having?: AdminAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdminAuditLogCountAggregateInputType | true
    _min?: AdminAuditLogMinAggregateInputType
    _max?: AdminAuditLogMaxAggregateInputType
  }

  export type AdminAuditLogGroupByOutputType = {
    id: string
    actorId: string
    action: string
    targetType: string
    targetId: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: AdminAuditLogCountAggregateOutputType | null
    _min: AdminAuditLogMinAggregateOutputType | null
    _max: AdminAuditLogMaxAggregateOutputType | null
  }

  type GetAdminAuditLogGroupByPayload<T extends AdminAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdminAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdminAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdminAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AdminAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AdminAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    metadata?: boolean
    createdAt?: boolean
    actor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuditLog"]>

  export type AdminAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    metadata?: boolean
    createdAt?: boolean
    actor?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["adminAuditLog"]>

  export type AdminAuditLogSelectScalar = {
    id?: boolean
    actorId?: boolean
    action?: boolean
    targetType?: boolean
    targetId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AdminAuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AdminAuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AdminAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AdminAuditLog"
    objects: {
      actor: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actorId: string
      action: string
      targetType: string
      targetId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["adminAuditLog"]>
    composites: {}
  }

  type AdminAuditLogGetPayload<S extends boolean | null | undefined | AdminAuditLogDefaultArgs> = $Result.GetResult<Prisma.$AdminAuditLogPayload, S>

  type AdminAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AdminAuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdminAuditLogCountAggregateInputType | true
    }

  export interface AdminAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AdminAuditLog'], meta: { name: 'AdminAuditLog' } }
    /**
     * Find zero or one AdminAuditLog that matches the filter.
     * @param {AdminAuditLogFindUniqueArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AdminAuditLogFindUniqueArgs>(args: SelectSubset<T, AdminAuditLogFindUniqueArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AdminAuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AdminAuditLogFindUniqueOrThrowArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AdminAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AdminAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AdminAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindFirstArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AdminAuditLogFindFirstArgs>(args?: SelectSubset<T, AdminAuditLogFindFirstArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AdminAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindFirstOrThrowArgs} args - Arguments to find a AdminAuditLog
     * @example
     * // Get one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AdminAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AdminAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AdminAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AdminAuditLogs
     * const adminAuditLogs = await prisma.adminAuditLog.findMany()
     * 
     * // Get first 10 AdminAuditLogs
     * const adminAuditLogs = await prisma.adminAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const adminAuditLogWithIdOnly = await prisma.adminAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AdminAuditLogFindManyArgs>(args?: SelectSubset<T, AdminAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AdminAuditLog.
     * @param {AdminAuditLogCreateArgs} args - Arguments to create a AdminAuditLog.
     * @example
     * // Create one AdminAuditLog
     * const AdminAuditLog = await prisma.adminAuditLog.create({
     *   data: {
     *     // ... data to create a AdminAuditLog
     *   }
     * })
     * 
     */
    create<T extends AdminAuditLogCreateArgs>(args: SelectSubset<T, AdminAuditLogCreateArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AdminAuditLogs.
     * @param {AdminAuditLogCreateManyArgs} args - Arguments to create many AdminAuditLogs.
     * @example
     * // Create many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AdminAuditLogCreateManyArgs>(args?: SelectSubset<T, AdminAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AdminAuditLogs and returns the data saved in the database.
     * @param {AdminAuditLogCreateManyAndReturnArgs} args - Arguments to create many AdminAuditLogs.
     * @example
     * // Create many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AdminAuditLogs and only return the `id`
     * const adminAuditLogWithIdOnly = await prisma.adminAuditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AdminAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AdminAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AdminAuditLog.
     * @param {AdminAuditLogDeleteArgs} args - Arguments to delete one AdminAuditLog.
     * @example
     * // Delete one AdminAuditLog
     * const AdminAuditLog = await prisma.adminAuditLog.delete({
     *   where: {
     *     // ... filter to delete one AdminAuditLog
     *   }
     * })
     * 
     */
    delete<T extends AdminAuditLogDeleteArgs>(args: SelectSubset<T, AdminAuditLogDeleteArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AdminAuditLog.
     * @param {AdminAuditLogUpdateArgs} args - Arguments to update one AdminAuditLog.
     * @example
     * // Update one AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AdminAuditLogUpdateArgs>(args: SelectSubset<T, AdminAuditLogUpdateArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AdminAuditLogs.
     * @param {AdminAuditLogDeleteManyArgs} args - Arguments to filter AdminAuditLogs to delete.
     * @example
     * // Delete a few AdminAuditLogs
     * const { count } = await prisma.adminAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AdminAuditLogDeleteManyArgs>(args?: SelectSubset<T, AdminAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AdminAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AdminAuditLogs
     * const adminAuditLog = await prisma.adminAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AdminAuditLogUpdateManyArgs>(args: SelectSubset<T, AdminAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AdminAuditLog.
     * @param {AdminAuditLogUpsertArgs} args - Arguments to update or create a AdminAuditLog.
     * @example
     * // Update or create a AdminAuditLog
     * const adminAuditLog = await prisma.adminAuditLog.upsert({
     *   create: {
     *     // ... data to create a AdminAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AdminAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AdminAuditLogUpsertArgs>(args: SelectSubset<T, AdminAuditLogUpsertArgs<ExtArgs>>): Prisma__AdminAuditLogClient<$Result.GetResult<Prisma.$AdminAuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AdminAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogCountArgs} args - Arguments to filter AdminAuditLogs to count.
     * @example
     * // Count the number of AdminAuditLogs
     * const count = await prisma.adminAuditLog.count({
     *   where: {
     *     // ... the filter for the AdminAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AdminAuditLogCountArgs>(
      args?: Subset<T, AdminAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdminAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AdminAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdminAuditLogAggregateArgs>(args: Subset<T, AdminAuditLogAggregateArgs>): Prisma.PrismaPromise<GetAdminAuditLogAggregateType<T>>

    /**
     * Group by AdminAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdminAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AdminAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AdminAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AdminAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AdminAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdminAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AdminAuditLog model
   */
  readonly fields: AdminAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AdminAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AdminAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AdminAuditLog model
   */ 
  interface AdminAuditLogFieldRefs {
    readonly id: FieldRef<"AdminAuditLog", 'String'>
    readonly actorId: FieldRef<"AdminAuditLog", 'String'>
    readonly action: FieldRef<"AdminAuditLog", 'String'>
    readonly targetType: FieldRef<"AdminAuditLog", 'String'>
    readonly targetId: FieldRef<"AdminAuditLog", 'String'>
    readonly metadata: FieldRef<"AdminAuditLog", 'Json'>
    readonly createdAt: FieldRef<"AdminAuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AdminAuditLog findUnique
   */
  export type AdminAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog findUniqueOrThrow
   */
  export type AdminAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog findFirst
   */
  export type AdminAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuditLogs.
     */
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog findFirstOrThrow
   */
  export type AdminAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLog to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AdminAuditLogs.
     */
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog findMany
   */
  export type AdminAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AdminAuditLogs to fetch.
     */
    where?: AdminAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AdminAuditLogs to fetch.
     */
    orderBy?: AdminAuditLogOrderByWithRelationInput | AdminAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AdminAuditLogs.
     */
    cursor?: AdminAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AdminAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AdminAuditLogs.
     */
    skip?: number
    distinct?: AdminAuditLogScalarFieldEnum | AdminAuditLogScalarFieldEnum[]
  }

  /**
   * AdminAuditLog create
   */
  export type AdminAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AdminAuditLog.
     */
    data: XOR<AdminAuditLogCreateInput, AdminAuditLogUncheckedCreateInput>
  }

  /**
   * AdminAuditLog createMany
   */
  export type AdminAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AdminAuditLogs.
     */
    data: AdminAuditLogCreateManyInput | AdminAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AdminAuditLog createManyAndReturn
   */
  export type AdminAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AdminAuditLogs.
     */
    data: AdminAuditLogCreateManyInput | AdminAuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AdminAuditLog update
   */
  export type AdminAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AdminAuditLog.
     */
    data: XOR<AdminAuditLogUpdateInput, AdminAuditLogUncheckedUpdateInput>
    /**
     * Choose, which AdminAuditLog to update.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog updateMany
   */
  export type AdminAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AdminAuditLogs.
     */
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AdminAuditLogs to update
     */
    where?: AdminAuditLogWhereInput
  }

  /**
   * AdminAuditLog upsert
   */
  export type AdminAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AdminAuditLog to update in case it exists.
     */
    where: AdminAuditLogWhereUniqueInput
    /**
     * In case the AdminAuditLog found by the `where` argument doesn't exist, create a new AdminAuditLog with this data.
     */
    create: XOR<AdminAuditLogCreateInput, AdminAuditLogUncheckedCreateInput>
    /**
     * In case the AdminAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AdminAuditLogUpdateInput, AdminAuditLogUncheckedUpdateInput>
  }

  /**
   * AdminAuditLog delete
   */
  export type AdminAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
    /**
     * Filter which AdminAuditLog to delete.
     */
    where: AdminAuditLogWhereUniqueInput
  }

  /**
   * AdminAuditLog deleteMany
   */
  export type AdminAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AdminAuditLogs to delete
     */
    where?: AdminAuditLogWhereInput
  }

  /**
   * AdminAuditLog without action
   */
  export type AdminAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdminAuditLog
     */
    select?: AdminAuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AdminAuditLogInclude<ExtArgs> | null
  }


  /**
   * Model AiResponseAudit
   */

  export type AggregateAiResponseAudit = {
    _count: AiResponseAuditCountAggregateOutputType | null
    _min: AiResponseAuditMinAggregateOutputType | null
    _max: AiResponseAuditMaxAggregateOutputType | null
  }

  export type AiResponseAuditMinAggregateOutputType = {
    id: string | null
    planId: string | null
    userId: string | null
    provider: string | null
    model: string | null
    role: string | null
    createdAt: Date | null
  }

  export type AiResponseAuditMaxAggregateOutputType = {
    id: string | null
    planId: string | null
    userId: string | null
    provider: string | null
    model: string | null
    role: string | null
    createdAt: Date | null
  }

  export type AiResponseAuditCountAggregateOutputType = {
    id: number
    planId: number
    userId: number
    provider: number
    model: number
    role: number
    prompt: number
    response: number
    createdAt: number
    _all: number
  }


  export type AiResponseAuditMinAggregateInputType = {
    id?: true
    planId?: true
    userId?: true
    provider?: true
    model?: true
    role?: true
    createdAt?: true
  }

  export type AiResponseAuditMaxAggregateInputType = {
    id?: true
    planId?: true
    userId?: true
    provider?: true
    model?: true
    role?: true
    createdAt?: true
  }

  export type AiResponseAuditCountAggregateInputType = {
    id?: true
    planId?: true
    userId?: true
    provider?: true
    model?: true
    role?: true
    prompt?: true
    response?: true
    createdAt?: true
    _all?: true
  }

  export type AiResponseAuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiResponseAudit to aggregate.
     */
    where?: AiResponseAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiResponseAudits to fetch.
     */
    orderBy?: AiResponseAuditOrderByWithRelationInput | AiResponseAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AiResponseAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiResponseAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiResponseAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AiResponseAudits
    **/
    _count?: true | AiResponseAuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AiResponseAuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AiResponseAuditMaxAggregateInputType
  }

  export type GetAiResponseAuditAggregateType<T extends AiResponseAuditAggregateArgs> = {
        [P in keyof T & keyof AggregateAiResponseAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAiResponseAudit[P]>
      : GetScalarType<T[P], AggregateAiResponseAudit[P]>
  }




  export type AiResponseAuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AiResponseAuditWhereInput
    orderBy?: AiResponseAuditOrderByWithAggregationInput | AiResponseAuditOrderByWithAggregationInput[]
    by: AiResponseAuditScalarFieldEnum[] | AiResponseAuditScalarFieldEnum
    having?: AiResponseAuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AiResponseAuditCountAggregateInputType | true
    _min?: AiResponseAuditMinAggregateInputType
    _max?: AiResponseAuditMaxAggregateInputType
  }

  export type AiResponseAuditGroupByOutputType = {
    id: string
    planId: string | null
    userId: string | null
    provider: string
    model: string | null
    role: string | null
    prompt: JsonValue | null
    response: JsonValue | null
    createdAt: Date
    _count: AiResponseAuditCountAggregateOutputType | null
    _min: AiResponseAuditMinAggregateOutputType | null
    _max: AiResponseAuditMaxAggregateOutputType | null
  }

  type GetAiResponseAuditGroupByPayload<T extends AiResponseAuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AiResponseAuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AiResponseAuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AiResponseAuditGroupByOutputType[P]>
            : GetScalarType<T[P], AiResponseAuditGroupByOutputType[P]>
        }
      >
    >


  export type AiResponseAuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    userId?: boolean
    provider?: boolean
    model?: boolean
    role?: boolean
    prompt?: boolean
    response?: boolean
    createdAt?: boolean
    plan?: boolean | AiResponseAudit$planArgs<ExtArgs>
    user?: boolean | AiResponseAudit$userArgs<ExtArgs>
  }, ExtArgs["result"]["aiResponseAudit"]>

  export type AiResponseAuditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    planId?: boolean
    userId?: boolean
    provider?: boolean
    model?: boolean
    role?: boolean
    prompt?: boolean
    response?: boolean
    createdAt?: boolean
    plan?: boolean | AiResponseAudit$planArgs<ExtArgs>
    user?: boolean | AiResponseAudit$userArgs<ExtArgs>
  }, ExtArgs["result"]["aiResponseAudit"]>

  export type AiResponseAuditSelectScalar = {
    id?: boolean
    planId?: boolean
    userId?: boolean
    provider?: boolean
    model?: boolean
    role?: boolean
    prompt?: boolean
    response?: boolean
    createdAt?: boolean
  }

  export type AiResponseAuditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | AiResponseAudit$planArgs<ExtArgs>
    user?: boolean | AiResponseAudit$userArgs<ExtArgs>
  }
  export type AiResponseAuditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    plan?: boolean | AiResponseAudit$planArgs<ExtArgs>
    user?: boolean | AiResponseAudit$userArgs<ExtArgs>
  }

  export type $AiResponseAuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AiResponseAudit"
    objects: {
      plan: Prisma.$LongevityPlanPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      planId: string | null
      userId: string | null
      provider: string
      model: string | null
      role: string | null
      prompt: Prisma.JsonValue | null
      response: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["aiResponseAudit"]>
    composites: {}
  }

  type AiResponseAuditGetPayload<S extends boolean | null | undefined | AiResponseAuditDefaultArgs> = $Result.GetResult<Prisma.$AiResponseAuditPayload, S>

  type AiResponseAuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AiResponseAuditFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AiResponseAuditCountAggregateInputType | true
    }

  export interface AiResponseAuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AiResponseAudit'], meta: { name: 'AiResponseAudit' } }
    /**
     * Find zero or one AiResponseAudit that matches the filter.
     * @param {AiResponseAuditFindUniqueArgs} args - Arguments to find a AiResponseAudit
     * @example
     * // Get one AiResponseAudit
     * const aiResponseAudit = await prisma.aiResponseAudit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AiResponseAuditFindUniqueArgs>(args: SelectSubset<T, AiResponseAuditFindUniqueArgs<ExtArgs>>): Prisma__AiResponseAuditClient<$Result.GetResult<Prisma.$AiResponseAuditPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AiResponseAudit that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AiResponseAuditFindUniqueOrThrowArgs} args - Arguments to find a AiResponseAudit
     * @example
     * // Get one AiResponseAudit
     * const aiResponseAudit = await prisma.aiResponseAudit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AiResponseAuditFindUniqueOrThrowArgs>(args: SelectSubset<T, AiResponseAuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AiResponseAuditClient<$Result.GetResult<Prisma.$AiResponseAuditPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AiResponseAudit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiResponseAuditFindFirstArgs} args - Arguments to find a AiResponseAudit
     * @example
     * // Get one AiResponseAudit
     * const aiResponseAudit = await prisma.aiResponseAudit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AiResponseAuditFindFirstArgs>(args?: SelectSubset<T, AiResponseAuditFindFirstArgs<ExtArgs>>): Prisma__AiResponseAuditClient<$Result.GetResult<Prisma.$AiResponseAuditPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AiResponseAudit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiResponseAuditFindFirstOrThrowArgs} args - Arguments to find a AiResponseAudit
     * @example
     * // Get one AiResponseAudit
     * const aiResponseAudit = await prisma.aiResponseAudit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AiResponseAuditFindFirstOrThrowArgs>(args?: SelectSubset<T, AiResponseAuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__AiResponseAuditClient<$Result.GetResult<Prisma.$AiResponseAuditPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AiResponseAudits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiResponseAuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AiResponseAudits
     * const aiResponseAudits = await prisma.aiResponseAudit.findMany()
     * 
     * // Get first 10 AiResponseAudits
     * const aiResponseAudits = await prisma.aiResponseAudit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const aiResponseAuditWithIdOnly = await prisma.aiResponseAudit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AiResponseAuditFindManyArgs>(args?: SelectSubset<T, AiResponseAuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiResponseAuditPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AiResponseAudit.
     * @param {AiResponseAuditCreateArgs} args - Arguments to create a AiResponseAudit.
     * @example
     * // Create one AiResponseAudit
     * const AiResponseAudit = await prisma.aiResponseAudit.create({
     *   data: {
     *     // ... data to create a AiResponseAudit
     *   }
     * })
     * 
     */
    create<T extends AiResponseAuditCreateArgs>(args: SelectSubset<T, AiResponseAuditCreateArgs<ExtArgs>>): Prisma__AiResponseAuditClient<$Result.GetResult<Prisma.$AiResponseAuditPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AiResponseAudits.
     * @param {AiResponseAuditCreateManyArgs} args - Arguments to create many AiResponseAudits.
     * @example
     * // Create many AiResponseAudits
     * const aiResponseAudit = await prisma.aiResponseAudit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AiResponseAuditCreateManyArgs>(args?: SelectSubset<T, AiResponseAuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AiResponseAudits and returns the data saved in the database.
     * @param {AiResponseAuditCreateManyAndReturnArgs} args - Arguments to create many AiResponseAudits.
     * @example
     * // Create many AiResponseAudits
     * const aiResponseAudit = await prisma.aiResponseAudit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AiResponseAudits and only return the `id`
     * const aiResponseAuditWithIdOnly = await prisma.aiResponseAudit.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AiResponseAuditCreateManyAndReturnArgs>(args?: SelectSubset<T, AiResponseAuditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AiResponseAuditPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AiResponseAudit.
     * @param {AiResponseAuditDeleteArgs} args - Arguments to delete one AiResponseAudit.
     * @example
     * // Delete one AiResponseAudit
     * const AiResponseAudit = await prisma.aiResponseAudit.delete({
     *   where: {
     *     // ... filter to delete one AiResponseAudit
     *   }
     * })
     * 
     */
    delete<T extends AiResponseAuditDeleteArgs>(args: SelectSubset<T, AiResponseAuditDeleteArgs<ExtArgs>>): Prisma__AiResponseAuditClient<$Result.GetResult<Prisma.$AiResponseAuditPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AiResponseAudit.
     * @param {AiResponseAuditUpdateArgs} args - Arguments to update one AiResponseAudit.
     * @example
     * // Update one AiResponseAudit
     * const aiResponseAudit = await prisma.aiResponseAudit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AiResponseAuditUpdateArgs>(args: SelectSubset<T, AiResponseAuditUpdateArgs<ExtArgs>>): Prisma__AiResponseAuditClient<$Result.GetResult<Prisma.$AiResponseAuditPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AiResponseAudits.
     * @param {AiResponseAuditDeleteManyArgs} args - Arguments to filter AiResponseAudits to delete.
     * @example
     * // Delete a few AiResponseAudits
     * const { count } = await prisma.aiResponseAudit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AiResponseAuditDeleteManyArgs>(args?: SelectSubset<T, AiResponseAuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AiResponseAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiResponseAuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AiResponseAudits
     * const aiResponseAudit = await prisma.aiResponseAudit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AiResponseAuditUpdateManyArgs>(args: SelectSubset<T, AiResponseAuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AiResponseAudit.
     * @param {AiResponseAuditUpsertArgs} args - Arguments to update or create a AiResponseAudit.
     * @example
     * // Update or create a AiResponseAudit
     * const aiResponseAudit = await prisma.aiResponseAudit.upsert({
     *   create: {
     *     // ... data to create a AiResponseAudit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AiResponseAudit we want to update
     *   }
     * })
     */
    upsert<T extends AiResponseAuditUpsertArgs>(args: SelectSubset<T, AiResponseAuditUpsertArgs<ExtArgs>>): Prisma__AiResponseAuditClient<$Result.GetResult<Prisma.$AiResponseAuditPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AiResponseAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiResponseAuditCountArgs} args - Arguments to filter AiResponseAudits to count.
     * @example
     * // Count the number of AiResponseAudits
     * const count = await prisma.aiResponseAudit.count({
     *   where: {
     *     // ... the filter for the AiResponseAudits we want to count
     *   }
     * })
    **/
    count<T extends AiResponseAuditCountArgs>(
      args?: Subset<T, AiResponseAuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AiResponseAuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AiResponseAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiResponseAuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AiResponseAuditAggregateArgs>(args: Subset<T, AiResponseAuditAggregateArgs>): Prisma.PrismaPromise<GetAiResponseAuditAggregateType<T>>

    /**
     * Group by AiResponseAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AiResponseAuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AiResponseAuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AiResponseAuditGroupByArgs['orderBy'] }
        : { orderBy?: AiResponseAuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AiResponseAuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAiResponseAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AiResponseAudit model
   */
  readonly fields: AiResponseAuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AiResponseAudit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AiResponseAuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    plan<T extends AiResponseAudit$planArgs<ExtArgs> = {}>(args?: Subset<T, AiResponseAudit$planArgs<ExtArgs>>): Prisma__LongevityPlanClient<$Result.GetResult<Prisma.$LongevityPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    user<T extends AiResponseAudit$userArgs<ExtArgs> = {}>(args?: Subset<T, AiResponseAudit$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AiResponseAudit model
   */ 
  interface AiResponseAuditFieldRefs {
    readonly id: FieldRef<"AiResponseAudit", 'String'>
    readonly planId: FieldRef<"AiResponseAudit", 'String'>
    readonly userId: FieldRef<"AiResponseAudit", 'String'>
    readonly provider: FieldRef<"AiResponseAudit", 'String'>
    readonly model: FieldRef<"AiResponseAudit", 'String'>
    readonly role: FieldRef<"AiResponseAudit", 'String'>
    readonly prompt: FieldRef<"AiResponseAudit", 'Json'>
    readonly response: FieldRef<"AiResponseAudit", 'Json'>
    readonly createdAt: FieldRef<"AiResponseAudit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AiResponseAudit findUnique
   */
  export type AiResponseAuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiResponseAudit
     */
    select?: AiResponseAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiResponseAuditInclude<ExtArgs> | null
    /**
     * Filter, which AiResponseAudit to fetch.
     */
    where: AiResponseAuditWhereUniqueInput
  }

  /**
   * AiResponseAudit findUniqueOrThrow
   */
  export type AiResponseAuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiResponseAudit
     */
    select?: AiResponseAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiResponseAuditInclude<ExtArgs> | null
    /**
     * Filter, which AiResponseAudit to fetch.
     */
    where: AiResponseAuditWhereUniqueInput
  }

  /**
   * AiResponseAudit findFirst
   */
  export type AiResponseAuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiResponseAudit
     */
    select?: AiResponseAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiResponseAuditInclude<ExtArgs> | null
    /**
     * Filter, which AiResponseAudit to fetch.
     */
    where?: AiResponseAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiResponseAudits to fetch.
     */
    orderBy?: AiResponseAuditOrderByWithRelationInput | AiResponseAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiResponseAudits.
     */
    cursor?: AiResponseAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiResponseAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiResponseAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiResponseAudits.
     */
    distinct?: AiResponseAuditScalarFieldEnum | AiResponseAuditScalarFieldEnum[]
  }

  /**
   * AiResponseAudit findFirstOrThrow
   */
  export type AiResponseAuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiResponseAudit
     */
    select?: AiResponseAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiResponseAuditInclude<ExtArgs> | null
    /**
     * Filter, which AiResponseAudit to fetch.
     */
    where?: AiResponseAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiResponseAudits to fetch.
     */
    orderBy?: AiResponseAuditOrderByWithRelationInput | AiResponseAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AiResponseAudits.
     */
    cursor?: AiResponseAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiResponseAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiResponseAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AiResponseAudits.
     */
    distinct?: AiResponseAuditScalarFieldEnum | AiResponseAuditScalarFieldEnum[]
  }

  /**
   * AiResponseAudit findMany
   */
  export type AiResponseAuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiResponseAudit
     */
    select?: AiResponseAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiResponseAuditInclude<ExtArgs> | null
    /**
     * Filter, which AiResponseAudits to fetch.
     */
    where?: AiResponseAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AiResponseAudits to fetch.
     */
    orderBy?: AiResponseAuditOrderByWithRelationInput | AiResponseAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AiResponseAudits.
     */
    cursor?: AiResponseAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AiResponseAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AiResponseAudits.
     */
    skip?: number
    distinct?: AiResponseAuditScalarFieldEnum | AiResponseAuditScalarFieldEnum[]
  }

  /**
   * AiResponseAudit create
   */
  export type AiResponseAuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiResponseAudit
     */
    select?: AiResponseAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiResponseAuditInclude<ExtArgs> | null
    /**
     * The data needed to create a AiResponseAudit.
     */
    data: XOR<AiResponseAuditCreateInput, AiResponseAuditUncheckedCreateInput>
  }

  /**
   * AiResponseAudit createMany
   */
  export type AiResponseAuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AiResponseAudits.
     */
    data: AiResponseAuditCreateManyInput | AiResponseAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AiResponseAudit createManyAndReturn
   */
  export type AiResponseAuditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiResponseAudit
     */
    select?: AiResponseAuditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AiResponseAudits.
     */
    data: AiResponseAuditCreateManyInput | AiResponseAuditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiResponseAuditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AiResponseAudit update
   */
  export type AiResponseAuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiResponseAudit
     */
    select?: AiResponseAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiResponseAuditInclude<ExtArgs> | null
    /**
     * The data needed to update a AiResponseAudit.
     */
    data: XOR<AiResponseAuditUpdateInput, AiResponseAuditUncheckedUpdateInput>
    /**
     * Choose, which AiResponseAudit to update.
     */
    where: AiResponseAuditWhereUniqueInput
  }

  /**
   * AiResponseAudit updateMany
   */
  export type AiResponseAuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AiResponseAudits.
     */
    data: XOR<AiResponseAuditUpdateManyMutationInput, AiResponseAuditUncheckedUpdateManyInput>
    /**
     * Filter which AiResponseAudits to update
     */
    where?: AiResponseAuditWhereInput
  }

  /**
   * AiResponseAudit upsert
   */
  export type AiResponseAuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiResponseAudit
     */
    select?: AiResponseAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiResponseAuditInclude<ExtArgs> | null
    /**
     * The filter to search for the AiResponseAudit to update in case it exists.
     */
    where: AiResponseAuditWhereUniqueInput
    /**
     * In case the AiResponseAudit found by the `where` argument doesn't exist, create a new AiResponseAudit with this data.
     */
    create: XOR<AiResponseAuditCreateInput, AiResponseAuditUncheckedCreateInput>
    /**
     * In case the AiResponseAudit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AiResponseAuditUpdateInput, AiResponseAuditUncheckedUpdateInput>
  }

  /**
   * AiResponseAudit delete
   */
  export type AiResponseAuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiResponseAudit
     */
    select?: AiResponseAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiResponseAuditInclude<ExtArgs> | null
    /**
     * Filter which AiResponseAudit to delete.
     */
    where: AiResponseAuditWhereUniqueInput
  }

  /**
   * AiResponseAudit deleteMany
   */
  export type AiResponseAuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AiResponseAudits to delete
     */
    where?: AiResponseAuditWhereInput
  }

  /**
   * AiResponseAudit.plan
   */
  export type AiResponseAudit$planArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LongevityPlan
     */
    select?: LongevityPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LongevityPlanInclude<ExtArgs> | null
    where?: LongevityPlanWhereInput
  }

  /**
   * AiResponseAudit.user
   */
  export type AiResponseAudit$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AiResponseAudit without action
   */
  export type AiResponseAuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AiResponseAudit
     */
    select?: AiResponseAuditSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AiResponseAuditInclude<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomAvgAggregateOutputType = {
    capacity: number | null
  }

  export type RoomSumAggregateOutputType = {
    capacity: number | null
  }

  export type RoomMinAggregateOutputType = {
    id: string | null
    name: string | null
    inviteCode: string | null
    status: $Enums.RoomStatus | null
    capacity: number | null
    hostId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomMaxAggregateOutputType = {
    id: string | null
    name: string | null
    inviteCode: string | null
    status: $Enums.RoomStatus | null
    capacity: number | null
    hostId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    name: number
    inviteCode: number
    status: number
    capacity: number
    hostId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomAvgAggregateInputType = {
    capacity?: true
  }

  export type RoomSumAggregateInputType = {
    capacity?: true
  }

  export type RoomMinAggregateInputType = {
    id?: true
    name?: true
    inviteCode?: true
    status?: true
    capacity?: true
    hostId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    name?: true
    inviteCode?: true
    status?: true
    capacity?: true
    hostId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    name?: true
    inviteCode?: true
    status?: true
    capacity?: true
    hostId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _avg?: RoomAvgAggregateInputType
    _sum?: RoomSumAggregateInputType
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: string
    name: string | null
    inviteCode: string
    status: $Enums.RoomStatus
    capacity: number
    hostId: string
    createdAt: Date
    updatedAt: Date
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    inviteCode?: boolean
    status?: boolean
    capacity?: boolean
    hostId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    host?: boolean | UserDefaultArgs<ExtArgs>
    memberships?: boolean | Room$membershipsArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    inviteCode?: boolean
    status?: boolean
    capacity?: boolean
    hostId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    host?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectScalar = {
    id?: boolean
    name?: boolean
    inviteCode?: boolean
    status?: boolean
    capacity?: boolean
    hostId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    host?: boolean | UserDefaultArgs<ExtArgs>
    memberships?: boolean | Room$membershipsArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    host?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      host: Prisma.$UserPayload<ExtArgs>
      memberships: Prisma.$RoomMembershipPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      inviteCode: string
      status: $Enums.RoomStatus
      capacity: number
      hostId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomFindUniqueArgs>(args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomFindFirstArgs>(args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomFindManyArgs>(args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends RoomCreateArgs>(args: SelectSubset<T, RoomCreateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomCreateManyArgs>(args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rooms and returns the data saved in the database.
     * @param {RoomCreateManyAndReturnArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends RoomDeleteArgs>(args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomUpdateArgs>(args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomDeleteManyArgs>(args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomUpdateManyArgs>(args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends RoomUpsertArgs>(args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    host<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    memberships<T extends Room$membershipsArgs<ExtArgs> = {}>(args?: Subset<T, Room$membershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Room model
   */ 
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'String'>
    readonly name: FieldRef<"Room", 'String'>
    readonly inviteCode: FieldRef<"Room", 'String'>
    readonly status: FieldRef<"Room", 'RoomStatus'>
    readonly capacity: FieldRef<"Room", 'Int'>
    readonly hostId: FieldRef<"Room", 'String'>
    readonly createdAt: FieldRef<"Room", 'DateTime'>
    readonly updatedAt: FieldRef<"Room", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Room createManyAndReturn
   */
  export type RoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
  }

  /**
   * Room.memberships
   */
  export type Room$membershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    where?: RoomMembershipWhereInput
    orderBy?: RoomMembershipOrderByWithRelationInput | RoomMembershipOrderByWithRelationInput[]
    cursor?: RoomMembershipWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomMembershipScalarFieldEnum | RoomMembershipScalarFieldEnum[]
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
  }


  /**
   * Model RoomMembership
   */

  export type AggregateRoomMembership = {
    _count: RoomMembershipCountAggregateOutputType | null
    _min: RoomMembershipMinAggregateOutputType | null
    _max: RoomMembershipMaxAggregateOutputType | null
  }

  export type RoomMembershipMinAggregateOutputType = {
    id: string | null
    roomId: string | null
    userId: string | null
    role: $Enums.RoomMembershipRole | null
    status: $Enums.RoomMembershipStatus | null
    joinedAt: Date | null
    leftAt: Date | null
    lastSeenAt: Date | null
    reconnectToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomMembershipMaxAggregateOutputType = {
    id: string | null
    roomId: string | null
    userId: string | null
    role: $Enums.RoomMembershipRole | null
    status: $Enums.RoomMembershipStatus | null
    joinedAt: Date | null
    leftAt: Date | null
    lastSeenAt: Date | null
    reconnectToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomMembershipCountAggregateOutputType = {
    id: number
    roomId: number
    userId: number
    role: number
    status: number
    joinedAt: number
    leftAt: number
    lastSeenAt: number
    reconnectToken: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomMembershipMinAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    role?: true
    status?: true
    joinedAt?: true
    leftAt?: true
    lastSeenAt?: true
    reconnectToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomMembershipMaxAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    role?: true
    status?: true
    joinedAt?: true
    leftAt?: true
    lastSeenAt?: true
    reconnectToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomMembershipCountAggregateInputType = {
    id?: true
    roomId?: true
    userId?: true
    role?: true
    status?: true
    joinedAt?: true
    leftAt?: true
    lastSeenAt?: true
    reconnectToken?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomMembershipAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomMembership to aggregate.
     */
    where?: RoomMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomMemberships to fetch.
     */
    orderBy?: RoomMembershipOrderByWithRelationInput | RoomMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomMemberships
    **/
    _count?: true | RoomMembershipCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMembershipMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMembershipMaxAggregateInputType
  }

  export type GetRoomMembershipAggregateType<T extends RoomMembershipAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomMembership]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomMembership[P]>
      : GetScalarType<T[P], AggregateRoomMembership[P]>
  }




  export type RoomMembershipGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomMembershipWhereInput
    orderBy?: RoomMembershipOrderByWithAggregationInput | RoomMembershipOrderByWithAggregationInput[]
    by: RoomMembershipScalarFieldEnum[] | RoomMembershipScalarFieldEnum
    having?: RoomMembershipScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomMembershipCountAggregateInputType | true
    _min?: RoomMembershipMinAggregateInputType
    _max?: RoomMembershipMaxAggregateInputType
  }

  export type RoomMembershipGroupByOutputType = {
    id: string
    roomId: string
    userId: string
    role: $Enums.RoomMembershipRole
    status: $Enums.RoomMembershipStatus
    joinedAt: Date
    leftAt: Date | null
    lastSeenAt: Date | null
    reconnectToken: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoomMembershipCountAggregateOutputType | null
    _min: RoomMembershipMinAggregateOutputType | null
    _max: RoomMembershipMaxAggregateOutputType | null
  }

  type GetRoomMembershipGroupByPayload<T extends RoomMembershipGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomMembershipGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomMembershipGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomMembershipGroupByOutputType[P]>
            : GetScalarType<T[P], RoomMembershipGroupByOutputType[P]>
        }
      >
    >


  export type RoomMembershipSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    role?: boolean
    status?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    lastSeenAt?: boolean
    reconnectToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomMembership"]>

  export type RoomMembershipSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    userId?: boolean
    role?: boolean
    status?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    lastSeenAt?: boolean
    reconnectToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomMembership"]>

  export type RoomMembershipSelectScalar = {
    id?: boolean
    roomId?: boolean
    userId?: boolean
    role?: boolean
    status?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    lastSeenAt?: boolean
    reconnectToken?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomMembershipInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RoomMembershipIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RoomMembershipPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomMembership"
    objects: {
      room: Prisma.$RoomPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomId: string
      userId: string
      role: $Enums.RoomMembershipRole
      status: $Enums.RoomMembershipStatus
      joinedAt: Date
      leftAt: Date | null
      lastSeenAt: Date | null
      reconnectToken: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roomMembership"]>
    composites: {}
  }

  type RoomMembershipGetPayload<S extends boolean | null | undefined | RoomMembershipDefaultArgs> = $Result.GetResult<Prisma.$RoomMembershipPayload, S>

  type RoomMembershipCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomMembershipFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomMembershipCountAggregateInputType | true
    }

  export interface RoomMembershipDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomMembership'], meta: { name: 'RoomMembership' } }
    /**
     * Find zero or one RoomMembership that matches the filter.
     * @param {RoomMembershipFindUniqueArgs} args - Arguments to find a RoomMembership
     * @example
     * // Get one RoomMembership
     * const roomMembership = await prisma.roomMembership.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomMembershipFindUniqueArgs>(args: SelectSubset<T, RoomMembershipFindUniqueArgs<ExtArgs>>): Prisma__RoomMembershipClient<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoomMembership that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoomMembershipFindUniqueOrThrowArgs} args - Arguments to find a RoomMembership
     * @example
     * // Get one RoomMembership
     * const roomMembership = await prisma.roomMembership.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomMembershipFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomMembershipFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomMembershipClient<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoomMembership that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMembershipFindFirstArgs} args - Arguments to find a RoomMembership
     * @example
     * // Get one RoomMembership
     * const roomMembership = await prisma.roomMembership.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomMembershipFindFirstArgs>(args?: SelectSubset<T, RoomMembershipFindFirstArgs<ExtArgs>>): Prisma__RoomMembershipClient<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoomMembership that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMembershipFindFirstOrThrowArgs} args - Arguments to find a RoomMembership
     * @example
     * // Get one RoomMembership
     * const roomMembership = await prisma.roomMembership.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomMembershipFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomMembershipFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomMembershipClient<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoomMemberships that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMembershipFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomMemberships
     * const roomMemberships = await prisma.roomMembership.findMany()
     * 
     * // Get first 10 RoomMemberships
     * const roomMemberships = await prisma.roomMembership.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomMembershipWithIdOnly = await prisma.roomMembership.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomMembershipFindManyArgs>(args?: SelectSubset<T, RoomMembershipFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoomMembership.
     * @param {RoomMembershipCreateArgs} args - Arguments to create a RoomMembership.
     * @example
     * // Create one RoomMembership
     * const RoomMembership = await prisma.roomMembership.create({
     *   data: {
     *     // ... data to create a RoomMembership
     *   }
     * })
     * 
     */
    create<T extends RoomMembershipCreateArgs>(args: SelectSubset<T, RoomMembershipCreateArgs<ExtArgs>>): Prisma__RoomMembershipClient<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoomMemberships.
     * @param {RoomMembershipCreateManyArgs} args - Arguments to create many RoomMemberships.
     * @example
     * // Create many RoomMemberships
     * const roomMembership = await prisma.roomMembership.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomMembershipCreateManyArgs>(args?: SelectSubset<T, RoomMembershipCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoomMemberships and returns the data saved in the database.
     * @param {RoomMembershipCreateManyAndReturnArgs} args - Arguments to create many RoomMemberships.
     * @example
     * // Create many RoomMemberships
     * const roomMembership = await prisma.roomMembership.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoomMemberships and only return the `id`
     * const roomMembershipWithIdOnly = await prisma.roomMembership.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomMembershipCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomMembershipCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoomMembership.
     * @param {RoomMembershipDeleteArgs} args - Arguments to delete one RoomMembership.
     * @example
     * // Delete one RoomMembership
     * const RoomMembership = await prisma.roomMembership.delete({
     *   where: {
     *     // ... filter to delete one RoomMembership
     *   }
     * })
     * 
     */
    delete<T extends RoomMembershipDeleteArgs>(args: SelectSubset<T, RoomMembershipDeleteArgs<ExtArgs>>): Prisma__RoomMembershipClient<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoomMembership.
     * @param {RoomMembershipUpdateArgs} args - Arguments to update one RoomMembership.
     * @example
     * // Update one RoomMembership
     * const roomMembership = await prisma.roomMembership.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomMembershipUpdateArgs>(args: SelectSubset<T, RoomMembershipUpdateArgs<ExtArgs>>): Prisma__RoomMembershipClient<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoomMemberships.
     * @param {RoomMembershipDeleteManyArgs} args - Arguments to filter RoomMemberships to delete.
     * @example
     * // Delete a few RoomMemberships
     * const { count } = await prisma.roomMembership.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomMembershipDeleteManyArgs>(args?: SelectSubset<T, RoomMembershipDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMembershipUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomMemberships
     * const roomMembership = await prisma.roomMembership.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomMembershipUpdateManyArgs>(args: SelectSubset<T, RoomMembershipUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoomMembership.
     * @param {RoomMembershipUpsertArgs} args - Arguments to update or create a RoomMembership.
     * @example
     * // Update or create a RoomMembership
     * const roomMembership = await prisma.roomMembership.upsert({
     *   create: {
     *     // ... data to create a RoomMembership
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomMembership we want to update
     *   }
     * })
     */
    upsert<T extends RoomMembershipUpsertArgs>(args: SelectSubset<T, RoomMembershipUpsertArgs<ExtArgs>>): Prisma__RoomMembershipClient<$Result.GetResult<Prisma.$RoomMembershipPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoomMemberships.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMembershipCountArgs} args - Arguments to filter RoomMemberships to count.
     * @example
     * // Count the number of RoomMemberships
     * const count = await prisma.roomMembership.count({
     *   where: {
     *     // ... the filter for the RoomMemberships we want to count
     *   }
     * })
    **/
    count<T extends RoomMembershipCountArgs>(
      args?: Subset<T, RoomMembershipCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomMembershipCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMembershipAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomMembershipAggregateArgs>(args: Subset<T, RoomMembershipAggregateArgs>): Prisma.PrismaPromise<GetRoomMembershipAggregateType<T>>

    /**
     * Group by RoomMembership.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomMembershipGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomMembershipGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomMembershipGroupByArgs['orderBy'] }
        : { orderBy?: RoomMembershipGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomMembershipGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomMembershipGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomMembership model
   */
  readonly fields: RoomMembershipFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomMembership.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomMembershipClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomMembership model
   */ 
  interface RoomMembershipFieldRefs {
    readonly id: FieldRef<"RoomMembership", 'String'>
    readonly roomId: FieldRef<"RoomMembership", 'String'>
    readonly userId: FieldRef<"RoomMembership", 'String'>
    readonly role: FieldRef<"RoomMembership", 'RoomMembershipRole'>
    readonly status: FieldRef<"RoomMembership", 'RoomMembershipStatus'>
    readonly joinedAt: FieldRef<"RoomMembership", 'DateTime'>
    readonly leftAt: FieldRef<"RoomMembership", 'DateTime'>
    readonly lastSeenAt: FieldRef<"RoomMembership", 'DateTime'>
    readonly reconnectToken: FieldRef<"RoomMembership", 'String'>
    readonly createdAt: FieldRef<"RoomMembership", 'DateTime'>
    readonly updatedAt: FieldRef<"RoomMembership", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoomMembership findUnique
   */
  export type RoomMembershipFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RoomMembership to fetch.
     */
    where: RoomMembershipWhereUniqueInput
  }

  /**
   * RoomMembership findUniqueOrThrow
   */
  export type RoomMembershipFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RoomMembership to fetch.
     */
    where: RoomMembershipWhereUniqueInput
  }

  /**
   * RoomMembership findFirst
   */
  export type RoomMembershipFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RoomMembership to fetch.
     */
    where?: RoomMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomMemberships to fetch.
     */
    orderBy?: RoomMembershipOrderByWithRelationInput | RoomMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomMemberships.
     */
    cursor?: RoomMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomMemberships.
     */
    distinct?: RoomMembershipScalarFieldEnum | RoomMembershipScalarFieldEnum[]
  }

  /**
   * RoomMembership findFirstOrThrow
   */
  export type RoomMembershipFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RoomMembership to fetch.
     */
    where?: RoomMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomMemberships to fetch.
     */
    orderBy?: RoomMembershipOrderByWithRelationInput | RoomMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomMemberships.
     */
    cursor?: RoomMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomMemberships.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomMemberships.
     */
    distinct?: RoomMembershipScalarFieldEnum | RoomMembershipScalarFieldEnum[]
  }

  /**
   * RoomMembership findMany
   */
  export type RoomMembershipFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    /**
     * Filter, which RoomMemberships to fetch.
     */
    where?: RoomMembershipWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomMemberships to fetch.
     */
    orderBy?: RoomMembershipOrderByWithRelationInput | RoomMembershipOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomMemberships.
     */
    cursor?: RoomMembershipWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomMemberships from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomMemberships.
     */
    skip?: number
    distinct?: RoomMembershipScalarFieldEnum | RoomMembershipScalarFieldEnum[]
  }

  /**
   * RoomMembership create
   */
  export type RoomMembershipCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomMembership.
     */
    data: XOR<RoomMembershipCreateInput, RoomMembershipUncheckedCreateInput>
  }

  /**
   * RoomMembership createMany
   */
  export type RoomMembershipCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomMemberships.
     */
    data: RoomMembershipCreateManyInput | RoomMembershipCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoomMembership createManyAndReturn
   */
  export type RoomMembershipCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoomMemberships.
     */
    data: RoomMembershipCreateManyInput | RoomMembershipCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomMembership update
   */
  export type RoomMembershipUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomMembership.
     */
    data: XOR<RoomMembershipUpdateInput, RoomMembershipUncheckedUpdateInput>
    /**
     * Choose, which RoomMembership to update.
     */
    where: RoomMembershipWhereUniqueInput
  }

  /**
   * RoomMembership updateMany
   */
  export type RoomMembershipUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomMemberships.
     */
    data: XOR<RoomMembershipUpdateManyMutationInput, RoomMembershipUncheckedUpdateManyInput>
    /**
     * Filter which RoomMemberships to update
     */
    where?: RoomMembershipWhereInput
  }

  /**
   * RoomMembership upsert
   */
  export type RoomMembershipUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomMembership to update in case it exists.
     */
    where: RoomMembershipWhereUniqueInput
    /**
     * In case the RoomMembership found by the `where` argument doesn't exist, create a new RoomMembership with this data.
     */
    create: XOR<RoomMembershipCreateInput, RoomMembershipUncheckedCreateInput>
    /**
     * In case the RoomMembership was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomMembershipUpdateInput, RoomMembershipUncheckedUpdateInput>
  }

  /**
   * RoomMembership delete
   */
  export type RoomMembershipDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
    /**
     * Filter which RoomMembership to delete.
     */
    where: RoomMembershipWhereUniqueInput
  }

  /**
   * RoomMembership deleteMany
   */
  export type RoomMembershipDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomMemberships to delete
     */
    where?: RoomMembershipWhereInput
  }

  /**
   * RoomMembership without action
   */
  export type RoomMembershipDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomMembership
     */
    select?: RoomMembershipSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomMembershipInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    fullName: 'fullName',
    role: 'role',
    status: 'status',
    whoopMemberId: 'whoopMemberId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    displayName: 'displayName',
    timezone: 'timezone',
    baselineSurvey: 'baselineSurvey',
    consents: 'consents',
    onboardingCompletedAt: 'onboardingCompletedAt',
    deleteRequested: 'deleteRequested',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const InsightScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    title: 'title',
    summary: 'summary',
    body: 'body',
    modelUsed: 'modelUsed',
    promptMetadata: 'promptMetadata',
    status: 'status',
    generatedAt: 'generatedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InsightScalarFieldEnum = (typeof InsightScalarFieldEnum)[keyof typeof InsightScalarFieldEnum]


  export const LongevityPlanScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    title: 'title',
    summary: 'summary',
    focusAreas: 'focusAreas',
    sections: 'sections',
    evidence: 'evidence',
    safetyState: 'safetyState',
    validatedBy: 'validatedBy',
    validatedAt: 'validatedAt',
    requestedAt: 'requestedAt',
    completedAt: 'completedAt',
    errorCode: 'errorCode',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LongevityPlanScalarFieldEnum = (typeof LongevityPlanScalarFieldEnum)[keyof typeof LongevityPlanScalarFieldEnum]


  export const BiomarkerScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    unit: 'unit',
    referenceLow: 'referenceLow',
    referenceHigh: 'referenceHigh',
    source: 'source',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BiomarkerScalarFieldEnum = (typeof BiomarkerScalarFieldEnum)[keyof typeof BiomarkerScalarFieldEnum]


  export const BiomarkerLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    biomarkerId: 'biomarkerId',
    value: 'value',
    unit: 'unit',
    source: 'source',
    capturedAt: 'capturedAt',
    accepted: 'accepted',
    flagged: 'flagged',
    notes: 'notes',
    rawPayload: 'rawPayload',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BiomarkerLogScalarFieldEnum = (typeof BiomarkerLogScalarFieldEnum)[keyof typeof BiomarkerLogScalarFieldEnum]


  export const PanelUploadScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    source: 'source',
    storageKey: 'storageKey',
    contentType: 'contentType',
    pageCount: 'pageCount',
    rawMetadata: 'rawMetadata',
    normalizedPayload: 'normalizedPayload',
    measurementCount: 'measurementCount',
    processedAt: 'processedAt',
    errorCode: 'errorCode',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PanelUploadScalarFieldEnum = (typeof PanelUploadScalarFieldEnum)[keyof typeof PanelUploadScalarFieldEnum]


  export const BiomarkerMeasurementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    biomarkerId: 'biomarkerId',
    panelUploadId: 'panelUploadId',
    markerName: 'markerName',
    value: 'value',
    unit: 'unit',
    referenceLow: 'referenceLow',
    referenceHigh: 'referenceHigh',
    capturedAt: 'capturedAt',
    status: 'status',
    source: 'source',
    confidence: 'confidence',
    flags: 'flags',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BiomarkerMeasurementScalarFieldEnum = (typeof BiomarkerMeasurementScalarFieldEnum)[keyof typeof BiomarkerMeasurementScalarFieldEnum]


  export const AuthProviderScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    providerUserId: 'providerUserId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    scopes: 'scopes',
    expiresAt: 'expiresAt',
    linkedAt: 'linkedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AuthProviderScalarFieldEnum = (typeof AuthProviderScalarFieldEnum)[keyof typeof AuthProviderScalarFieldEnum]


  export const LoginAuditScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    email: 'email',
    provider: 'provider',
    success: 'success',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    failureReason: 'failureReason',
    createdAt: 'createdAt'
  };

  export type LoginAuditScalarFieldEnum = (typeof LoginAuditScalarFieldEnum)[keyof typeof LoginAuditScalarFieldEnum]


  export const InsightActionScalarFieldEnum: {
    id: 'id',
    insightId: 'insightId',
    actorId: 'actorId',
    actionType: 'actionType',
    notes: 'notes',
    createdAt: 'createdAt'
  };

  export type InsightActionScalarFieldEnum = (typeof InsightActionScalarFieldEnum)[keyof typeof InsightActionScalarFieldEnum]


  export const InsightGenerationJobScalarFieldEnum: {
    id: 'id',
    insightId: 'insightId',
    requestedById: 'requestedById',
    status: 'status',
    cloudTaskName: 'cloudTaskName',
    queue: 'queue',
    payload: 'payload',
    scheduledAt: 'scheduledAt',
    dispatchedAt: 'dispatchedAt',
    completedAt: 'completedAt',
    errorCode: 'errorCode',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InsightGenerationJobScalarFieldEnum = (typeof InsightGenerationJobScalarFieldEnum)[keyof typeof InsightGenerationJobScalarFieldEnum]


  export const LongevityPlanJobScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    requestedById: 'requestedById',
    status: 'status',
    cloudTaskName: 'cloudTaskName',
    queue: 'queue',
    payload: 'payload',
    scheduledAt: 'scheduledAt',
    dispatchedAt: 'dispatchedAt',
    completedAt: 'completedAt',
    errorCode: 'errorCode',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LongevityPlanJobScalarFieldEnum = (typeof LongevityPlanJobScalarFieldEnum)[keyof typeof LongevityPlanJobScalarFieldEnum]


  export const CloudTaskMetadataScalarFieldEnum: {
    id: 'id',
    taskName: 'taskName',
    queue: 'queue',
    status: 'status',
    jobId: 'jobId',
    planJobId: 'planJobId',
    payload: 'payload',
    scheduleTime: 'scheduleTime',
    firstAttemptAt: 'firstAttemptAt',
    lastAttemptAt: 'lastAttemptAt',
    attemptCount: 'attemptCount',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CloudTaskMetadataScalarFieldEnum = (typeof CloudTaskMetadataScalarFieldEnum)[keyof typeof CloudTaskMetadataScalarFieldEnum]


  export const WhoopIntegrationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    whoopUserId: 'whoopUserId',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    expiresAt: 'expiresAt',
    scope: 'scope',
    tokenKeyId: 'tokenKeyId',
    tokenRotatedAt: 'tokenRotatedAt',
    syncStatus: 'syncStatus',
    lastSyncedAt: 'lastSyncedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type WhoopIntegrationScalarFieldEnum = (typeof WhoopIntegrationScalarFieldEnum)[keyof typeof WhoopIntegrationScalarFieldEnum]


  export const WhoopLinkSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    state: 'state',
    redirectUri: 'redirectUri',
    scope: 'scope',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    completedAt: 'completedAt',
    cancelledAt: 'cancelledAt'
  };

  export type WhoopLinkSessionScalarFieldEnum = (typeof WhoopLinkSessionScalarFieldEnum)[keyof typeof WhoopLinkSessionScalarFieldEnum]


  export const FeedPostScalarFieldEnum: {
    id: 'id',
    authorId: 'authorId',
    body: 'body',
    tags: 'tags',
    visibility: 'visibility',
    flagged: 'flagged',
    reactionSummary: 'reactionSummary',
    commentCount: 'commentCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FeedPostScalarFieldEnum = (typeof FeedPostScalarFieldEnum)[keyof typeof FeedPostScalarFieldEnum]


  export const CommentScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    authorId: 'authorId',
    body: 'body',
    flagged: 'flagged',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CommentScalarFieldEnum = (typeof CommentScalarFieldEnum)[keyof typeof CommentScalarFieldEnum]


  export const ReactionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    postId: 'postId',
    commentId: 'commentId',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type ReactionScalarFieldEnum = (typeof ReactionScalarFieldEnum)[keyof typeof ReactionScalarFieldEnum]


  export const EngagementEventScalarFieldEnum: {
    id: 'id',
    type: 'type',
    userId: 'userId',
    postId: 'postId',
    commentId: 'commentId',
    reactionType: 'reactionType',
    occurredAt: 'occurredAt',
    metadata: 'metadata'
  };

  export type EngagementEventScalarFieldEnum = (typeof EngagementEventScalarFieldEnum)[keyof typeof EngagementEventScalarFieldEnum]


  export const FlagScalarFieldEnum: {
    id: 'id',
    targetType: 'targetType',
    status: 'status',
    reason: 'reason',
    postId: 'postId',
    commentId: 'commentId',
    insightId: 'insightId',
    biomarkerLogId: 'biomarkerLogId',
    openedById: 'openedById',
    resolvedById: 'resolvedById',
    resolvedAt: 'resolvedAt',
    auditTrail: 'auditTrail',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FlagScalarFieldEnum = (typeof FlagScalarFieldEnum)[keyof typeof FlagScalarFieldEnum]


  export const AdminAuditLogScalarFieldEnum: {
    id: 'id',
    actorId: 'actorId',
    action: 'action',
    targetType: 'targetType',
    targetId: 'targetId',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AdminAuditLogScalarFieldEnum = (typeof AdminAuditLogScalarFieldEnum)[keyof typeof AdminAuditLogScalarFieldEnum]


  export const AiResponseAuditScalarFieldEnum: {
    id: 'id',
    planId: 'planId',
    userId: 'userId',
    provider: 'provider',
    model: 'model',
    role: 'role',
    prompt: 'prompt',
    response: 'response',
    createdAt: 'createdAt'
  };

  export type AiResponseAuditScalarFieldEnum = (typeof AiResponseAuditScalarFieldEnum)[keyof typeof AiResponseAuditScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    name: 'name',
    inviteCode: 'inviteCode',
    status: 'status',
    capacity: 'capacity',
    hostId: 'hostId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const RoomMembershipScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    userId: 'userId',
    role: 'role',
    status: 'status',
    joinedAt: 'joinedAt',
    leftAt: 'leftAt',
    lastSeenAt: 'lastSeenAt',
    reconnectToken: 'reconnectToken',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomMembershipScalarFieldEnum = (typeof RoomMembershipScalarFieldEnum)[keyof typeof RoomMembershipScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus'>
    


  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserStatus[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'InsightStatus'
   */
  export type EnumInsightStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightStatus'>
    


  /**
   * Reference to a field of type 'InsightStatus[]'
   */
  export type ListEnumInsightStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightStatus[]'>
    


  /**
   * Reference to a field of type 'LongevityPlanStatus'
   */
  export type EnumLongevityPlanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LongevityPlanStatus'>
    


  /**
   * Reference to a field of type 'LongevityPlanStatus[]'
   */
  export type ListEnumLongevityPlanStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LongevityPlanStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'BiomarkerSource'
   */
  export type EnumBiomarkerSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BiomarkerSource'>
    


  /**
   * Reference to a field of type 'BiomarkerSource[]'
   */
  export type ListEnumBiomarkerSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BiomarkerSource[]'>
    


  /**
   * Reference to a field of type 'PanelUploadStatus'
   */
  export type EnumPanelUploadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PanelUploadStatus'>
    


  /**
   * Reference to a field of type 'PanelUploadStatus[]'
   */
  export type ListEnumPanelUploadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PanelUploadStatus[]'>
    


  /**
   * Reference to a field of type 'PanelUploadSource'
   */
  export type EnumPanelUploadSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PanelUploadSource'>
    


  /**
   * Reference to a field of type 'PanelUploadSource[]'
   */
  export type ListEnumPanelUploadSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PanelUploadSource[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'MeasurementStatus'
   */
  export type EnumMeasurementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeasurementStatus'>
    


  /**
   * Reference to a field of type 'MeasurementStatus[]'
   */
  export type ListEnumMeasurementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeasurementStatus[]'>
    


  /**
   * Reference to a field of type 'AuthProviderType'
   */
  export type EnumAuthProviderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProviderType'>
    


  /**
   * Reference to a field of type 'AuthProviderType[]'
   */
  export type ListEnumAuthProviderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthProviderType[]'>
    


  /**
   * Reference to a field of type 'InsightActionType'
   */
  export type EnumInsightActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightActionType'>
    


  /**
   * Reference to a field of type 'InsightActionType[]'
   */
  export type ListEnumInsightActionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightActionType[]'>
    


  /**
   * Reference to a field of type 'InsightGenerationStatus'
   */
  export type EnumInsightGenerationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightGenerationStatus'>
    


  /**
   * Reference to a field of type 'InsightGenerationStatus[]'
   */
  export type ListEnumInsightGenerationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InsightGenerationStatus[]'>
    


  /**
   * Reference to a field of type 'LongevityPlanJobStatus'
   */
  export type EnumLongevityPlanJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LongevityPlanJobStatus'>
    


  /**
   * Reference to a field of type 'LongevityPlanJobStatus[]'
   */
  export type ListEnumLongevityPlanJobStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LongevityPlanJobStatus[]'>
    


  /**
   * Reference to a field of type 'CloudTaskStatus'
   */
  export type EnumCloudTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CloudTaskStatus'>
    


  /**
   * Reference to a field of type 'CloudTaskStatus[]'
   */
  export type ListEnumCloudTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CloudTaskStatus[]'>
    


  /**
   * Reference to a field of type 'WhoopSyncStatus'
   */
  export type EnumWhoopSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WhoopSyncStatus'>
    


  /**
   * Reference to a field of type 'WhoopSyncStatus[]'
   */
  export type ListEnumWhoopSyncStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'WhoopSyncStatus[]'>
    


  /**
   * Reference to a field of type 'PostVisibility'
   */
  export type EnumPostVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostVisibility'>
    


  /**
   * Reference to a field of type 'PostVisibility[]'
   */
  export type ListEnumPostVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PostVisibility[]'>
    


  /**
   * Reference to a field of type 'ReactionType'
   */
  export type EnumReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReactionType'>
    


  /**
   * Reference to a field of type 'ReactionType[]'
   */
  export type ListEnumReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReactionType[]'>
    


  /**
   * Reference to a field of type 'EngagementEventType'
   */
  export type EnumEngagementEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EngagementEventType'>
    


  /**
   * Reference to a field of type 'EngagementEventType[]'
   */
  export type ListEnumEngagementEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EngagementEventType[]'>
    


  /**
   * Reference to a field of type 'FlagTargetType'
   */
  export type EnumFlagTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlagTargetType'>
    


  /**
   * Reference to a field of type 'FlagTargetType[]'
   */
  export type ListEnumFlagTargetTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlagTargetType[]'>
    


  /**
   * Reference to a field of type 'FlagStatus'
   */
  export type EnumFlagStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlagStatus'>
    


  /**
   * Reference to a field of type 'FlagStatus[]'
   */
  export type ListEnumFlagStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlagStatus[]'>
    


  /**
   * Reference to a field of type 'RoomStatus'
   */
  export type EnumRoomStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomStatus'>
    


  /**
   * Reference to a field of type 'RoomStatus[]'
   */
  export type ListEnumRoomStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomStatus[]'>
    


  /**
   * Reference to a field of type 'RoomMembershipRole'
   */
  export type EnumRoomMembershipRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomMembershipRole'>
    


  /**
   * Reference to a field of type 'RoomMembershipRole[]'
   */
  export type ListEnumRoomMembershipRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomMembershipRole[]'>
    


  /**
   * Reference to a field of type 'RoomMembershipStatus'
   */
  export type EnumRoomMembershipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomMembershipStatus'>
    


  /**
   * Reference to a field of type 'RoomMembershipStatus[]'
   */
  export type ListEnumRoomMembershipStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomMembershipStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringNullableFilter<"User"> | string | null
    fullName?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    whoopMemberId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    authProviders?: AuthProviderListRelationFilter
    whoopIntegration?: XOR<WhoopIntegrationNullableRelationFilter, WhoopIntegrationWhereInput> | null
    whoopLinkSessions?: WhoopLinkSessionListRelationFilter
    insights?: InsightListRelationFilter
    insightActions?: InsightActionListRelationFilter
    insightGenerationJobs?: InsightGenerationJobListRelationFilter
    biomarkerLogs?: BiomarkerLogListRelationFilter
    panelUploads?: PanelUploadListRelationFilter
    biomarkerMeasurements?: BiomarkerMeasurementListRelationFilter
    feedPosts?: FeedPostListRelationFilter
    comments?: CommentListRelationFilter
    reactions?: ReactionListRelationFilter
    engagementEvents?: EngagementEventListRelationFilter
    roomsHosted?: RoomListRelationFilter
    roomMemberships?: RoomMembershipListRelationFilter
    flagsOpened?: FlagListRelationFilter
    flagsResolved?: FlagListRelationFilter
    auditLogs?: AdminAuditLogListRelationFilter
    longevityPlans?: LongevityPlanListRelationFilter
    longevityPlanJobs?: LongevityPlanJobListRelationFilter
    aiResponseAudits?: AiResponseAuditListRelationFilter
    loginAudits?: LoginAuditListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    whoopMemberId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    authProviders?: AuthProviderOrderByRelationAggregateInput
    whoopIntegration?: WhoopIntegrationOrderByWithRelationInput
    whoopLinkSessions?: WhoopLinkSessionOrderByRelationAggregateInput
    insights?: InsightOrderByRelationAggregateInput
    insightActions?: InsightActionOrderByRelationAggregateInput
    insightGenerationJobs?: InsightGenerationJobOrderByRelationAggregateInput
    biomarkerLogs?: BiomarkerLogOrderByRelationAggregateInput
    panelUploads?: PanelUploadOrderByRelationAggregateInput
    biomarkerMeasurements?: BiomarkerMeasurementOrderByRelationAggregateInput
    feedPosts?: FeedPostOrderByRelationAggregateInput
    comments?: CommentOrderByRelationAggregateInput
    reactions?: ReactionOrderByRelationAggregateInput
    engagementEvents?: EngagementEventOrderByRelationAggregateInput
    roomsHosted?: RoomOrderByRelationAggregateInput
    roomMemberships?: RoomMembershipOrderByRelationAggregateInput
    flagsOpened?: FlagOrderByRelationAggregateInput
    flagsResolved?: FlagOrderByRelationAggregateInput
    auditLogs?: AdminAuditLogOrderByRelationAggregateInput
    longevityPlans?: LongevityPlanOrderByRelationAggregateInput
    longevityPlanJobs?: LongevityPlanJobOrderByRelationAggregateInput
    aiResponseAudits?: AiResponseAuditOrderByRelationAggregateInput
    loginAudits?: LoginAuditOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    whoopMemberId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringNullableFilter<"User"> | string | null
    fullName?: StringNullableFilter<"User"> | string | null
    role?: EnumRoleFilter<"User"> | $Enums.Role
    status?: EnumUserStatusFilter<"User"> | $Enums.UserStatus
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profile?: XOR<ProfileNullableRelationFilter, ProfileWhereInput> | null
    authProviders?: AuthProviderListRelationFilter
    whoopIntegration?: XOR<WhoopIntegrationNullableRelationFilter, WhoopIntegrationWhereInput> | null
    whoopLinkSessions?: WhoopLinkSessionListRelationFilter
    insights?: InsightListRelationFilter
    insightActions?: InsightActionListRelationFilter
    insightGenerationJobs?: InsightGenerationJobListRelationFilter
    biomarkerLogs?: BiomarkerLogListRelationFilter
    panelUploads?: PanelUploadListRelationFilter
    biomarkerMeasurements?: BiomarkerMeasurementListRelationFilter
    feedPosts?: FeedPostListRelationFilter
    comments?: CommentListRelationFilter
    reactions?: ReactionListRelationFilter
    engagementEvents?: EngagementEventListRelationFilter
    roomsHosted?: RoomListRelationFilter
    roomMemberships?: RoomMembershipListRelationFilter
    flagsOpened?: FlagListRelationFilter
    flagsResolved?: FlagListRelationFilter
    auditLogs?: AdminAuditLogListRelationFilter
    longevityPlans?: LongevityPlanListRelationFilter
    longevityPlanJobs?: LongevityPlanJobListRelationFilter
    aiResponseAudits?: AiResponseAuditListRelationFilter
    loginAudits?: LoginAuditListRelationFilter
  }, "id" | "email" | "whoopMemberId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    role?: SortOrder
    status?: SortOrder
    whoopMemberId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    fullName?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    status?: EnumUserStatusWithAggregatesFilter<"User"> | $Enums.UserStatus
    whoopMemberId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    displayName?: StringFilter<"Profile"> | string
    timezone?: StringFilter<"Profile"> | string
    baselineSurvey?: JsonNullableFilter<"Profile">
    consents?: JsonNullableFilter<"Profile">
    onboardingCompletedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    deleteRequested?: BoolFilter<"Profile"> | boolean
    deletedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    timezone?: SortOrder
    baselineSurvey?: SortOrderInput | SortOrder
    consents?: SortOrderInput | SortOrder
    onboardingCompletedAt?: SortOrderInput | SortOrder
    deleteRequested?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    displayName?: StringFilter<"Profile"> | string
    timezone?: StringFilter<"Profile"> | string
    baselineSurvey?: JsonNullableFilter<"Profile">
    consents?: JsonNullableFilter<"Profile">
    onboardingCompletedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    deleteRequested?: BoolFilter<"Profile"> | boolean
    deletedAt?: DateTimeNullableFilter<"Profile"> | Date | string | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    timezone?: SortOrder
    baselineSurvey?: SortOrderInput | SortOrder
    consents?: SortOrderInput | SortOrder
    onboardingCompletedAt?: SortOrderInput | SortOrder
    deleteRequested?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    userId?: StringWithAggregatesFilter<"Profile"> | string
    displayName?: StringWithAggregatesFilter<"Profile"> | string
    timezone?: StringWithAggregatesFilter<"Profile"> | string
    baselineSurvey?: JsonNullableWithAggregatesFilter<"Profile">
    consents?: JsonNullableWithAggregatesFilter<"Profile">
    onboardingCompletedAt?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    deleteRequested?: BoolWithAggregatesFilter<"Profile"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Profile"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type InsightWhereInput = {
    AND?: InsightWhereInput | InsightWhereInput[]
    OR?: InsightWhereInput[]
    NOT?: InsightWhereInput | InsightWhereInput[]
    id?: StringFilter<"Insight"> | string
    userId?: StringFilter<"Insight"> | string
    title?: StringFilter<"Insight"> | string
    summary?: StringFilter<"Insight"> | string
    body?: JsonNullableFilter<"Insight">
    modelUsed?: StringNullableFilter<"Insight"> | string | null
    promptMetadata?: JsonNullableFilter<"Insight">
    status?: EnumInsightStatusFilter<"Insight"> | $Enums.InsightStatus
    generatedAt?: DateTimeFilter<"Insight"> | Date | string
    createdAt?: DateTimeFilter<"Insight"> | Date | string
    updatedAt?: DateTimeFilter<"Insight"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    actions?: InsightActionListRelationFilter
    generationJobs?: InsightGenerationJobListRelationFilter
    flags?: FlagListRelationFilter
  }

  export type InsightOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    body?: SortOrderInput | SortOrder
    modelUsed?: SortOrderInput | SortOrder
    promptMetadata?: SortOrderInput | SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    actions?: InsightActionOrderByRelationAggregateInput
    generationJobs?: InsightGenerationJobOrderByRelationAggregateInput
    flags?: FlagOrderByRelationAggregateInput
  }

  export type InsightWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InsightWhereInput | InsightWhereInput[]
    OR?: InsightWhereInput[]
    NOT?: InsightWhereInput | InsightWhereInput[]
    userId?: StringFilter<"Insight"> | string
    title?: StringFilter<"Insight"> | string
    summary?: StringFilter<"Insight"> | string
    body?: JsonNullableFilter<"Insight">
    modelUsed?: StringNullableFilter<"Insight"> | string | null
    promptMetadata?: JsonNullableFilter<"Insight">
    status?: EnumInsightStatusFilter<"Insight"> | $Enums.InsightStatus
    generatedAt?: DateTimeFilter<"Insight"> | Date | string
    createdAt?: DateTimeFilter<"Insight"> | Date | string
    updatedAt?: DateTimeFilter<"Insight"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    actions?: InsightActionListRelationFilter
    generationJobs?: InsightGenerationJobListRelationFilter
    flags?: FlagListRelationFilter
  }, "id">

  export type InsightOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    body?: SortOrderInput | SortOrder
    modelUsed?: SortOrderInput | SortOrder
    promptMetadata?: SortOrderInput | SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InsightCountOrderByAggregateInput
    _max?: InsightMaxOrderByAggregateInput
    _min?: InsightMinOrderByAggregateInput
  }

  export type InsightScalarWhereWithAggregatesInput = {
    AND?: InsightScalarWhereWithAggregatesInput | InsightScalarWhereWithAggregatesInput[]
    OR?: InsightScalarWhereWithAggregatesInput[]
    NOT?: InsightScalarWhereWithAggregatesInput | InsightScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Insight"> | string
    userId?: StringWithAggregatesFilter<"Insight"> | string
    title?: StringWithAggregatesFilter<"Insight"> | string
    summary?: StringWithAggregatesFilter<"Insight"> | string
    body?: JsonNullableWithAggregatesFilter<"Insight">
    modelUsed?: StringNullableWithAggregatesFilter<"Insight"> | string | null
    promptMetadata?: JsonNullableWithAggregatesFilter<"Insight">
    status?: EnumInsightStatusWithAggregatesFilter<"Insight"> | $Enums.InsightStatus
    generatedAt?: DateTimeWithAggregatesFilter<"Insight"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Insight"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Insight"> | Date | string
  }

  export type LongevityPlanWhereInput = {
    AND?: LongevityPlanWhereInput | LongevityPlanWhereInput[]
    OR?: LongevityPlanWhereInput[]
    NOT?: LongevityPlanWhereInput | LongevityPlanWhereInput[]
    id?: StringFilter<"LongevityPlan"> | string
    userId?: StringFilter<"LongevityPlan"> | string
    status?: EnumLongevityPlanStatusFilter<"LongevityPlan"> | $Enums.LongevityPlanStatus
    title?: StringFilter<"LongevityPlan"> | string
    summary?: StringNullableFilter<"LongevityPlan"> | string | null
    focusAreas?: StringNullableListFilter<"LongevityPlan">
    sections?: JsonNullableFilter<"LongevityPlan">
    evidence?: JsonNullableFilter<"LongevityPlan">
    safetyState?: JsonNullableFilter<"LongevityPlan">
    validatedBy?: StringNullableFilter<"LongevityPlan"> | string | null
    validatedAt?: DateTimeNullableFilter<"LongevityPlan"> | Date | string | null
    requestedAt?: DateTimeFilter<"LongevityPlan"> | Date | string
    completedAt?: DateTimeNullableFilter<"LongevityPlan"> | Date | string | null
    errorCode?: StringNullableFilter<"LongevityPlan"> | string | null
    errorMessage?: StringNullableFilter<"LongevityPlan"> | string | null
    createdAt?: DateTimeFilter<"LongevityPlan"> | Date | string
    updatedAt?: DateTimeFilter<"LongevityPlan"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    jobs?: LongevityPlanJobListRelationFilter
    audits?: AiResponseAuditListRelationFilter
  }

  export type LongevityPlanOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    title?: SortOrder
    summary?: SortOrderInput | SortOrder
    focusAreas?: SortOrder
    sections?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    safetyState?: SortOrderInput | SortOrder
    validatedBy?: SortOrderInput | SortOrder
    validatedAt?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    jobs?: LongevityPlanJobOrderByRelationAggregateInput
    audits?: AiResponseAuditOrderByRelationAggregateInput
  }

  export type LongevityPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LongevityPlanWhereInput | LongevityPlanWhereInput[]
    OR?: LongevityPlanWhereInput[]
    NOT?: LongevityPlanWhereInput | LongevityPlanWhereInput[]
    userId?: StringFilter<"LongevityPlan"> | string
    status?: EnumLongevityPlanStatusFilter<"LongevityPlan"> | $Enums.LongevityPlanStatus
    title?: StringFilter<"LongevityPlan"> | string
    summary?: StringNullableFilter<"LongevityPlan"> | string | null
    focusAreas?: StringNullableListFilter<"LongevityPlan">
    sections?: JsonNullableFilter<"LongevityPlan">
    evidence?: JsonNullableFilter<"LongevityPlan">
    safetyState?: JsonNullableFilter<"LongevityPlan">
    validatedBy?: StringNullableFilter<"LongevityPlan"> | string | null
    validatedAt?: DateTimeNullableFilter<"LongevityPlan"> | Date | string | null
    requestedAt?: DateTimeFilter<"LongevityPlan"> | Date | string
    completedAt?: DateTimeNullableFilter<"LongevityPlan"> | Date | string | null
    errorCode?: StringNullableFilter<"LongevityPlan"> | string | null
    errorMessage?: StringNullableFilter<"LongevityPlan"> | string | null
    createdAt?: DateTimeFilter<"LongevityPlan"> | Date | string
    updatedAt?: DateTimeFilter<"LongevityPlan"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    jobs?: LongevityPlanJobListRelationFilter
    audits?: AiResponseAuditListRelationFilter
  }, "id">

  export type LongevityPlanOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    title?: SortOrder
    summary?: SortOrderInput | SortOrder
    focusAreas?: SortOrder
    sections?: SortOrderInput | SortOrder
    evidence?: SortOrderInput | SortOrder
    safetyState?: SortOrderInput | SortOrder
    validatedBy?: SortOrderInput | SortOrder
    validatedAt?: SortOrderInput | SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LongevityPlanCountOrderByAggregateInput
    _max?: LongevityPlanMaxOrderByAggregateInput
    _min?: LongevityPlanMinOrderByAggregateInput
  }

  export type LongevityPlanScalarWhereWithAggregatesInput = {
    AND?: LongevityPlanScalarWhereWithAggregatesInput | LongevityPlanScalarWhereWithAggregatesInput[]
    OR?: LongevityPlanScalarWhereWithAggregatesInput[]
    NOT?: LongevityPlanScalarWhereWithAggregatesInput | LongevityPlanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LongevityPlan"> | string
    userId?: StringWithAggregatesFilter<"LongevityPlan"> | string
    status?: EnumLongevityPlanStatusWithAggregatesFilter<"LongevityPlan"> | $Enums.LongevityPlanStatus
    title?: StringWithAggregatesFilter<"LongevityPlan"> | string
    summary?: StringNullableWithAggregatesFilter<"LongevityPlan"> | string | null
    focusAreas?: StringNullableListFilter<"LongevityPlan">
    sections?: JsonNullableWithAggregatesFilter<"LongevityPlan">
    evidence?: JsonNullableWithAggregatesFilter<"LongevityPlan">
    safetyState?: JsonNullableWithAggregatesFilter<"LongevityPlan">
    validatedBy?: StringNullableWithAggregatesFilter<"LongevityPlan"> | string | null
    validatedAt?: DateTimeNullableWithAggregatesFilter<"LongevityPlan"> | Date | string | null
    requestedAt?: DateTimeWithAggregatesFilter<"LongevityPlan"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"LongevityPlan"> | Date | string | null
    errorCode?: StringNullableWithAggregatesFilter<"LongevityPlan"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"LongevityPlan"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LongevityPlan"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LongevityPlan"> | Date | string
  }

  export type BiomarkerWhereInput = {
    AND?: BiomarkerWhereInput | BiomarkerWhereInput[]
    OR?: BiomarkerWhereInput[]
    NOT?: BiomarkerWhereInput | BiomarkerWhereInput[]
    id?: StringFilter<"Biomarker"> | string
    slug?: StringFilter<"Biomarker"> | string
    name?: StringFilter<"Biomarker"> | string
    unit?: StringFilter<"Biomarker"> | string
    referenceLow?: DecimalNullableFilter<"Biomarker"> | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: DecimalNullableFilter<"Biomarker"> | Decimal | DecimalJsLike | number | string | null
    source?: EnumBiomarkerSourceFilter<"Biomarker"> | $Enums.BiomarkerSource
    createdAt?: DateTimeFilter<"Biomarker"> | Date | string
    updatedAt?: DateTimeFilter<"Biomarker"> | Date | string
    logs?: BiomarkerLogListRelationFilter
    measurements?: BiomarkerMeasurementListRelationFilter
  }

  export type BiomarkerOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    referenceLow?: SortOrderInput | SortOrder
    referenceHigh?: SortOrderInput | SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    logs?: BiomarkerLogOrderByRelationAggregateInput
    measurements?: BiomarkerMeasurementOrderByRelationAggregateInput
  }

  export type BiomarkerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: BiomarkerWhereInput | BiomarkerWhereInput[]
    OR?: BiomarkerWhereInput[]
    NOT?: BiomarkerWhereInput | BiomarkerWhereInput[]
    name?: StringFilter<"Biomarker"> | string
    unit?: StringFilter<"Biomarker"> | string
    referenceLow?: DecimalNullableFilter<"Biomarker"> | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: DecimalNullableFilter<"Biomarker"> | Decimal | DecimalJsLike | number | string | null
    source?: EnumBiomarkerSourceFilter<"Biomarker"> | $Enums.BiomarkerSource
    createdAt?: DateTimeFilter<"Biomarker"> | Date | string
    updatedAt?: DateTimeFilter<"Biomarker"> | Date | string
    logs?: BiomarkerLogListRelationFilter
    measurements?: BiomarkerMeasurementListRelationFilter
  }, "id" | "slug">

  export type BiomarkerOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    referenceLow?: SortOrderInput | SortOrder
    referenceHigh?: SortOrderInput | SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BiomarkerCountOrderByAggregateInput
    _avg?: BiomarkerAvgOrderByAggregateInput
    _max?: BiomarkerMaxOrderByAggregateInput
    _min?: BiomarkerMinOrderByAggregateInput
    _sum?: BiomarkerSumOrderByAggregateInput
  }

  export type BiomarkerScalarWhereWithAggregatesInput = {
    AND?: BiomarkerScalarWhereWithAggregatesInput | BiomarkerScalarWhereWithAggregatesInput[]
    OR?: BiomarkerScalarWhereWithAggregatesInput[]
    NOT?: BiomarkerScalarWhereWithAggregatesInput | BiomarkerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Biomarker"> | string
    slug?: StringWithAggregatesFilter<"Biomarker"> | string
    name?: StringWithAggregatesFilter<"Biomarker"> | string
    unit?: StringWithAggregatesFilter<"Biomarker"> | string
    referenceLow?: DecimalNullableWithAggregatesFilter<"Biomarker"> | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: DecimalNullableWithAggregatesFilter<"Biomarker"> | Decimal | DecimalJsLike | number | string | null
    source?: EnumBiomarkerSourceWithAggregatesFilter<"Biomarker"> | $Enums.BiomarkerSource
    createdAt?: DateTimeWithAggregatesFilter<"Biomarker"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Biomarker"> | Date | string
  }

  export type BiomarkerLogWhereInput = {
    AND?: BiomarkerLogWhereInput | BiomarkerLogWhereInput[]
    OR?: BiomarkerLogWhereInput[]
    NOT?: BiomarkerLogWhereInput | BiomarkerLogWhereInput[]
    id?: StringFilter<"BiomarkerLog"> | string
    userId?: StringFilter<"BiomarkerLog"> | string
    biomarkerId?: StringFilter<"BiomarkerLog"> | string
    value?: DecimalFilter<"BiomarkerLog"> | Decimal | DecimalJsLike | number | string
    unit?: StringNullableFilter<"BiomarkerLog"> | string | null
    source?: EnumBiomarkerSourceFilter<"BiomarkerLog"> | $Enums.BiomarkerSource
    capturedAt?: DateTimeFilter<"BiomarkerLog"> | Date | string
    accepted?: BoolFilter<"BiomarkerLog"> | boolean
    flagged?: BoolFilter<"BiomarkerLog"> | boolean
    notes?: StringNullableFilter<"BiomarkerLog"> | string | null
    rawPayload?: JsonNullableFilter<"BiomarkerLog">
    createdAt?: DateTimeFilter<"BiomarkerLog"> | Date | string
    updatedAt?: DateTimeFilter<"BiomarkerLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    biomarker?: XOR<BiomarkerRelationFilter, BiomarkerWhereInput>
    flags?: FlagListRelationFilter
  }

  export type BiomarkerLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    biomarkerId?: SortOrder
    value?: SortOrder
    unit?: SortOrderInput | SortOrder
    source?: SortOrder
    capturedAt?: SortOrder
    accepted?: SortOrder
    flagged?: SortOrder
    notes?: SortOrderInput | SortOrder
    rawPayload?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    biomarker?: BiomarkerOrderByWithRelationInput
    flags?: FlagOrderByRelationAggregateInput
  }

  export type BiomarkerLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BiomarkerLogWhereInput | BiomarkerLogWhereInput[]
    OR?: BiomarkerLogWhereInput[]
    NOT?: BiomarkerLogWhereInput | BiomarkerLogWhereInput[]
    userId?: StringFilter<"BiomarkerLog"> | string
    biomarkerId?: StringFilter<"BiomarkerLog"> | string
    value?: DecimalFilter<"BiomarkerLog"> | Decimal | DecimalJsLike | number | string
    unit?: StringNullableFilter<"BiomarkerLog"> | string | null
    source?: EnumBiomarkerSourceFilter<"BiomarkerLog"> | $Enums.BiomarkerSource
    capturedAt?: DateTimeFilter<"BiomarkerLog"> | Date | string
    accepted?: BoolFilter<"BiomarkerLog"> | boolean
    flagged?: BoolFilter<"BiomarkerLog"> | boolean
    notes?: StringNullableFilter<"BiomarkerLog"> | string | null
    rawPayload?: JsonNullableFilter<"BiomarkerLog">
    createdAt?: DateTimeFilter<"BiomarkerLog"> | Date | string
    updatedAt?: DateTimeFilter<"BiomarkerLog"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    biomarker?: XOR<BiomarkerRelationFilter, BiomarkerWhereInput>
    flags?: FlagListRelationFilter
  }, "id">

  export type BiomarkerLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    biomarkerId?: SortOrder
    value?: SortOrder
    unit?: SortOrderInput | SortOrder
    source?: SortOrder
    capturedAt?: SortOrder
    accepted?: SortOrder
    flagged?: SortOrder
    notes?: SortOrderInput | SortOrder
    rawPayload?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BiomarkerLogCountOrderByAggregateInput
    _avg?: BiomarkerLogAvgOrderByAggregateInput
    _max?: BiomarkerLogMaxOrderByAggregateInput
    _min?: BiomarkerLogMinOrderByAggregateInput
    _sum?: BiomarkerLogSumOrderByAggregateInput
  }

  export type BiomarkerLogScalarWhereWithAggregatesInput = {
    AND?: BiomarkerLogScalarWhereWithAggregatesInput | BiomarkerLogScalarWhereWithAggregatesInput[]
    OR?: BiomarkerLogScalarWhereWithAggregatesInput[]
    NOT?: BiomarkerLogScalarWhereWithAggregatesInput | BiomarkerLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BiomarkerLog"> | string
    userId?: StringWithAggregatesFilter<"BiomarkerLog"> | string
    biomarkerId?: StringWithAggregatesFilter<"BiomarkerLog"> | string
    value?: DecimalWithAggregatesFilter<"BiomarkerLog"> | Decimal | DecimalJsLike | number | string
    unit?: StringNullableWithAggregatesFilter<"BiomarkerLog"> | string | null
    source?: EnumBiomarkerSourceWithAggregatesFilter<"BiomarkerLog"> | $Enums.BiomarkerSource
    capturedAt?: DateTimeWithAggregatesFilter<"BiomarkerLog"> | Date | string
    accepted?: BoolWithAggregatesFilter<"BiomarkerLog"> | boolean
    flagged?: BoolWithAggregatesFilter<"BiomarkerLog"> | boolean
    notes?: StringNullableWithAggregatesFilter<"BiomarkerLog"> | string | null
    rawPayload?: JsonNullableWithAggregatesFilter<"BiomarkerLog">
    createdAt?: DateTimeWithAggregatesFilter<"BiomarkerLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BiomarkerLog"> | Date | string
  }

  export type PanelUploadWhereInput = {
    AND?: PanelUploadWhereInput | PanelUploadWhereInput[]
    OR?: PanelUploadWhereInput[]
    NOT?: PanelUploadWhereInput | PanelUploadWhereInput[]
    id?: StringFilter<"PanelUpload"> | string
    userId?: StringFilter<"PanelUpload"> | string
    status?: EnumPanelUploadStatusFilter<"PanelUpload"> | $Enums.PanelUploadStatus
    source?: EnumPanelUploadSourceFilter<"PanelUpload"> | $Enums.PanelUploadSource
    storageKey?: StringFilter<"PanelUpload"> | string
    contentType?: StringNullableFilter<"PanelUpload"> | string | null
    pageCount?: IntNullableFilter<"PanelUpload"> | number | null
    rawMetadata?: JsonNullableFilter<"PanelUpload">
    normalizedPayload?: JsonNullableFilter<"PanelUpload">
    measurementCount?: IntFilter<"PanelUpload"> | number
    processedAt?: DateTimeNullableFilter<"PanelUpload"> | Date | string | null
    errorCode?: StringNullableFilter<"PanelUpload"> | string | null
    errorMessage?: StringNullableFilter<"PanelUpload"> | string | null
    createdAt?: DateTimeFilter<"PanelUpload"> | Date | string
    updatedAt?: DateTimeFilter<"PanelUpload"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    measurements?: BiomarkerMeasurementListRelationFilter
  }

  export type PanelUploadOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    source?: SortOrder
    storageKey?: SortOrder
    contentType?: SortOrderInput | SortOrder
    pageCount?: SortOrderInput | SortOrder
    rawMetadata?: SortOrderInput | SortOrder
    normalizedPayload?: SortOrderInput | SortOrder
    measurementCount?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    measurements?: BiomarkerMeasurementOrderByRelationAggregateInput
  }

  export type PanelUploadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PanelUploadWhereInput | PanelUploadWhereInput[]
    OR?: PanelUploadWhereInput[]
    NOT?: PanelUploadWhereInput | PanelUploadWhereInput[]
    userId?: StringFilter<"PanelUpload"> | string
    status?: EnumPanelUploadStatusFilter<"PanelUpload"> | $Enums.PanelUploadStatus
    source?: EnumPanelUploadSourceFilter<"PanelUpload"> | $Enums.PanelUploadSource
    storageKey?: StringFilter<"PanelUpload"> | string
    contentType?: StringNullableFilter<"PanelUpload"> | string | null
    pageCount?: IntNullableFilter<"PanelUpload"> | number | null
    rawMetadata?: JsonNullableFilter<"PanelUpload">
    normalizedPayload?: JsonNullableFilter<"PanelUpload">
    measurementCount?: IntFilter<"PanelUpload"> | number
    processedAt?: DateTimeNullableFilter<"PanelUpload"> | Date | string | null
    errorCode?: StringNullableFilter<"PanelUpload"> | string | null
    errorMessage?: StringNullableFilter<"PanelUpload"> | string | null
    createdAt?: DateTimeFilter<"PanelUpload"> | Date | string
    updatedAt?: DateTimeFilter<"PanelUpload"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    measurements?: BiomarkerMeasurementListRelationFilter
  }, "id">

  export type PanelUploadOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    source?: SortOrder
    storageKey?: SortOrder
    contentType?: SortOrderInput | SortOrder
    pageCount?: SortOrderInput | SortOrder
    rawMetadata?: SortOrderInput | SortOrder
    normalizedPayload?: SortOrderInput | SortOrder
    measurementCount?: SortOrder
    processedAt?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PanelUploadCountOrderByAggregateInput
    _avg?: PanelUploadAvgOrderByAggregateInput
    _max?: PanelUploadMaxOrderByAggregateInput
    _min?: PanelUploadMinOrderByAggregateInput
    _sum?: PanelUploadSumOrderByAggregateInput
  }

  export type PanelUploadScalarWhereWithAggregatesInput = {
    AND?: PanelUploadScalarWhereWithAggregatesInput | PanelUploadScalarWhereWithAggregatesInput[]
    OR?: PanelUploadScalarWhereWithAggregatesInput[]
    NOT?: PanelUploadScalarWhereWithAggregatesInput | PanelUploadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PanelUpload"> | string
    userId?: StringWithAggregatesFilter<"PanelUpload"> | string
    status?: EnumPanelUploadStatusWithAggregatesFilter<"PanelUpload"> | $Enums.PanelUploadStatus
    source?: EnumPanelUploadSourceWithAggregatesFilter<"PanelUpload"> | $Enums.PanelUploadSource
    storageKey?: StringWithAggregatesFilter<"PanelUpload"> | string
    contentType?: StringNullableWithAggregatesFilter<"PanelUpload"> | string | null
    pageCount?: IntNullableWithAggregatesFilter<"PanelUpload"> | number | null
    rawMetadata?: JsonNullableWithAggregatesFilter<"PanelUpload">
    normalizedPayload?: JsonNullableWithAggregatesFilter<"PanelUpload">
    measurementCount?: IntWithAggregatesFilter<"PanelUpload"> | number
    processedAt?: DateTimeNullableWithAggregatesFilter<"PanelUpload"> | Date | string | null
    errorCode?: StringNullableWithAggregatesFilter<"PanelUpload"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"PanelUpload"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PanelUpload"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PanelUpload"> | Date | string
  }

  export type BiomarkerMeasurementWhereInput = {
    AND?: BiomarkerMeasurementWhereInput | BiomarkerMeasurementWhereInput[]
    OR?: BiomarkerMeasurementWhereInput[]
    NOT?: BiomarkerMeasurementWhereInput | BiomarkerMeasurementWhereInput[]
    id?: StringFilter<"BiomarkerMeasurement"> | string
    userId?: StringFilter<"BiomarkerMeasurement"> | string
    biomarkerId?: StringNullableFilter<"BiomarkerMeasurement"> | string | null
    panelUploadId?: StringNullableFilter<"BiomarkerMeasurement"> | string | null
    markerName?: StringFilter<"BiomarkerMeasurement"> | string
    value?: DecimalNullableFilter<"BiomarkerMeasurement"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"BiomarkerMeasurement"> | string | null
    referenceLow?: DecimalNullableFilter<"BiomarkerMeasurement"> | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: DecimalNullableFilter<"BiomarkerMeasurement"> | Decimal | DecimalJsLike | number | string | null
    capturedAt?: DateTimeNullableFilter<"BiomarkerMeasurement"> | Date | string | null
    status?: EnumMeasurementStatusFilter<"BiomarkerMeasurement"> | $Enums.MeasurementStatus
    source?: EnumBiomarkerSourceFilter<"BiomarkerMeasurement"> | $Enums.BiomarkerSource
    confidence?: DecimalNullableFilter<"BiomarkerMeasurement"> | Decimal | DecimalJsLike | number | string | null
    flags?: JsonNullableFilter<"BiomarkerMeasurement">
    createdAt?: DateTimeFilter<"BiomarkerMeasurement"> | Date | string
    updatedAt?: DateTimeFilter<"BiomarkerMeasurement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    biomarker?: XOR<BiomarkerNullableRelationFilter, BiomarkerWhereInput> | null
    panelUpload?: XOR<PanelUploadNullableRelationFilter, PanelUploadWhereInput> | null
  }

  export type BiomarkerMeasurementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    biomarkerId?: SortOrderInput | SortOrder
    panelUploadId?: SortOrderInput | SortOrder
    markerName?: SortOrder
    value?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    referenceLow?: SortOrderInput | SortOrder
    referenceHigh?: SortOrderInput | SortOrder
    capturedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    source?: SortOrder
    confidence?: SortOrderInput | SortOrder
    flags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    biomarker?: BiomarkerOrderByWithRelationInput
    panelUpload?: PanelUploadOrderByWithRelationInput
  }

  export type BiomarkerMeasurementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BiomarkerMeasurementWhereInput | BiomarkerMeasurementWhereInput[]
    OR?: BiomarkerMeasurementWhereInput[]
    NOT?: BiomarkerMeasurementWhereInput | BiomarkerMeasurementWhereInput[]
    userId?: StringFilter<"BiomarkerMeasurement"> | string
    biomarkerId?: StringNullableFilter<"BiomarkerMeasurement"> | string | null
    panelUploadId?: StringNullableFilter<"BiomarkerMeasurement"> | string | null
    markerName?: StringFilter<"BiomarkerMeasurement"> | string
    value?: DecimalNullableFilter<"BiomarkerMeasurement"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"BiomarkerMeasurement"> | string | null
    referenceLow?: DecimalNullableFilter<"BiomarkerMeasurement"> | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: DecimalNullableFilter<"BiomarkerMeasurement"> | Decimal | DecimalJsLike | number | string | null
    capturedAt?: DateTimeNullableFilter<"BiomarkerMeasurement"> | Date | string | null
    status?: EnumMeasurementStatusFilter<"BiomarkerMeasurement"> | $Enums.MeasurementStatus
    source?: EnumBiomarkerSourceFilter<"BiomarkerMeasurement"> | $Enums.BiomarkerSource
    confidence?: DecimalNullableFilter<"BiomarkerMeasurement"> | Decimal | DecimalJsLike | number | string | null
    flags?: JsonNullableFilter<"BiomarkerMeasurement">
    createdAt?: DateTimeFilter<"BiomarkerMeasurement"> | Date | string
    updatedAt?: DateTimeFilter<"BiomarkerMeasurement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    biomarker?: XOR<BiomarkerNullableRelationFilter, BiomarkerWhereInput> | null
    panelUpload?: XOR<PanelUploadNullableRelationFilter, PanelUploadWhereInput> | null
  }, "id">

  export type BiomarkerMeasurementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    biomarkerId?: SortOrderInput | SortOrder
    panelUploadId?: SortOrderInput | SortOrder
    markerName?: SortOrder
    value?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    referenceLow?: SortOrderInput | SortOrder
    referenceHigh?: SortOrderInput | SortOrder
    capturedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    source?: SortOrder
    confidence?: SortOrderInput | SortOrder
    flags?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BiomarkerMeasurementCountOrderByAggregateInput
    _avg?: BiomarkerMeasurementAvgOrderByAggregateInput
    _max?: BiomarkerMeasurementMaxOrderByAggregateInput
    _min?: BiomarkerMeasurementMinOrderByAggregateInput
    _sum?: BiomarkerMeasurementSumOrderByAggregateInput
  }

  export type BiomarkerMeasurementScalarWhereWithAggregatesInput = {
    AND?: BiomarkerMeasurementScalarWhereWithAggregatesInput | BiomarkerMeasurementScalarWhereWithAggregatesInput[]
    OR?: BiomarkerMeasurementScalarWhereWithAggregatesInput[]
    NOT?: BiomarkerMeasurementScalarWhereWithAggregatesInput | BiomarkerMeasurementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BiomarkerMeasurement"> | string
    userId?: StringWithAggregatesFilter<"BiomarkerMeasurement"> | string
    biomarkerId?: StringNullableWithAggregatesFilter<"BiomarkerMeasurement"> | string | null
    panelUploadId?: StringNullableWithAggregatesFilter<"BiomarkerMeasurement"> | string | null
    markerName?: StringWithAggregatesFilter<"BiomarkerMeasurement"> | string
    value?: DecimalNullableWithAggregatesFilter<"BiomarkerMeasurement"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableWithAggregatesFilter<"BiomarkerMeasurement"> | string | null
    referenceLow?: DecimalNullableWithAggregatesFilter<"BiomarkerMeasurement"> | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: DecimalNullableWithAggregatesFilter<"BiomarkerMeasurement"> | Decimal | DecimalJsLike | number | string | null
    capturedAt?: DateTimeNullableWithAggregatesFilter<"BiomarkerMeasurement"> | Date | string | null
    status?: EnumMeasurementStatusWithAggregatesFilter<"BiomarkerMeasurement"> | $Enums.MeasurementStatus
    source?: EnumBiomarkerSourceWithAggregatesFilter<"BiomarkerMeasurement"> | $Enums.BiomarkerSource
    confidence?: DecimalNullableWithAggregatesFilter<"BiomarkerMeasurement"> | Decimal | DecimalJsLike | number | string | null
    flags?: JsonNullableWithAggregatesFilter<"BiomarkerMeasurement">
    createdAt?: DateTimeWithAggregatesFilter<"BiomarkerMeasurement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BiomarkerMeasurement"> | Date | string
  }

  export type AuthProviderWhereInput = {
    AND?: AuthProviderWhereInput | AuthProviderWhereInput[]
    OR?: AuthProviderWhereInput[]
    NOT?: AuthProviderWhereInput | AuthProviderWhereInput[]
    id?: StringFilter<"AuthProvider"> | string
    userId?: StringFilter<"AuthProvider"> | string
    type?: EnumAuthProviderTypeFilter<"AuthProvider"> | $Enums.AuthProviderType
    providerUserId?: StringNullableFilter<"AuthProvider"> | string | null
    accessToken?: StringNullableFilter<"AuthProvider"> | string | null
    refreshToken?: StringNullableFilter<"AuthProvider"> | string | null
    scopes?: StringNullableListFilter<"AuthProvider">
    expiresAt?: DateTimeNullableFilter<"AuthProvider"> | Date | string | null
    linkedAt?: DateTimeFilter<"AuthProvider"> | Date | string
    createdAt?: DateTimeFilter<"AuthProvider"> | Date | string
    updatedAt?: DateTimeFilter<"AuthProvider"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AuthProviderOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    providerUserId?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    scopes?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    linkedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuthProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_type?: AuthProviderUserIdTypeCompoundUniqueInput
    AND?: AuthProviderWhereInput | AuthProviderWhereInput[]
    OR?: AuthProviderWhereInput[]
    NOT?: AuthProviderWhereInput | AuthProviderWhereInput[]
    userId?: StringFilter<"AuthProvider"> | string
    type?: EnumAuthProviderTypeFilter<"AuthProvider"> | $Enums.AuthProviderType
    providerUserId?: StringNullableFilter<"AuthProvider"> | string | null
    accessToken?: StringNullableFilter<"AuthProvider"> | string | null
    refreshToken?: StringNullableFilter<"AuthProvider"> | string | null
    scopes?: StringNullableListFilter<"AuthProvider">
    expiresAt?: DateTimeNullableFilter<"AuthProvider"> | Date | string | null
    linkedAt?: DateTimeFilter<"AuthProvider"> | Date | string
    createdAt?: DateTimeFilter<"AuthProvider"> | Date | string
    updatedAt?: DateTimeFilter<"AuthProvider"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_type">

  export type AuthProviderOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    providerUserId?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    scopes?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    linkedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AuthProviderCountOrderByAggregateInput
    _max?: AuthProviderMaxOrderByAggregateInput
    _min?: AuthProviderMinOrderByAggregateInput
  }

  export type AuthProviderScalarWhereWithAggregatesInput = {
    AND?: AuthProviderScalarWhereWithAggregatesInput | AuthProviderScalarWhereWithAggregatesInput[]
    OR?: AuthProviderScalarWhereWithAggregatesInput[]
    NOT?: AuthProviderScalarWhereWithAggregatesInput | AuthProviderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuthProvider"> | string
    userId?: StringWithAggregatesFilter<"AuthProvider"> | string
    type?: EnumAuthProviderTypeWithAggregatesFilter<"AuthProvider"> | $Enums.AuthProviderType
    providerUserId?: StringNullableWithAggregatesFilter<"AuthProvider"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"AuthProvider"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"AuthProvider"> | string | null
    scopes?: StringNullableListFilter<"AuthProvider">
    expiresAt?: DateTimeNullableWithAggregatesFilter<"AuthProvider"> | Date | string | null
    linkedAt?: DateTimeWithAggregatesFilter<"AuthProvider"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"AuthProvider"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AuthProvider"> | Date | string
  }

  export type LoginAuditWhereInput = {
    AND?: LoginAuditWhereInput | LoginAuditWhereInput[]
    OR?: LoginAuditWhereInput[]
    NOT?: LoginAuditWhereInput | LoginAuditWhereInput[]
    id?: StringFilter<"LoginAudit"> | string
    userId?: StringNullableFilter<"LoginAudit"> | string | null
    email?: StringFilter<"LoginAudit"> | string
    provider?: EnumAuthProviderTypeFilter<"LoginAudit"> | $Enums.AuthProviderType
    success?: BoolFilter<"LoginAudit"> | boolean
    ipAddress?: StringNullableFilter<"LoginAudit"> | string | null
    userAgent?: StringNullableFilter<"LoginAudit"> | string | null
    failureReason?: StringNullableFilter<"LoginAudit"> | string | null
    createdAt?: DateTimeFilter<"LoginAudit"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type LoginAuditOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    email?: SortOrder
    provider?: SortOrder
    success?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LoginAuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LoginAuditWhereInput | LoginAuditWhereInput[]
    OR?: LoginAuditWhereInput[]
    NOT?: LoginAuditWhereInput | LoginAuditWhereInput[]
    userId?: StringNullableFilter<"LoginAudit"> | string | null
    email?: StringFilter<"LoginAudit"> | string
    provider?: EnumAuthProviderTypeFilter<"LoginAudit"> | $Enums.AuthProviderType
    success?: BoolFilter<"LoginAudit"> | boolean
    ipAddress?: StringNullableFilter<"LoginAudit"> | string | null
    userAgent?: StringNullableFilter<"LoginAudit"> | string | null
    failureReason?: StringNullableFilter<"LoginAudit"> | string | null
    createdAt?: DateTimeFilter<"LoginAudit"> | Date | string
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type LoginAuditOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    email?: SortOrder
    provider?: SortOrder
    success?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    failureReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LoginAuditCountOrderByAggregateInput
    _max?: LoginAuditMaxOrderByAggregateInput
    _min?: LoginAuditMinOrderByAggregateInput
  }

  export type LoginAuditScalarWhereWithAggregatesInput = {
    AND?: LoginAuditScalarWhereWithAggregatesInput | LoginAuditScalarWhereWithAggregatesInput[]
    OR?: LoginAuditScalarWhereWithAggregatesInput[]
    NOT?: LoginAuditScalarWhereWithAggregatesInput | LoginAuditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LoginAudit"> | string
    userId?: StringNullableWithAggregatesFilter<"LoginAudit"> | string | null
    email?: StringWithAggregatesFilter<"LoginAudit"> | string
    provider?: EnumAuthProviderTypeWithAggregatesFilter<"LoginAudit"> | $Enums.AuthProviderType
    success?: BoolWithAggregatesFilter<"LoginAudit"> | boolean
    ipAddress?: StringNullableWithAggregatesFilter<"LoginAudit"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"LoginAudit"> | string | null
    failureReason?: StringNullableWithAggregatesFilter<"LoginAudit"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LoginAudit"> | Date | string
  }

  export type InsightActionWhereInput = {
    AND?: InsightActionWhereInput | InsightActionWhereInput[]
    OR?: InsightActionWhereInput[]
    NOT?: InsightActionWhereInput | InsightActionWhereInput[]
    id?: StringFilter<"InsightAction"> | string
    insightId?: StringFilter<"InsightAction"> | string
    actorId?: StringNullableFilter<"InsightAction"> | string | null
    actionType?: EnumInsightActionTypeFilter<"InsightAction"> | $Enums.InsightActionType
    notes?: StringNullableFilter<"InsightAction"> | string | null
    createdAt?: DateTimeFilter<"InsightAction"> | Date | string
    insight?: XOR<InsightRelationFilter, InsightWhereInput>
    actor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type InsightActionOrderByWithRelationInput = {
    id?: SortOrder
    insightId?: SortOrder
    actorId?: SortOrderInput | SortOrder
    actionType?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    insight?: InsightOrderByWithRelationInput
    actor?: UserOrderByWithRelationInput
  }

  export type InsightActionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InsightActionWhereInput | InsightActionWhereInput[]
    OR?: InsightActionWhereInput[]
    NOT?: InsightActionWhereInput | InsightActionWhereInput[]
    insightId?: StringFilter<"InsightAction"> | string
    actorId?: StringNullableFilter<"InsightAction"> | string | null
    actionType?: EnumInsightActionTypeFilter<"InsightAction"> | $Enums.InsightActionType
    notes?: StringNullableFilter<"InsightAction"> | string | null
    createdAt?: DateTimeFilter<"InsightAction"> | Date | string
    insight?: XOR<InsightRelationFilter, InsightWhereInput>
    actor?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type InsightActionOrderByWithAggregationInput = {
    id?: SortOrder
    insightId?: SortOrder
    actorId?: SortOrderInput | SortOrder
    actionType?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: InsightActionCountOrderByAggregateInput
    _max?: InsightActionMaxOrderByAggregateInput
    _min?: InsightActionMinOrderByAggregateInput
  }

  export type InsightActionScalarWhereWithAggregatesInput = {
    AND?: InsightActionScalarWhereWithAggregatesInput | InsightActionScalarWhereWithAggregatesInput[]
    OR?: InsightActionScalarWhereWithAggregatesInput[]
    NOT?: InsightActionScalarWhereWithAggregatesInput | InsightActionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InsightAction"> | string
    insightId?: StringWithAggregatesFilter<"InsightAction"> | string
    actorId?: StringNullableWithAggregatesFilter<"InsightAction"> | string | null
    actionType?: EnumInsightActionTypeWithAggregatesFilter<"InsightAction"> | $Enums.InsightActionType
    notes?: StringNullableWithAggregatesFilter<"InsightAction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InsightAction"> | Date | string
  }

  export type InsightGenerationJobWhereInput = {
    AND?: InsightGenerationJobWhereInput | InsightGenerationJobWhereInput[]
    OR?: InsightGenerationJobWhereInput[]
    NOT?: InsightGenerationJobWhereInput | InsightGenerationJobWhereInput[]
    id?: StringFilter<"InsightGenerationJob"> | string
    insightId?: StringNullableFilter<"InsightGenerationJob"> | string | null
    requestedById?: StringNullableFilter<"InsightGenerationJob"> | string | null
    status?: EnumInsightGenerationStatusFilter<"InsightGenerationJob"> | $Enums.InsightGenerationStatus
    cloudTaskName?: StringNullableFilter<"InsightGenerationJob"> | string | null
    queue?: StringNullableFilter<"InsightGenerationJob"> | string | null
    payload?: JsonNullableFilter<"InsightGenerationJob">
    scheduledAt?: DateTimeNullableFilter<"InsightGenerationJob"> | Date | string | null
    dispatchedAt?: DateTimeNullableFilter<"InsightGenerationJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"InsightGenerationJob"> | Date | string | null
    errorCode?: StringNullableFilter<"InsightGenerationJob"> | string | null
    errorMessage?: StringNullableFilter<"InsightGenerationJob"> | string | null
    createdAt?: DateTimeFilter<"InsightGenerationJob"> | Date | string
    updatedAt?: DateTimeFilter<"InsightGenerationJob"> | Date | string
    insight?: XOR<InsightNullableRelationFilter, InsightWhereInput> | null
    requestedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    cloudTask?: XOR<CloudTaskMetadataNullableRelationFilter, CloudTaskMetadataWhereInput> | null
  }

  export type InsightGenerationJobOrderByWithRelationInput = {
    id?: SortOrder
    insightId?: SortOrderInput | SortOrder
    requestedById?: SortOrderInput | SortOrder
    status?: SortOrder
    cloudTaskName?: SortOrderInput | SortOrder
    queue?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    dispatchedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    insight?: InsightOrderByWithRelationInput
    requestedBy?: UserOrderByWithRelationInput
    cloudTask?: CloudTaskMetadataOrderByWithRelationInput
  }

  export type InsightGenerationJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InsightGenerationJobWhereInput | InsightGenerationJobWhereInput[]
    OR?: InsightGenerationJobWhereInput[]
    NOT?: InsightGenerationJobWhereInput | InsightGenerationJobWhereInput[]
    insightId?: StringNullableFilter<"InsightGenerationJob"> | string | null
    requestedById?: StringNullableFilter<"InsightGenerationJob"> | string | null
    status?: EnumInsightGenerationStatusFilter<"InsightGenerationJob"> | $Enums.InsightGenerationStatus
    cloudTaskName?: StringNullableFilter<"InsightGenerationJob"> | string | null
    queue?: StringNullableFilter<"InsightGenerationJob"> | string | null
    payload?: JsonNullableFilter<"InsightGenerationJob">
    scheduledAt?: DateTimeNullableFilter<"InsightGenerationJob"> | Date | string | null
    dispatchedAt?: DateTimeNullableFilter<"InsightGenerationJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"InsightGenerationJob"> | Date | string | null
    errorCode?: StringNullableFilter<"InsightGenerationJob"> | string | null
    errorMessage?: StringNullableFilter<"InsightGenerationJob"> | string | null
    createdAt?: DateTimeFilter<"InsightGenerationJob"> | Date | string
    updatedAt?: DateTimeFilter<"InsightGenerationJob"> | Date | string
    insight?: XOR<InsightNullableRelationFilter, InsightWhereInput> | null
    requestedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    cloudTask?: XOR<CloudTaskMetadataNullableRelationFilter, CloudTaskMetadataWhereInput> | null
  }, "id">

  export type InsightGenerationJobOrderByWithAggregationInput = {
    id?: SortOrder
    insightId?: SortOrderInput | SortOrder
    requestedById?: SortOrderInput | SortOrder
    status?: SortOrder
    cloudTaskName?: SortOrderInput | SortOrder
    queue?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    dispatchedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InsightGenerationJobCountOrderByAggregateInput
    _max?: InsightGenerationJobMaxOrderByAggregateInput
    _min?: InsightGenerationJobMinOrderByAggregateInput
  }

  export type InsightGenerationJobScalarWhereWithAggregatesInput = {
    AND?: InsightGenerationJobScalarWhereWithAggregatesInput | InsightGenerationJobScalarWhereWithAggregatesInput[]
    OR?: InsightGenerationJobScalarWhereWithAggregatesInput[]
    NOT?: InsightGenerationJobScalarWhereWithAggregatesInput | InsightGenerationJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InsightGenerationJob"> | string
    insightId?: StringNullableWithAggregatesFilter<"InsightGenerationJob"> | string | null
    requestedById?: StringNullableWithAggregatesFilter<"InsightGenerationJob"> | string | null
    status?: EnumInsightGenerationStatusWithAggregatesFilter<"InsightGenerationJob"> | $Enums.InsightGenerationStatus
    cloudTaskName?: StringNullableWithAggregatesFilter<"InsightGenerationJob"> | string | null
    queue?: StringNullableWithAggregatesFilter<"InsightGenerationJob"> | string | null
    payload?: JsonNullableWithAggregatesFilter<"InsightGenerationJob">
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"InsightGenerationJob"> | Date | string | null
    dispatchedAt?: DateTimeNullableWithAggregatesFilter<"InsightGenerationJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"InsightGenerationJob"> | Date | string | null
    errorCode?: StringNullableWithAggregatesFilter<"InsightGenerationJob"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"InsightGenerationJob"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InsightGenerationJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InsightGenerationJob"> | Date | string
  }

  export type LongevityPlanJobWhereInput = {
    AND?: LongevityPlanJobWhereInput | LongevityPlanJobWhereInput[]
    OR?: LongevityPlanJobWhereInput[]
    NOT?: LongevityPlanJobWhereInput | LongevityPlanJobWhereInput[]
    id?: StringFilter<"LongevityPlanJob"> | string
    planId?: StringNullableFilter<"LongevityPlanJob"> | string | null
    requestedById?: StringNullableFilter<"LongevityPlanJob"> | string | null
    status?: EnumLongevityPlanJobStatusFilter<"LongevityPlanJob"> | $Enums.LongevityPlanJobStatus
    cloudTaskName?: StringNullableFilter<"LongevityPlanJob"> | string | null
    queue?: StringNullableFilter<"LongevityPlanJob"> | string | null
    payload?: JsonNullableFilter<"LongevityPlanJob">
    scheduledAt?: DateTimeNullableFilter<"LongevityPlanJob"> | Date | string | null
    dispatchedAt?: DateTimeNullableFilter<"LongevityPlanJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"LongevityPlanJob"> | Date | string | null
    errorCode?: StringNullableFilter<"LongevityPlanJob"> | string | null
    errorMessage?: StringNullableFilter<"LongevityPlanJob"> | string | null
    createdAt?: DateTimeFilter<"LongevityPlanJob"> | Date | string
    updatedAt?: DateTimeFilter<"LongevityPlanJob"> | Date | string
    plan?: XOR<LongevityPlanNullableRelationFilter, LongevityPlanWhereInput> | null
    requestedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    cloudTask?: XOR<CloudTaskMetadataNullableRelationFilter, CloudTaskMetadataWhereInput> | null
  }

  export type LongevityPlanJobOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrderInput | SortOrder
    requestedById?: SortOrderInput | SortOrder
    status?: SortOrder
    cloudTaskName?: SortOrderInput | SortOrder
    queue?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    dispatchedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    plan?: LongevityPlanOrderByWithRelationInput
    requestedBy?: UserOrderByWithRelationInput
    cloudTask?: CloudTaskMetadataOrderByWithRelationInput
  }

  export type LongevityPlanJobWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LongevityPlanJobWhereInput | LongevityPlanJobWhereInput[]
    OR?: LongevityPlanJobWhereInput[]
    NOT?: LongevityPlanJobWhereInput | LongevityPlanJobWhereInput[]
    planId?: StringNullableFilter<"LongevityPlanJob"> | string | null
    requestedById?: StringNullableFilter<"LongevityPlanJob"> | string | null
    status?: EnumLongevityPlanJobStatusFilter<"LongevityPlanJob"> | $Enums.LongevityPlanJobStatus
    cloudTaskName?: StringNullableFilter<"LongevityPlanJob"> | string | null
    queue?: StringNullableFilter<"LongevityPlanJob"> | string | null
    payload?: JsonNullableFilter<"LongevityPlanJob">
    scheduledAt?: DateTimeNullableFilter<"LongevityPlanJob"> | Date | string | null
    dispatchedAt?: DateTimeNullableFilter<"LongevityPlanJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"LongevityPlanJob"> | Date | string | null
    errorCode?: StringNullableFilter<"LongevityPlanJob"> | string | null
    errorMessage?: StringNullableFilter<"LongevityPlanJob"> | string | null
    createdAt?: DateTimeFilter<"LongevityPlanJob"> | Date | string
    updatedAt?: DateTimeFilter<"LongevityPlanJob"> | Date | string
    plan?: XOR<LongevityPlanNullableRelationFilter, LongevityPlanWhereInput> | null
    requestedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    cloudTask?: XOR<CloudTaskMetadataNullableRelationFilter, CloudTaskMetadataWhereInput> | null
  }, "id">

  export type LongevityPlanJobOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrderInput | SortOrder
    requestedById?: SortOrderInput | SortOrder
    status?: SortOrder
    cloudTaskName?: SortOrderInput | SortOrder
    queue?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    dispatchedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    errorCode?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LongevityPlanJobCountOrderByAggregateInput
    _max?: LongevityPlanJobMaxOrderByAggregateInput
    _min?: LongevityPlanJobMinOrderByAggregateInput
  }

  export type LongevityPlanJobScalarWhereWithAggregatesInput = {
    AND?: LongevityPlanJobScalarWhereWithAggregatesInput | LongevityPlanJobScalarWhereWithAggregatesInput[]
    OR?: LongevityPlanJobScalarWhereWithAggregatesInput[]
    NOT?: LongevityPlanJobScalarWhereWithAggregatesInput | LongevityPlanJobScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LongevityPlanJob"> | string
    planId?: StringNullableWithAggregatesFilter<"LongevityPlanJob"> | string | null
    requestedById?: StringNullableWithAggregatesFilter<"LongevityPlanJob"> | string | null
    status?: EnumLongevityPlanJobStatusWithAggregatesFilter<"LongevityPlanJob"> | $Enums.LongevityPlanJobStatus
    cloudTaskName?: StringNullableWithAggregatesFilter<"LongevityPlanJob"> | string | null
    queue?: StringNullableWithAggregatesFilter<"LongevityPlanJob"> | string | null
    payload?: JsonNullableWithAggregatesFilter<"LongevityPlanJob">
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"LongevityPlanJob"> | Date | string | null
    dispatchedAt?: DateTimeNullableWithAggregatesFilter<"LongevityPlanJob"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"LongevityPlanJob"> | Date | string | null
    errorCode?: StringNullableWithAggregatesFilter<"LongevityPlanJob"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"LongevityPlanJob"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LongevityPlanJob"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LongevityPlanJob"> | Date | string
  }

  export type CloudTaskMetadataWhereInput = {
    AND?: CloudTaskMetadataWhereInput | CloudTaskMetadataWhereInput[]
    OR?: CloudTaskMetadataWhereInput[]
    NOT?: CloudTaskMetadataWhereInput | CloudTaskMetadataWhereInput[]
    id?: StringFilter<"CloudTaskMetadata"> | string
    taskName?: StringFilter<"CloudTaskMetadata"> | string
    queue?: StringFilter<"CloudTaskMetadata"> | string
    status?: EnumCloudTaskStatusFilter<"CloudTaskMetadata"> | $Enums.CloudTaskStatus
    jobId?: StringNullableFilter<"CloudTaskMetadata"> | string | null
    planJobId?: StringNullableFilter<"CloudTaskMetadata"> | string | null
    payload?: JsonNullableFilter<"CloudTaskMetadata">
    scheduleTime?: DateTimeNullableFilter<"CloudTaskMetadata"> | Date | string | null
    firstAttemptAt?: DateTimeNullableFilter<"CloudTaskMetadata"> | Date | string | null
    lastAttemptAt?: DateTimeNullableFilter<"CloudTaskMetadata"> | Date | string | null
    attemptCount?: IntFilter<"CloudTaskMetadata"> | number
    errorMessage?: StringNullableFilter<"CloudTaskMetadata"> | string | null
    createdAt?: DateTimeFilter<"CloudTaskMetadata"> | Date | string
    updatedAt?: DateTimeFilter<"CloudTaskMetadata"> | Date | string
    job?: XOR<InsightGenerationJobNullableRelationFilter, InsightGenerationJobWhereInput> | null
    planJob?: XOR<LongevityPlanJobNullableRelationFilter, LongevityPlanJobWhereInput> | null
  }

  export type CloudTaskMetadataOrderByWithRelationInput = {
    id?: SortOrder
    taskName?: SortOrder
    queue?: SortOrder
    status?: SortOrder
    jobId?: SortOrderInput | SortOrder
    planJobId?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    scheduleTime?: SortOrderInput | SortOrder
    firstAttemptAt?: SortOrderInput | SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    attemptCount?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    job?: InsightGenerationJobOrderByWithRelationInput
    planJob?: LongevityPlanJobOrderByWithRelationInput
  }

  export type CloudTaskMetadataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    taskName?: string
    jobId?: string
    planJobId?: string
    AND?: CloudTaskMetadataWhereInput | CloudTaskMetadataWhereInput[]
    OR?: CloudTaskMetadataWhereInput[]
    NOT?: CloudTaskMetadataWhereInput | CloudTaskMetadataWhereInput[]
    queue?: StringFilter<"CloudTaskMetadata"> | string
    status?: EnumCloudTaskStatusFilter<"CloudTaskMetadata"> | $Enums.CloudTaskStatus
    payload?: JsonNullableFilter<"CloudTaskMetadata">
    scheduleTime?: DateTimeNullableFilter<"CloudTaskMetadata"> | Date | string | null
    firstAttemptAt?: DateTimeNullableFilter<"CloudTaskMetadata"> | Date | string | null
    lastAttemptAt?: DateTimeNullableFilter<"CloudTaskMetadata"> | Date | string | null
    attemptCount?: IntFilter<"CloudTaskMetadata"> | number
    errorMessage?: StringNullableFilter<"CloudTaskMetadata"> | string | null
    createdAt?: DateTimeFilter<"CloudTaskMetadata"> | Date | string
    updatedAt?: DateTimeFilter<"CloudTaskMetadata"> | Date | string
    job?: XOR<InsightGenerationJobNullableRelationFilter, InsightGenerationJobWhereInput> | null
    planJob?: XOR<LongevityPlanJobNullableRelationFilter, LongevityPlanJobWhereInput> | null
  }, "id" | "taskName" | "jobId" | "planJobId">

  export type CloudTaskMetadataOrderByWithAggregationInput = {
    id?: SortOrder
    taskName?: SortOrder
    queue?: SortOrder
    status?: SortOrder
    jobId?: SortOrderInput | SortOrder
    planJobId?: SortOrderInput | SortOrder
    payload?: SortOrderInput | SortOrder
    scheduleTime?: SortOrderInput | SortOrder
    firstAttemptAt?: SortOrderInput | SortOrder
    lastAttemptAt?: SortOrderInput | SortOrder
    attemptCount?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CloudTaskMetadataCountOrderByAggregateInput
    _avg?: CloudTaskMetadataAvgOrderByAggregateInput
    _max?: CloudTaskMetadataMaxOrderByAggregateInput
    _min?: CloudTaskMetadataMinOrderByAggregateInput
    _sum?: CloudTaskMetadataSumOrderByAggregateInput
  }

  export type CloudTaskMetadataScalarWhereWithAggregatesInput = {
    AND?: CloudTaskMetadataScalarWhereWithAggregatesInput | CloudTaskMetadataScalarWhereWithAggregatesInput[]
    OR?: CloudTaskMetadataScalarWhereWithAggregatesInput[]
    NOT?: CloudTaskMetadataScalarWhereWithAggregatesInput | CloudTaskMetadataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CloudTaskMetadata"> | string
    taskName?: StringWithAggregatesFilter<"CloudTaskMetadata"> | string
    queue?: StringWithAggregatesFilter<"CloudTaskMetadata"> | string
    status?: EnumCloudTaskStatusWithAggregatesFilter<"CloudTaskMetadata"> | $Enums.CloudTaskStatus
    jobId?: StringNullableWithAggregatesFilter<"CloudTaskMetadata"> | string | null
    planJobId?: StringNullableWithAggregatesFilter<"CloudTaskMetadata"> | string | null
    payload?: JsonNullableWithAggregatesFilter<"CloudTaskMetadata">
    scheduleTime?: DateTimeNullableWithAggregatesFilter<"CloudTaskMetadata"> | Date | string | null
    firstAttemptAt?: DateTimeNullableWithAggregatesFilter<"CloudTaskMetadata"> | Date | string | null
    lastAttemptAt?: DateTimeNullableWithAggregatesFilter<"CloudTaskMetadata"> | Date | string | null
    attemptCount?: IntWithAggregatesFilter<"CloudTaskMetadata"> | number
    errorMessage?: StringNullableWithAggregatesFilter<"CloudTaskMetadata"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CloudTaskMetadata"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CloudTaskMetadata"> | Date | string
  }

  export type WhoopIntegrationWhereInput = {
    AND?: WhoopIntegrationWhereInput | WhoopIntegrationWhereInput[]
    OR?: WhoopIntegrationWhereInput[]
    NOT?: WhoopIntegrationWhereInput | WhoopIntegrationWhereInput[]
    id?: StringFilter<"WhoopIntegration"> | string
    userId?: StringFilter<"WhoopIntegration"> | string
    whoopUserId?: StringNullableFilter<"WhoopIntegration"> | string | null
    accessToken?: StringNullableFilter<"WhoopIntegration"> | string | null
    refreshToken?: StringNullableFilter<"WhoopIntegration"> | string | null
    expiresAt?: DateTimeNullableFilter<"WhoopIntegration"> | Date | string | null
    scope?: StringNullableListFilter<"WhoopIntegration">
    tokenKeyId?: StringNullableFilter<"WhoopIntegration"> | string | null
    tokenRotatedAt?: DateTimeNullableFilter<"WhoopIntegration"> | Date | string | null
    syncStatus?: EnumWhoopSyncStatusFilter<"WhoopIntegration"> | $Enums.WhoopSyncStatus
    lastSyncedAt?: DateTimeNullableFilter<"WhoopIntegration"> | Date | string | null
    createdAt?: DateTimeFilter<"WhoopIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"WhoopIntegration"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WhoopIntegrationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    whoopUserId?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    scope?: SortOrder
    tokenKeyId?: SortOrderInput | SortOrder
    tokenRotatedAt?: SortOrderInput | SortOrder
    syncStatus?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WhoopIntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    whoopUserId?: string
    AND?: WhoopIntegrationWhereInput | WhoopIntegrationWhereInput[]
    OR?: WhoopIntegrationWhereInput[]
    NOT?: WhoopIntegrationWhereInput | WhoopIntegrationWhereInput[]
    accessToken?: StringNullableFilter<"WhoopIntegration"> | string | null
    refreshToken?: StringNullableFilter<"WhoopIntegration"> | string | null
    expiresAt?: DateTimeNullableFilter<"WhoopIntegration"> | Date | string | null
    scope?: StringNullableListFilter<"WhoopIntegration">
    tokenKeyId?: StringNullableFilter<"WhoopIntegration"> | string | null
    tokenRotatedAt?: DateTimeNullableFilter<"WhoopIntegration"> | Date | string | null
    syncStatus?: EnumWhoopSyncStatusFilter<"WhoopIntegration"> | $Enums.WhoopSyncStatus
    lastSyncedAt?: DateTimeNullableFilter<"WhoopIntegration"> | Date | string | null
    createdAt?: DateTimeFilter<"WhoopIntegration"> | Date | string
    updatedAt?: DateTimeFilter<"WhoopIntegration"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId" | "whoopUserId">

  export type WhoopIntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    whoopUserId?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    scope?: SortOrder
    tokenKeyId?: SortOrderInput | SortOrder
    tokenRotatedAt?: SortOrderInput | SortOrder
    syncStatus?: SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: WhoopIntegrationCountOrderByAggregateInput
    _max?: WhoopIntegrationMaxOrderByAggregateInput
    _min?: WhoopIntegrationMinOrderByAggregateInput
  }

  export type WhoopIntegrationScalarWhereWithAggregatesInput = {
    AND?: WhoopIntegrationScalarWhereWithAggregatesInput | WhoopIntegrationScalarWhereWithAggregatesInput[]
    OR?: WhoopIntegrationScalarWhereWithAggregatesInput[]
    NOT?: WhoopIntegrationScalarWhereWithAggregatesInput | WhoopIntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhoopIntegration"> | string
    userId?: StringWithAggregatesFilter<"WhoopIntegration"> | string
    whoopUserId?: StringNullableWithAggregatesFilter<"WhoopIntegration"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"WhoopIntegration"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"WhoopIntegration"> | string | null
    expiresAt?: DateTimeNullableWithAggregatesFilter<"WhoopIntegration"> | Date | string | null
    scope?: StringNullableListFilter<"WhoopIntegration">
    tokenKeyId?: StringNullableWithAggregatesFilter<"WhoopIntegration"> | string | null
    tokenRotatedAt?: DateTimeNullableWithAggregatesFilter<"WhoopIntegration"> | Date | string | null
    syncStatus?: EnumWhoopSyncStatusWithAggregatesFilter<"WhoopIntegration"> | $Enums.WhoopSyncStatus
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"WhoopIntegration"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"WhoopIntegration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WhoopIntegration"> | Date | string
  }

  export type WhoopLinkSessionWhereInput = {
    AND?: WhoopLinkSessionWhereInput | WhoopLinkSessionWhereInput[]
    OR?: WhoopLinkSessionWhereInput[]
    NOT?: WhoopLinkSessionWhereInput | WhoopLinkSessionWhereInput[]
    id?: StringFilter<"WhoopLinkSession"> | string
    userId?: StringFilter<"WhoopLinkSession"> | string
    state?: StringFilter<"WhoopLinkSession"> | string
    redirectUri?: StringFilter<"WhoopLinkSession"> | string
    scope?: StringNullableListFilter<"WhoopLinkSession">
    expiresAt?: DateTimeFilter<"WhoopLinkSession"> | Date | string
    createdAt?: DateTimeFilter<"WhoopLinkSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"WhoopLinkSession"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"WhoopLinkSession"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type WhoopLinkSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    state?: SortOrder
    redirectUri?: SortOrder
    scope?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type WhoopLinkSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    state?: string
    AND?: WhoopLinkSessionWhereInput | WhoopLinkSessionWhereInput[]
    OR?: WhoopLinkSessionWhereInput[]
    NOT?: WhoopLinkSessionWhereInput | WhoopLinkSessionWhereInput[]
    userId?: StringFilter<"WhoopLinkSession"> | string
    redirectUri?: StringFilter<"WhoopLinkSession"> | string
    scope?: StringNullableListFilter<"WhoopLinkSession">
    expiresAt?: DateTimeFilter<"WhoopLinkSession"> | Date | string
    createdAt?: DateTimeFilter<"WhoopLinkSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"WhoopLinkSession"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"WhoopLinkSession"> | Date | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "state">

  export type WhoopLinkSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    state?: SortOrder
    redirectUri?: SortOrder
    scope?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    _count?: WhoopLinkSessionCountOrderByAggregateInput
    _max?: WhoopLinkSessionMaxOrderByAggregateInput
    _min?: WhoopLinkSessionMinOrderByAggregateInput
  }

  export type WhoopLinkSessionScalarWhereWithAggregatesInput = {
    AND?: WhoopLinkSessionScalarWhereWithAggregatesInput | WhoopLinkSessionScalarWhereWithAggregatesInput[]
    OR?: WhoopLinkSessionScalarWhereWithAggregatesInput[]
    NOT?: WhoopLinkSessionScalarWhereWithAggregatesInput | WhoopLinkSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WhoopLinkSession"> | string
    userId?: StringWithAggregatesFilter<"WhoopLinkSession"> | string
    state?: StringWithAggregatesFilter<"WhoopLinkSession"> | string
    redirectUri?: StringWithAggregatesFilter<"WhoopLinkSession"> | string
    scope?: StringNullableListFilter<"WhoopLinkSession">
    expiresAt?: DateTimeWithAggregatesFilter<"WhoopLinkSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"WhoopLinkSession"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"WhoopLinkSession"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"WhoopLinkSession"> | Date | string | null
  }

  export type FeedPostWhereInput = {
    AND?: FeedPostWhereInput | FeedPostWhereInput[]
    OR?: FeedPostWhereInput[]
    NOT?: FeedPostWhereInput | FeedPostWhereInput[]
    id?: StringFilter<"FeedPost"> | string
    authorId?: StringFilter<"FeedPost"> | string
    body?: StringFilter<"FeedPost"> | string
    tags?: StringNullableListFilter<"FeedPost">
    visibility?: EnumPostVisibilityFilter<"FeedPost"> | $Enums.PostVisibility
    flagged?: BoolFilter<"FeedPost"> | boolean
    reactionSummary?: JsonNullableFilter<"FeedPost">
    commentCount?: IntFilter<"FeedPost"> | number
    createdAt?: DateTimeFilter<"FeedPost"> | Date | string
    updatedAt?: DateTimeFilter<"FeedPost"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    comments?: CommentListRelationFilter
    reactions?: ReactionListRelationFilter
    flags?: FlagListRelationFilter
    engagementEvents?: EngagementEventListRelationFilter
  }

  export type FeedPostOrderByWithRelationInput = {
    id?: SortOrder
    authorId?: SortOrder
    body?: SortOrder
    tags?: SortOrder
    visibility?: SortOrder
    flagged?: SortOrder
    reactionSummary?: SortOrderInput | SortOrder
    commentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    comments?: CommentOrderByRelationAggregateInput
    reactions?: ReactionOrderByRelationAggregateInput
    flags?: FlagOrderByRelationAggregateInput
    engagementEvents?: EngagementEventOrderByRelationAggregateInput
  }

  export type FeedPostWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FeedPostWhereInput | FeedPostWhereInput[]
    OR?: FeedPostWhereInput[]
    NOT?: FeedPostWhereInput | FeedPostWhereInput[]
    authorId?: StringFilter<"FeedPost"> | string
    body?: StringFilter<"FeedPost"> | string
    tags?: StringNullableListFilter<"FeedPost">
    visibility?: EnumPostVisibilityFilter<"FeedPost"> | $Enums.PostVisibility
    flagged?: BoolFilter<"FeedPost"> | boolean
    reactionSummary?: JsonNullableFilter<"FeedPost">
    commentCount?: IntFilter<"FeedPost"> | number
    createdAt?: DateTimeFilter<"FeedPost"> | Date | string
    updatedAt?: DateTimeFilter<"FeedPost"> | Date | string
    author?: XOR<UserRelationFilter, UserWhereInput>
    comments?: CommentListRelationFilter
    reactions?: ReactionListRelationFilter
    flags?: FlagListRelationFilter
    engagementEvents?: EngagementEventListRelationFilter
  }, "id">

  export type FeedPostOrderByWithAggregationInput = {
    id?: SortOrder
    authorId?: SortOrder
    body?: SortOrder
    tags?: SortOrder
    visibility?: SortOrder
    flagged?: SortOrder
    reactionSummary?: SortOrderInput | SortOrder
    commentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FeedPostCountOrderByAggregateInput
    _avg?: FeedPostAvgOrderByAggregateInput
    _max?: FeedPostMaxOrderByAggregateInput
    _min?: FeedPostMinOrderByAggregateInput
    _sum?: FeedPostSumOrderByAggregateInput
  }

  export type FeedPostScalarWhereWithAggregatesInput = {
    AND?: FeedPostScalarWhereWithAggregatesInput | FeedPostScalarWhereWithAggregatesInput[]
    OR?: FeedPostScalarWhereWithAggregatesInput[]
    NOT?: FeedPostScalarWhereWithAggregatesInput | FeedPostScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FeedPost"> | string
    authorId?: StringWithAggregatesFilter<"FeedPost"> | string
    body?: StringWithAggregatesFilter<"FeedPost"> | string
    tags?: StringNullableListFilter<"FeedPost">
    visibility?: EnumPostVisibilityWithAggregatesFilter<"FeedPost"> | $Enums.PostVisibility
    flagged?: BoolWithAggregatesFilter<"FeedPost"> | boolean
    reactionSummary?: JsonNullableWithAggregatesFilter<"FeedPost">
    commentCount?: IntWithAggregatesFilter<"FeedPost"> | number
    createdAt?: DateTimeWithAggregatesFilter<"FeedPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FeedPost"> | Date | string
  }

  export type CommentWhereInput = {
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    id?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    body?: StringFilter<"Comment"> | string
    flagged?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<FeedPostRelationFilter, FeedPostWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    reactions?: ReactionListRelationFilter
    flags?: FlagListRelationFilter
    engagementEvents?: EngagementEventListRelationFilter
  }

  export type CommentOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    body?: SortOrder
    flagged?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: FeedPostOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
    reactions?: ReactionOrderByRelationAggregateInput
    flags?: FlagOrderByRelationAggregateInput
    engagementEvents?: EngagementEventOrderByRelationAggregateInput
  }

  export type CommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CommentWhereInput | CommentWhereInput[]
    OR?: CommentWhereInput[]
    NOT?: CommentWhereInput | CommentWhereInput[]
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    body?: StringFilter<"Comment"> | string
    flagged?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
    post?: XOR<FeedPostRelationFilter, FeedPostWhereInput>
    author?: XOR<UserRelationFilter, UserWhereInput>
    reactions?: ReactionListRelationFilter
    flags?: FlagListRelationFilter
    engagementEvents?: EngagementEventListRelationFilter
  }, "id">

  export type CommentOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    body?: SortOrder
    flagged?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CommentCountOrderByAggregateInput
    _max?: CommentMaxOrderByAggregateInput
    _min?: CommentMinOrderByAggregateInput
  }

  export type CommentScalarWhereWithAggregatesInput = {
    AND?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    OR?: CommentScalarWhereWithAggregatesInput[]
    NOT?: CommentScalarWhereWithAggregatesInput | CommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Comment"> | string
    postId?: StringWithAggregatesFilter<"Comment"> | string
    authorId?: StringWithAggregatesFilter<"Comment"> | string
    body?: StringWithAggregatesFilter<"Comment"> | string
    flagged?: BoolWithAggregatesFilter<"Comment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Comment"> | Date | string
  }

  export type ReactionWhereInput = {
    AND?: ReactionWhereInput | ReactionWhereInput[]
    OR?: ReactionWhereInput[]
    NOT?: ReactionWhereInput | ReactionWhereInput[]
    id?: StringFilter<"Reaction"> | string
    type?: EnumReactionTypeFilter<"Reaction"> | $Enums.ReactionType
    postId?: StringNullableFilter<"Reaction"> | string | null
    commentId?: StringNullableFilter<"Reaction"> | string | null
    userId?: StringFilter<"Reaction"> | string
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
    post?: XOR<FeedPostNullableRelationFilter, FeedPostWhereInput> | null
    comment?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type ReactionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    postId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    post?: FeedPostOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReactionWhereInput | ReactionWhereInput[]
    OR?: ReactionWhereInput[]
    NOT?: ReactionWhereInput | ReactionWhereInput[]
    type?: EnumReactionTypeFilter<"Reaction"> | $Enums.ReactionType
    postId?: StringNullableFilter<"Reaction"> | string | null
    commentId?: StringNullableFilter<"Reaction"> | string | null
    userId?: StringFilter<"Reaction"> | string
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
    post?: XOR<FeedPostNullableRelationFilter, FeedPostWhereInput> | null
    comment?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type ReactionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    postId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: ReactionCountOrderByAggregateInput
    _max?: ReactionMaxOrderByAggregateInput
    _min?: ReactionMinOrderByAggregateInput
  }

  export type ReactionScalarWhereWithAggregatesInput = {
    AND?: ReactionScalarWhereWithAggregatesInput | ReactionScalarWhereWithAggregatesInput[]
    OR?: ReactionScalarWhereWithAggregatesInput[]
    NOT?: ReactionScalarWhereWithAggregatesInput | ReactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Reaction"> | string
    type?: EnumReactionTypeWithAggregatesFilter<"Reaction"> | $Enums.ReactionType
    postId?: StringNullableWithAggregatesFilter<"Reaction"> | string | null
    commentId?: StringNullableWithAggregatesFilter<"Reaction"> | string | null
    userId?: StringWithAggregatesFilter<"Reaction"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Reaction"> | Date | string
  }

  export type EngagementEventWhereInput = {
    AND?: EngagementEventWhereInput | EngagementEventWhereInput[]
    OR?: EngagementEventWhereInput[]
    NOT?: EngagementEventWhereInput | EngagementEventWhereInput[]
    id?: StringFilter<"EngagementEvent"> | string
    type?: EnumEngagementEventTypeFilter<"EngagementEvent"> | $Enums.EngagementEventType
    userId?: StringFilter<"EngagementEvent"> | string
    postId?: StringNullableFilter<"EngagementEvent"> | string | null
    commentId?: StringNullableFilter<"EngagementEvent"> | string | null
    reactionType?: EnumReactionTypeNullableFilter<"EngagementEvent"> | $Enums.ReactionType | null
    occurredAt?: DateTimeFilter<"EngagementEvent"> | Date | string
    metadata?: JsonNullableFilter<"EngagementEvent">
    user?: XOR<UserRelationFilter, UserWhereInput>
    post?: XOR<FeedPostNullableRelationFilter, FeedPostWhereInput> | null
    comment?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
  }

  export type EngagementEventOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    postId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    reactionType?: SortOrderInput | SortOrder
    occurredAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    post?: FeedPostOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
  }

  export type EngagementEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EngagementEventWhereInput | EngagementEventWhereInput[]
    OR?: EngagementEventWhereInput[]
    NOT?: EngagementEventWhereInput | EngagementEventWhereInput[]
    type?: EnumEngagementEventTypeFilter<"EngagementEvent"> | $Enums.EngagementEventType
    userId?: StringFilter<"EngagementEvent"> | string
    postId?: StringNullableFilter<"EngagementEvent"> | string | null
    commentId?: StringNullableFilter<"EngagementEvent"> | string | null
    reactionType?: EnumReactionTypeNullableFilter<"EngagementEvent"> | $Enums.ReactionType | null
    occurredAt?: DateTimeFilter<"EngagementEvent"> | Date | string
    metadata?: JsonNullableFilter<"EngagementEvent">
    user?: XOR<UserRelationFilter, UserWhereInput>
    post?: XOR<FeedPostNullableRelationFilter, FeedPostWhereInput> | null
    comment?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
  }, "id">

  export type EngagementEventOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    postId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    reactionType?: SortOrderInput | SortOrder
    occurredAt?: SortOrder
    metadata?: SortOrderInput | SortOrder
    _count?: EngagementEventCountOrderByAggregateInput
    _max?: EngagementEventMaxOrderByAggregateInput
    _min?: EngagementEventMinOrderByAggregateInput
  }

  export type EngagementEventScalarWhereWithAggregatesInput = {
    AND?: EngagementEventScalarWhereWithAggregatesInput | EngagementEventScalarWhereWithAggregatesInput[]
    OR?: EngagementEventScalarWhereWithAggregatesInput[]
    NOT?: EngagementEventScalarWhereWithAggregatesInput | EngagementEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EngagementEvent"> | string
    type?: EnumEngagementEventTypeWithAggregatesFilter<"EngagementEvent"> | $Enums.EngagementEventType
    userId?: StringWithAggregatesFilter<"EngagementEvent"> | string
    postId?: StringNullableWithAggregatesFilter<"EngagementEvent"> | string | null
    commentId?: StringNullableWithAggregatesFilter<"EngagementEvent"> | string | null
    reactionType?: EnumReactionTypeNullableWithAggregatesFilter<"EngagementEvent"> | $Enums.ReactionType | null
    occurredAt?: DateTimeWithAggregatesFilter<"EngagementEvent"> | Date | string
    metadata?: JsonNullableWithAggregatesFilter<"EngagementEvent">
  }

  export type FlagWhereInput = {
    AND?: FlagWhereInput | FlagWhereInput[]
    OR?: FlagWhereInput[]
    NOT?: FlagWhereInput | FlagWhereInput[]
    id?: StringFilter<"Flag"> | string
    targetType?: EnumFlagTargetTypeFilter<"Flag"> | $Enums.FlagTargetType
    status?: EnumFlagStatusFilter<"Flag"> | $Enums.FlagStatus
    reason?: StringFilter<"Flag"> | string
    postId?: StringNullableFilter<"Flag"> | string | null
    commentId?: StringNullableFilter<"Flag"> | string | null
    insightId?: StringNullableFilter<"Flag"> | string | null
    biomarkerLogId?: StringNullableFilter<"Flag"> | string | null
    openedById?: StringFilter<"Flag"> | string
    resolvedById?: StringNullableFilter<"Flag"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Flag"> | Date | string | null
    auditTrail?: JsonNullableFilter<"Flag">
    createdAt?: DateTimeFilter<"Flag"> | Date | string
    updatedAt?: DateTimeFilter<"Flag"> | Date | string
    post?: XOR<FeedPostNullableRelationFilter, FeedPostWhereInput> | null
    comment?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    insight?: XOR<InsightNullableRelationFilter, InsightWhereInput> | null
    biomarkerLog?: XOR<BiomarkerLogNullableRelationFilter, BiomarkerLogWhereInput> | null
    openedBy?: XOR<UserRelationFilter, UserWhereInput>
    resolvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type FlagOrderByWithRelationInput = {
    id?: SortOrder
    targetType?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    postId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    insightId?: SortOrderInput | SortOrder
    biomarkerLogId?: SortOrderInput | SortOrder
    openedById?: SortOrder
    resolvedById?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    auditTrail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: FeedPostOrderByWithRelationInput
    comment?: CommentOrderByWithRelationInput
    insight?: InsightOrderByWithRelationInput
    biomarkerLog?: BiomarkerLogOrderByWithRelationInput
    openedBy?: UserOrderByWithRelationInput
    resolvedBy?: UserOrderByWithRelationInput
  }

  export type FlagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FlagWhereInput | FlagWhereInput[]
    OR?: FlagWhereInput[]
    NOT?: FlagWhereInput | FlagWhereInput[]
    targetType?: EnumFlagTargetTypeFilter<"Flag"> | $Enums.FlagTargetType
    status?: EnumFlagStatusFilter<"Flag"> | $Enums.FlagStatus
    reason?: StringFilter<"Flag"> | string
    postId?: StringNullableFilter<"Flag"> | string | null
    commentId?: StringNullableFilter<"Flag"> | string | null
    insightId?: StringNullableFilter<"Flag"> | string | null
    biomarkerLogId?: StringNullableFilter<"Flag"> | string | null
    openedById?: StringFilter<"Flag"> | string
    resolvedById?: StringNullableFilter<"Flag"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Flag"> | Date | string | null
    auditTrail?: JsonNullableFilter<"Flag">
    createdAt?: DateTimeFilter<"Flag"> | Date | string
    updatedAt?: DateTimeFilter<"Flag"> | Date | string
    post?: XOR<FeedPostNullableRelationFilter, FeedPostWhereInput> | null
    comment?: XOR<CommentNullableRelationFilter, CommentWhereInput> | null
    insight?: XOR<InsightNullableRelationFilter, InsightWhereInput> | null
    biomarkerLog?: XOR<BiomarkerLogNullableRelationFilter, BiomarkerLogWhereInput> | null
    openedBy?: XOR<UserRelationFilter, UserWhereInput>
    resolvedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type FlagOrderByWithAggregationInput = {
    id?: SortOrder
    targetType?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    postId?: SortOrderInput | SortOrder
    commentId?: SortOrderInput | SortOrder
    insightId?: SortOrderInput | SortOrder
    biomarkerLogId?: SortOrderInput | SortOrder
    openedById?: SortOrder
    resolvedById?: SortOrderInput | SortOrder
    resolvedAt?: SortOrderInput | SortOrder
    auditTrail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FlagCountOrderByAggregateInput
    _max?: FlagMaxOrderByAggregateInput
    _min?: FlagMinOrderByAggregateInput
  }

  export type FlagScalarWhereWithAggregatesInput = {
    AND?: FlagScalarWhereWithAggregatesInput | FlagScalarWhereWithAggregatesInput[]
    OR?: FlagScalarWhereWithAggregatesInput[]
    NOT?: FlagScalarWhereWithAggregatesInput | FlagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Flag"> | string
    targetType?: EnumFlagTargetTypeWithAggregatesFilter<"Flag"> | $Enums.FlagTargetType
    status?: EnumFlagStatusWithAggregatesFilter<"Flag"> | $Enums.FlagStatus
    reason?: StringWithAggregatesFilter<"Flag"> | string
    postId?: StringNullableWithAggregatesFilter<"Flag"> | string | null
    commentId?: StringNullableWithAggregatesFilter<"Flag"> | string | null
    insightId?: StringNullableWithAggregatesFilter<"Flag"> | string | null
    biomarkerLogId?: StringNullableWithAggregatesFilter<"Flag"> | string | null
    openedById?: StringWithAggregatesFilter<"Flag"> | string
    resolvedById?: StringNullableWithAggregatesFilter<"Flag"> | string | null
    resolvedAt?: DateTimeNullableWithAggregatesFilter<"Flag"> | Date | string | null
    auditTrail?: JsonNullableWithAggregatesFilter<"Flag">
    createdAt?: DateTimeWithAggregatesFilter<"Flag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Flag"> | Date | string
  }

  export type AdminAuditLogWhereInput = {
    AND?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    OR?: AdminAuditLogWhereInput[]
    NOT?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    id?: StringFilter<"AdminAuditLog"> | string
    actorId?: StringFilter<"AdminAuditLog"> | string
    action?: StringFilter<"AdminAuditLog"> | string
    targetType?: StringFilter<"AdminAuditLog"> | string
    targetId?: StringNullableFilter<"AdminAuditLog"> | string | null
    metadata?: JsonNullableFilter<"AdminAuditLog">
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
    actor?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type AdminAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    actor?: UserOrderByWithRelationInput
  }

  export type AdminAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    OR?: AdminAuditLogWhereInput[]
    NOT?: AdminAuditLogWhereInput | AdminAuditLogWhereInput[]
    actorId?: StringFilter<"AdminAuditLog"> | string
    action?: StringFilter<"AdminAuditLog"> | string
    targetType?: StringFilter<"AdminAuditLog"> | string
    targetId?: StringNullableFilter<"AdminAuditLog"> | string | null
    metadata?: JsonNullableFilter<"AdminAuditLog">
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
    actor?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type AdminAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AdminAuditLogCountOrderByAggregateInput
    _max?: AdminAuditLogMaxOrderByAggregateInput
    _min?: AdminAuditLogMinOrderByAggregateInput
  }

  export type AdminAuditLogScalarWhereWithAggregatesInput = {
    AND?: AdminAuditLogScalarWhereWithAggregatesInput | AdminAuditLogScalarWhereWithAggregatesInput[]
    OR?: AdminAuditLogScalarWhereWithAggregatesInput[]
    NOT?: AdminAuditLogScalarWhereWithAggregatesInput | AdminAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    actorId?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    action?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    targetType?: StringWithAggregatesFilter<"AdminAuditLog"> | string
    targetId?: StringNullableWithAggregatesFilter<"AdminAuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AdminAuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AdminAuditLog"> | Date | string
  }

  export type AiResponseAuditWhereInput = {
    AND?: AiResponseAuditWhereInput | AiResponseAuditWhereInput[]
    OR?: AiResponseAuditWhereInput[]
    NOT?: AiResponseAuditWhereInput | AiResponseAuditWhereInput[]
    id?: StringFilter<"AiResponseAudit"> | string
    planId?: StringNullableFilter<"AiResponseAudit"> | string | null
    userId?: StringNullableFilter<"AiResponseAudit"> | string | null
    provider?: StringFilter<"AiResponseAudit"> | string
    model?: StringNullableFilter<"AiResponseAudit"> | string | null
    role?: StringNullableFilter<"AiResponseAudit"> | string | null
    prompt?: JsonNullableFilter<"AiResponseAudit">
    response?: JsonNullableFilter<"AiResponseAudit">
    createdAt?: DateTimeFilter<"AiResponseAudit"> | Date | string
    plan?: XOR<LongevityPlanNullableRelationFilter, LongevityPlanWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AiResponseAuditOrderByWithRelationInput = {
    id?: SortOrder
    planId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    provider?: SortOrder
    model?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    prompt?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    plan?: LongevityPlanOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type AiResponseAuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AiResponseAuditWhereInput | AiResponseAuditWhereInput[]
    OR?: AiResponseAuditWhereInput[]
    NOT?: AiResponseAuditWhereInput | AiResponseAuditWhereInput[]
    planId?: StringNullableFilter<"AiResponseAudit"> | string | null
    userId?: StringNullableFilter<"AiResponseAudit"> | string | null
    provider?: StringFilter<"AiResponseAudit"> | string
    model?: StringNullableFilter<"AiResponseAudit"> | string | null
    role?: StringNullableFilter<"AiResponseAudit"> | string | null
    prompt?: JsonNullableFilter<"AiResponseAudit">
    response?: JsonNullableFilter<"AiResponseAudit">
    createdAt?: DateTimeFilter<"AiResponseAudit"> | Date | string
    plan?: XOR<LongevityPlanNullableRelationFilter, LongevityPlanWhereInput> | null
    user?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AiResponseAuditOrderByWithAggregationInput = {
    id?: SortOrder
    planId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    provider?: SortOrder
    model?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    prompt?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AiResponseAuditCountOrderByAggregateInput
    _max?: AiResponseAuditMaxOrderByAggregateInput
    _min?: AiResponseAuditMinOrderByAggregateInput
  }

  export type AiResponseAuditScalarWhereWithAggregatesInput = {
    AND?: AiResponseAuditScalarWhereWithAggregatesInput | AiResponseAuditScalarWhereWithAggregatesInput[]
    OR?: AiResponseAuditScalarWhereWithAggregatesInput[]
    NOT?: AiResponseAuditScalarWhereWithAggregatesInput | AiResponseAuditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AiResponseAudit"> | string
    planId?: StringNullableWithAggregatesFilter<"AiResponseAudit"> | string | null
    userId?: StringNullableWithAggregatesFilter<"AiResponseAudit"> | string | null
    provider?: StringWithAggregatesFilter<"AiResponseAudit"> | string
    model?: StringNullableWithAggregatesFilter<"AiResponseAudit"> | string | null
    role?: StringNullableWithAggregatesFilter<"AiResponseAudit"> | string | null
    prompt?: JsonNullableWithAggregatesFilter<"AiResponseAudit">
    response?: JsonNullableWithAggregatesFilter<"AiResponseAudit">
    createdAt?: DateTimeWithAggregatesFilter<"AiResponseAudit"> | Date | string
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: StringFilter<"Room"> | string
    name?: StringNullableFilter<"Room"> | string | null
    inviteCode?: StringFilter<"Room"> | string
    status?: EnumRoomStatusFilter<"Room"> | $Enums.RoomStatus
    capacity?: IntFilter<"Room"> | number
    hostId?: StringFilter<"Room"> | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    host?: XOR<UserRelationFilter, UserWhereInput>
    memberships?: RoomMembershipListRelationFilter
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    inviteCode?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    hostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    host?: UserOrderByWithRelationInput
    memberships?: RoomMembershipOrderByRelationAggregateInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    inviteCode?: string
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    name?: StringNullableFilter<"Room"> | string | null
    status?: EnumRoomStatusFilter<"Room"> | $Enums.RoomStatus
    capacity?: IntFilter<"Room"> | number
    hostId?: StringFilter<"Room"> | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    host?: XOR<UserRelationFilter, UserWhereInput>
    memberships?: RoomMembershipListRelationFilter
  }, "id" | "inviteCode">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    inviteCode?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    hostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _avg?: RoomAvgOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
    _sum?: RoomSumOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Room"> | string
    name?: StringNullableWithAggregatesFilter<"Room"> | string | null
    inviteCode?: StringWithAggregatesFilter<"Room"> | string
    status?: EnumRoomStatusWithAggregatesFilter<"Room"> | $Enums.RoomStatus
    capacity?: IntWithAggregatesFilter<"Room"> | number
    hostId?: StringWithAggregatesFilter<"Room"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
  }

  export type RoomMembershipWhereInput = {
    AND?: RoomMembershipWhereInput | RoomMembershipWhereInput[]
    OR?: RoomMembershipWhereInput[]
    NOT?: RoomMembershipWhereInput | RoomMembershipWhereInput[]
    id?: StringFilter<"RoomMembership"> | string
    roomId?: StringFilter<"RoomMembership"> | string
    userId?: StringFilter<"RoomMembership"> | string
    role?: EnumRoomMembershipRoleFilter<"RoomMembership"> | $Enums.RoomMembershipRole
    status?: EnumRoomMembershipStatusFilter<"RoomMembership"> | $Enums.RoomMembershipStatus
    joinedAt?: DateTimeFilter<"RoomMembership"> | Date | string
    leftAt?: DateTimeNullableFilter<"RoomMembership"> | Date | string | null
    lastSeenAt?: DateTimeNullableFilter<"RoomMembership"> | Date | string | null
    reconnectToken?: StringNullableFilter<"RoomMembership"> | string | null
    createdAt?: DateTimeFilter<"RoomMembership"> | Date | string
    updatedAt?: DateTimeFilter<"RoomMembership"> | Date | string
    room?: XOR<RoomRelationFilter, RoomWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RoomMembershipOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    lastSeenAt?: SortOrderInput | SortOrder
    reconnectToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    room?: RoomOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type RoomMembershipWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roomId_userId?: RoomMembershipRoomIdUserIdCompoundUniqueInput
    AND?: RoomMembershipWhereInput | RoomMembershipWhereInput[]
    OR?: RoomMembershipWhereInput[]
    NOT?: RoomMembershipWhereInput | RoomMembershipWhereInput[]
    roomId?: StringFilter<"RoomMembership"> | string
    userId?: StringFilter<"RoomMembership"> | string
    role?: EnumRoomMembershipRoleFilter<"RoomMembership"> | $Enums.RoomMembershipRole
    status?: EnumRoomMembershipStatusFilter<"RoomMembership"> | $Enums.RoomMembershipStatus
    joinedAt?: DateTimeFilter<"RoomMembership"> | Date | string
    leftAt?: DateTimeNullableFilter<"RoomMembership"> | Date | string | null
    lastSeenAt?: DateTimeNullableFilter<"RoomMembership"> | Date | string | null
    reconnectToken?: StringNullableFilter<"RoomMembership"> | string | null
    createdAt?: DateTimeFilter<"RoomMembership"> | Date | string
    updatedAt?: DateTimeFilter<"RoomMembership"> | Date | string
    room?: XOR<RoomRelationFilter, RoomWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "roomId_userId">

  export type RoomMembershipOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    lastSeenAt?: SortOrderInput | SortOrder
    reconnectToken?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomMembershipCountOrderByAggregateInput
    _max?: RoomMembershipMaxOrderByAggregateInput
    _min?: RoomMembershipMinOrderByAggregateInput
  }

  export type RoomMembershipScalarWhereWithAggregatesInput = {
    AND?: RoomMembershipScalarWhereWithAggregatesInput | RoomMembershipScalarWhereWithAggregatesInput[]
    OR?: RoomMembershipScalarWhereWithAggregatesInput[]
    NOT?: RoomMembershipScalarWhereWithAggregatesInput | RoomMembershipScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoomMembership"> | string
    roomId?: StringWithAggregatesFilter<"RoomMembership"> | string
    userId?: StringWithAggregatesFilter<"RoomMembership"> | string
    role?: EnumRoomMembershipRoleWithAggregatesFilter<"RoomMembership"> | $Enums.RoomMembershipRole
    status?: EnumRoomMembershipStatusWithAggregatesFilter<"RoomMembership"> | $Enums.RoomMembershipStatus
    joinedAt?: DateTimeWithAggregatesFilter<"RoomMembership"> | Date | string
    leftAt?: DateTimeNullableWithAggregatesFilter<"RoomMembership"> | Date | string | null
    lastSeenAt?: DateTimeNullableWithAggregatesFilter<"RoomMembership"> | Date | string | null
    reconnectToken?: StringNullableWithAggregatesFilter<"RoomMembership"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RoomMembership"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoomMembership"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    displayName: string
    timezone: string
    baselineSurvey?: NullableJsonNullValueInput | InputJsonValue
    consents?: NullableJsonNullValueInput | InputJsonValue
    onboardingCompletedAt?: Date | string | null
    deleteRequested?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    displayName: string
    timezone: string
    baselineSurvey?: NullableJsonNullValueInput | InputJsonValue
    consents?: NullableJsonNullValueInput | InputJsonValue
    onboardingCompletedAt?: Date | string | null
    deleteRequested?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    baselineSurvey?: NullableJsonNullValueInput | InputJsonValue
    consents?: NullableJsonNullValueInput | InputJsonValue
    onboardingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleteRequested?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    baselineSurvey?: NullableJsonNullValueInput | InputJsonValue
    consents?: NullableJsonNullValueInput | InputJsonValue
    onboardingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleteRequested?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    displayName: string
    timezone: string
    baselineSurvey?: NullableJsonNullValueInput | InputJsonValue
    consents?: NullableJsonNullValueInput | InputJsonValue
    onboardingCompletedAt?: Date | string | null
    deleteRequested?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    baselineSurvey?: NullableJsonNullValueInput | InputJsonValue
    consents?: NullableJsonNullValueInput | InputJsonValue
    onboardingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleteRequested?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    baselineSurvey?: NullableJsonNullValueInput | InputJsonValue
    consents?: NullableJsonNullValueInput | InputJsonValue
    onboardingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleteRequested?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightCreateInput = {
    id?: string
    title: string
    summary: string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InsightStatus
    generatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInsightsInput
    actions?: InsightActionCreateNestedManyWithoutInsightInput
    generationJobs?: InsightGenerationJobCreateNestedManyWithoutInsightInput
    flags?: FlagCreateNestedManyWithoutInsightInput
  }

  export type InsightUncheckedCreateInput = {
    id?: string
    userId: string
    title: string
    summary: string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InsightStatus
    generatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: InsightActionUncheckedCreateNestedManyWithoutInsightInput
    generationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutInsightInput
    flags?: FlagUncheckedCreateNestedManyWithoutInsightInput
  }

  export type InsightUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInsightsNestedInput
    actions?: InsightActionUpdateManyWithoutInsightNestedInput
    generationJobs?: InsightGenerationJobUpdateManyWithoutInsightNestedInput
    flags?: FlagUpdateManyWithoutInsightNestedInput
  }

  export type InsightUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: InsightActionUncheckedUpdateManyWithoutInsightNestedInput
    generationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutInsightNestedInput
    flags?: FlagUncheckedUpdateManyWithoutInsightNestedInput
  }

  export type InsightCreateManyInput = {
    id?: string
    userId: string
    title: string
    summary: string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InsightStatus
    generatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsightUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LongevityPlanCreateInput = {
    id?: string
    status?: $Enums.LongevityPlanStatus
    title: string
    summary?: string | null
    focusAreas?: LongevityPlanCreatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: string | null
    validatedAt?: Date | string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLongevityPlansInput
    jobs?: LongevityPlanJobCreateNestedManyWithoutPlanInput
    audits?: AiResponseAuditCreateNestedManyWithoutPlanInput
  }

  export type LongevityPlanUncheckedCreateInput = {
    id?: string
    userId: string
    status?: $Enums.LongevityPlanStatus
    title: string
    summary?: string | null
    focusAreas?: LongevityPlanCreatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: string | null
    validatedAt?: Date | string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutPlanInput
    audits?: AiResponseAuditUncheckedCreateNestedManyWithoutPlanInput
  }

  export type LongevityPlanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLongevityPlanStatusFieldUpdateOperationsInput | $Enums.LongevityPlanStatus
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    focusAreas?: LongevityPlanUpdatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLongevityPlansNestedInput
    jobs?: LongevityPlanJobUpdateManyWithoutPlanNestedInput
    audits?: AiResponseAuditUpdateManyWithoutPlanNestedInput
  }

  export type LongevityPlanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumLongevityPlanStatusFieldUpdateOperationsInput | $Enums.LongevityPlanStatus
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    focusAreas?: LongevityPlanUpdatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: LongevityPlanJobUncheckedUpdateManyWithoutPlanNestedInput
    audits?: AiResponseAuditUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type LongevityPlanCreateManyInput = {
    id?: string
    userId: string
    status?: $Enums.LongevityPlanStatus
    title: string
    summary?: string | null
    focusAreas?: LongevityPlanCreatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: string | null
    validatedAt?: Date | string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LongevityPlanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLongevityPlanStatusFieldUpdateOperationsInput | $Enums.LongevityPlanStatus
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    focusAreas?: LongevityPlanUpdatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LongevityPlanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumLongevityPlanStatusFieldUpdateOperationsInput | $Enums.LongevityPlanStatus
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    focusAreas?: LongevityPlanUpdatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerCreateInput = {
    id?: string
    slug: string
    name: string
    unit: string
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    source: $Enums.BiomarkerSource
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: BiomarkerLogCreateNestedManyWithoutBiomarkerInput
    measurements?: BiomarkerMeasurementCreateNestedManyWithoutBiomarkerInput
  }

  export type BiomarkerUncheckedCreateInput = {
    id?: string
    slug: string
    name: string
    unit: string
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    source: $Enums.BiomarkerSource
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: BiomarkerLogUncheckedCreateNestedManyWithoutBiomarkerInput
    measurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutBiomarkerInput
  }

  export type BiomarkerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: BiomarkerLogUpdateManyWithoutBiomarkerNestedInput
    measurements?: BiomarkerMeasurementUpdateManyWithoutBiomarkerNestedInput
  }

  export type BiomarkerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: BiomarkerLogUncheckedUpdateManyWithoutBiomarkerNestedInput
    measurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutBiomarkerNestedInput
  }

  export type BiomarkerCreateManyInput = {
    id?: string
    slug: string
    name: string
    unit: string
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    source: $Enums.BiomarkerSource
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiomarkerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerLogCreateInput = {
    id?: string
    value: Decimal | DecimalJsLike | number | string
    unit?: string | null
    source?: $Enums.BiomarkerSource
    capturedAt: Date | string
    accepted?: boolean
    flagged?: boolean
    notes?: string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBiomarkerLogsInput
    biomarker: BiomarkerCreateNestedOneWithoutLogsInput
    flags?: FlagCreateNestedManyWithoutBiomarkerLogInput
  }

  export type BiomarkerLogUncheckedCreateInput = {
    id?: string
    userId: string
    biomarkerId: string
    value: Decimal | DecimalJsLike | number | string
    unit?: string | null
    source?: $Enums.BiomarkerSource
    capturedAt: Date | string
    accepted?: boolean
    flagged?: boolean
    notes?: string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    flags?: FlagUncheckedCreateNestedManyWithoutBiomarkerLogInput
  }

  export type BiomarkerLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    flagged?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBiomarkerLogsNestedInput
    biomarker?: BiomarkerUpdateOneRequiredWithoutLogsNestedInput
    flags?: FlagUpdateManyWithoutBiomarkerLogNestedInput
  }

  export type BiomarkerLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    biomarkerId?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    flagged?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flags?: FlagUncheckedUpdateManyWithoutBiomarkerLogNestedInput
  }

  export type BiomarkerLogCreateManyInput = {
    id?: string
    userId: string
    biomarkerId: string
    value: Decimal | DecimalJsLike | number | string
    unit?: string | null
    source?: $Enums.BiomarkerSource
    capturedAt: Date | string
    accepted?: boolean
    flagged?: boolean
    notes?: string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiomarkerLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    flagged?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    biomarkerId?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    flagged?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PanelUploadCreateInput = {
    id?: string
    status?: $Enums.PanelUploadStatus
    source?: $Enums.PanelUploadSource
    storageKey: string
    contentType?: string | null
    pageCount?: number | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    normalizedPayload?: NullableJsonNullValueInput | InputJsonValue
    measurementCount?: number
    processedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPanelUploadsInput
    measurements?: BiomarkerMeasurementCreateNestedManyWithoutPanelUploadInput
  }

  export type PanelUploadUncheckedCreateInput = {
    id?: string
    userId: string
    status?: $Enums.PanelUploadStatus
    source?: $Enums.PanelUploadSource
    storageKey: string
    contentType?: string | null
    pageCount?: number | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    normalizedPayload?: NullableJsonNullValueInput | InputJsonValue
    measurementCount?: number
    processedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    measurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutPanelUploadInput
  }

  export type PanelUploadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPanelUploadStatusFieldUpdateOperationsInput | $Enums.PanelUploadStatus
    source?: EnumPanelUploadSourceFieldUpdateOperationsInput | $Enums.PanelUploadSource
    storageKey?: StringFieldUpdateOperationsInput | string
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    normalizedPayload?: NullableJsonNullValueInput | InputJsonValue
    measurementCount?: IntFieldUpdateOperationsInput | number
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPanelUploadsNestedInput
    measurements?: BiomarkerMeasurementUpdateManyWithoutPanelUploadNestedInput
  }

  export type PanelUploadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumPanelUploadStatusFieldUpdateOperationsInput | $Enums.PanelUploadStatus
    source?: EnumPanelUploadSourceFieldUpdateOperationsInput | $Enums.PanelUploadSource
    storageKey?: StringFieldUpdateOperationsInput | string
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    normalizedPayload?: NullableJsonNullValueInput | InputJsonValue
    measurementCount?: IntFieldUpdateOperationsInput | number
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    measurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutPanelUploadNestedInput
  }

  export type PanelUploadCreateManyInput = {
    id?: string
    userId: string
    status?: $Enums.PanelUploadStatus
    source?: $Enums.PanelUploadSource
    storageKey: string
    contentType?: string | null
    pageCount?: number | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    normalizedPayload?: NullableJsonNullValueInput | InputJsonValue
    measurementCount?: number
    processedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PanelUploadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPanelUploadStatusFieldUpdateOperationsInput | $Enums.PanelUploadStatus
    source?: EnumPanelUploadSourceFieldUpdateOperationsInput | $Enums.PanelUploadSource
    storageKey?: StringFieldUpdateOperationsInput | string
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    normalizedPayload?: NullableJsonNullValueInput | InputJsonValue
    measurementCount?: IntFieldUpdateOperationsInput | number
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PanelUploadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumPanelUploadStatusFieldUpdateOperationsInput | $Enums.PanelUploadStatus
    source?: EnumPanelUploadSourceFieldUpdateOperationsInput | $Enums.PanelUploadSource
    storageKey?: StringFieldUpdateOperationsInput | string
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    normalizedPayload?: NullableJsonNullValueInput | InputJsonValue
    measurementCount?: IntFieldUpdateOperationsInput | number
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerMeasurementCreateInput = {
    id?: string
    markerName: string
    value?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    capturedAt?: Date | string | null
    status?: $Enums.MeasurementStatus
    source?: $Enums.BiomarkerSource
    confidence?: Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBiomarkerMeasurementsInput
    biomarker?: BiomarkerCreateNestedOneWithoutMeasurementsInput
    panelUpload?: PanelUploadCreateNestedOneWithoutMeasurementsInput
  }

  export type BiomarkerMeasurementUncheckedCreateInput = {
    id?: string
    userId: string
    biomarkerId?: string | null
    panelUploadId?: string | null
    markerName: string
    value?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    capturedAt?: Date | string | null
    status?: $Enums.MeasurementStatus
    source?: $Enums.BiomarkerSource
    confidence?: Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiomarkerMeasurementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    markerName?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMeasurementStatusFieldUpdateOperationsInput | $Enums.MeasurementStatus
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    confidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBiomarkerMeasurementsNestedInput
    biomarker?: BiomarkerUpdateOneWithoutMeasurementsNestedInput
    panelUpload?: PanelUploadUpdateOneWithoutMeasurementsNestedInput
  }

  export type BiomarkerMeasurementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    biomarkerId?: NullableStringFieldUpdateOperationsInput | string | null
    panelUploadId?: NullableStringFieldUpdateOperationsInput | string | null
    markerName?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMeasurementStatusFieldUpdateOperationsInput | $Enums.MeasurementStatus
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    confidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerMeasurementCreateManyInput = {
    id?: string
    userId: string
    biomarkerId?: string | null
    panelUploadId?: string | null
    markerName: string
    value?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    capturedAt?: Date | string | null
    status?: $Enums.MeasurementStatus
    source?: $Enums.BiomarkerSource
    confidence?: Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiomarkerMeasurementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    markerName?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMeasurementStatusFieldUpdateOperationsInput | $Enums.MeasurementStatus
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    confidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerMeasurementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    biomarkerId?: NullableStringFieldUpdateOperationsInput | string | null
    panelUploadId?: NullableStringFieldUpdateOperationsInput | string | null
    markerName?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMeasurementStatusFieldUpdateOperationsInput | $Enums.MeasurementStatus
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    confidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthProviderCreateInput = {
    id?: string
    type: $Enums.AuthProviderType
    providerUserId?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    scopes?: AuthProviderCreatescopesInput | string[]
    expiresAt?: Date | string | null
    linkedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAuthProvidersInput
  }

  export type AuthProviderUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.AuthProviderType
    providerUserId?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    scopes?: AuthProviderCreatescopesInput | string[]
    expiresAt?: Date | string | null
    linkedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthProviderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAuthProviderTypeFieldUpdateOperationsInput | $Enums.AuthProviderType
    providerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: AuthProviderUpdatescopesInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuthProvidersNestedInput
  }

  export type AuthProviderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumAuthProviderTypeFieldUpdateOperationsInput | $Enums.AuthProviderType
    providerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: AuthProviderUpdatescopesInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthProviderCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.AuthProviderType
    providerUserId?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    scopes?: AuthProviderCreatescopesInput | string[]
    expiresAt?: Date | string | null
    linkedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthProviderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAuthProviderTypeFieldUpdateOperationsInput | $Enums.AuthProviderType
    providerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: AuthProviderUpdatescopesInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthProviderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumAuthProviderTypeFieldUpdateOperationsInput | $Enums.AuthProviderType
    providerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: AuthProviderUpdatescopesInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginAuditCreateInput = {
    id?: string
    email: string
    provider: $Enums.AuthProviderType
    success: boolean
    ipAddress?: string | null
    userAgent?: string | null
    failureReason?: string | null
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutLoginAuditsInput
  }

  export type LoginAuditUncheckedCreateInput = {
    id?: string
    userId?: string | null
    email: string
    provider: $Enums.AuthProviderType
    success: boolean
    ipAddress?: string | null
    userAgent?: string | null
    failureReason?: string | null
    createdAt?: Date | string
  }

  export type LoginAuditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderTypeFieldUpdateOperationsInput | $Enums.AuthProviderType
    success?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutLoginAuditsNestedInput
  }

  export type LoginAuditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderTypeFieldUpdateOperationsInput | $Enums.AuthProviderType
    success?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginAuditCreateManyInput = {
    id?: string
    userId?: string | null
    email: string
    provider: $Enums.AuthProviderType
    success: boolean
    ipAddress?: string | null
    userAgent?: string | null
    failureReason?: string | null
    createdAt?: Date | string
  }

  export type LoginAuditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderTypeFieldUpdateOperationsInput | $Enums.AuthProviderType
    success?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginAuditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderTypeFieldUpdateOperationsInput | $Enums.AuthProviderType
    success?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightActionCreateInput = {
    id?: string
    actionType: $Enums.InsightActionType
    notes?: string | null
    createdAt?: Date | string
    insight: InsightCreateNestedOneWithoutActionsInput
    actor?: UserCreateNestedOneWithoutInsightActionsInput
  }

  export type InsightActionUncheckedCreateInput = {
    id?: string
    insightId: string
    actorId?: string | null
    actionType: $Enums.InsightActionType
    notes?: string | null
    createdAt?: Date | string
  }

  export type InsightActionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumInsightActionTypeFieldUpdateOperationsInput | $Enums.InsightActionType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insight?: InsightUpdateOneRequiredWithoutActionsNestedInput
    actor?: UserUpdateOneWithoutInsightActionsNestedInput
  }

  export type InsightActionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: EnumInsightActionTypeFieldUpdateOperationsInput | $Enums.InsightActionType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightActionCreateManyInput = {
    id?: string
    insightId: string
    actorId?: string | null
    actionType: $Enums.InsightActionType
    notes?: string | null
    createdAt?: Date | string
  }

  export type InsightActionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumInsightActionTypeFieldUpdateOperationsInput | $Enums.InsightActionType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightActionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: EnumInsightActionTypeFieldUpdateOperationsInput | $Enums.InsightActionType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightGenerationJobCreateInput = {
    id?: string
    status: $Enums.InsightGenerationStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    insight?: InsightCreateNestedOneWithoutGenerationJobsInput
    requestedBy?: UserCreateNestedOneWithoutInsightGenerationJobsInput
    cloudTask?: CloudTaskMetadataCreateNestedOneWithoutJobInput
  }

  export type InsightGenerationJobUncheckedCreateInput = {
    id?: string
    insightId?: string | null
    requestedById?: string | null
    status: $Enums.InsightGenerationStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cloudTask?: CloudTaskMetadataUncheckedCreateNestedOneWithoutJobInput
  }

  export type InsightGenerationJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInsightGenerationStatusFieldUpdateOperationsInput | $Enums.InsightGenerationStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insight?: InsightUpdateOneWithoutGenerationJobsNestedInput
    requestedBy?: UserUpdateOneWithoutInsightGenerationJobsNestedInput
    cloudTask?: CloudTaskMetadataUpdateOneWithoutJobNestedInput
  }

  export type InsightGenerationJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsightGenerationStatusFieldUpdateOperationsInput | $Enums.InsightGenerationStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cloudTask?: CloudTaskMetadataUncheckedUpdateOneWithoutJobNestedInput
  }

  export type InsightGenerationJobCreateManyInput = {
    id?: string
    insightId?: string | null
    requestedById?: string | null
    status: $Enums.InsightGenerationStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsightGenerationJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInsightGenerationStatusFieldUpdateOperationsInput | $Enums.InsightGenerationStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightGenerationJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsightGenerationStatusFieldUpdateOperationsInput | $Enums.InsightGenerationStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LongevityPlanJobCreateInput = {
    id?: string
    status?: $Enums.LongevityPlanJobStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: LongevityPlanCreateNestedOneWithoutJobsInput
    requestedBy?: UserCreateNestedOneWithoutLongevityPlanJobsInput
    cloudTask?: CloudTaskMetadataCreateNestedOneWithoutPlanJobInput
  }

  export type LongevityPlanJobUncheckedCreateInput = {
    id?: string
    planId?: string | null
    requestedById?: string | null
    status?: $Enums.LongevityPlanJobStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cloudTask?: CloudTaskMetadataUncheckedCreateNestedOneWithoutPlanJobInput
  }

  export type LongevityPlanJobUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLongevityPlanJobStatusFieldUpdateOperationsInput | $Enums.LongevityPlanJobStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: LongevityPlanUpdateOneWithoutJobsNestedInput
    requestedBy?: UserUpdateOneWithoutLongevityPlanJobsNestedInput
    cloudTask?: CloudTaskMetadataUpdateOneWithoutPlanJobNestedInput
  }

  export type LongevityPlanJobUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLongevityPlanJobStatusFieldUpdateOperationsInput | $Enums.LongevityPlanJobStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cloudTask?: CloudTaskMetadataUncheckedUpdateOneWithoutPlanJobNestedInput
  }

  export type LongevityPlanJobCreateManyInput = {
    id?: string
    planId?: string | null
    requestedById?: string | null
    status?: $Enums.LongevityPlanJobStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LongevityPlanJobUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLongevityPlanJobStatusFieldUpdateOperationsInput | $Enums.LongevityPlanJobStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LongevityPlanJobUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLongevityPlanJobStatusFieldUpdateOperationsInput | $Enums.LongevityPlanJobStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CloudTaskMetadataCreateInput = {
    id?: string
    taskName: string
    queue: string
    status?: $Enums.CloudTaskStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduleTime?: Date | string | null
    firstAttemptAt?: Date | string | null
    lastAttemptAt?: Date | string | null
    attemptCount?: number
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    job?: InsightGenerationJobCreateNestedOneWithoutCloudTaskInput
    planJob?: LongevityPlanJobCreateNestedOneWithoutCloudTaskInput
  }

  export type CloudTaskMetadataUncheckedCreateInput = {
    id?: string
    taskName: string
    queue: string
    status?: $Enums.CloudTaskStatus
    jobId?: string | null
    planJobId?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduleTime?: Date | string | null
    firstAttemptAt?: Date | string | null
    lastAttemptAt?: Date | string | null
    attemptCount?: number
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CloudTaskMetadataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskName?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    status?: EnumCloudTaskStatusFieldUpdateOperationsInput | $Enums.CloudTaskStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduleTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: InsightGenerationJobUpdateOneWithoutCloudTaskNestedInput
    planJob?: LongevityPlanJobUpdateOneWithoutCloudTaskNestedInput
  }

  export type CloudTaskMetadataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskName?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    status?: EnumCloudTaskStatusFieldUpdateOperationsInput | $Enums.CloudTaskStatus
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    planJobId?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduleTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CloudTaskMetadataCreateManyInput = {
    id?: string
    taskName: string
    queue: string
    status?: $Enums.CloudTaskStatus
    jobId?: string | null
    planJobId?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduleTime?: Date | string | null
    firstAttemptAt?: Date | string | null
    lastAttemptAt?: Date | string | null
    attemptCount?: number
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CloudTaskMetadataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskName?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    status?: EnumCloudTaskStatusFieldUpdateOperationsInput | $Enums.CloudTaskStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduleTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CloudTaskMetadataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskName?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    status?: EnumCloudTaskStatusFieldUpdateOperationsInput | $Enums.CloudTaskStatus
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    planJobId?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduleTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhoopIntegrationCreateInput = {
    id?: string
    whoopUserId?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    scope?: WhoopIntegrationCreatescopeInput | string[]
    tokenKeyId?: string | null
    tokenRotatedAt?: Date | string | null
    syncStatus?: $Enums.WhoopSyncStatus
    lastSyncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutWhoopIntegrationInput
  }

  export type WhoopIntegrationUncheckedCreateInput = {
    id?: string
    userId: string
    whoopUserId?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    scope?: WhoopIntegrationCreatescopeInput | string[]
    tokenKeyId?: string | null
    tokenRotatedAt?: Date | string | null
    syncStatus?: $Enums.WhoopSyncStatus
    lastSyncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhoopIntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    whoopUserId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: WhoopIntegrationUpdatescopeInput | string[]
    tokenKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenRotatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: EnumWhoopSyncStatusFieldUpdateOperationsInput | $Enums.WhoopSyncStatus
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWhoopIntegrationNestedInput
  }

  export type WhoopIntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    whoopUserId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: WhoopIntegrationUpdatescopeInput | string[]
    tokenKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenRotatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: EnumWhoopSyncStatusFieldUpdateOperationsInput | $Enums.WhoopSyncStatus
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhoopIntegrationCreateManyInput = {
    id?: string
    userId: string
    whoopUserId?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    scope?: WhoopIntegrationCreatescopeInput | string[]
    tokenKeyId?: string | null
    tokenRotatedAt?: Date | string | null
    syncStatus?: $Enums.WhoopSyncStatus
    lastSyncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhoopIntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    whoopUserId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: WhoopIntegrationUpdatescopeInput | string[]
    tokenKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenRotatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: EnumWhoopSyncStatusFieldUpdateOperationsInput | $Enums.WhoopSyncStatus
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhoopIntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    whoopUserId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: WhoopIntegrationUpdatescopeInput | string[]
    tokenKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenRotatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: EnumWhoopSyncStatusFieldUpdateOperationsInput | $Enums.WhoopSyncStatus
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhoopLinkSessionCreateInput = {
    id?: string
    state: string
    redirectUri: string
    scope?: WhoopLinkSessionCreatescopeInput | string[]
    expiresAt: Date | string
    createdAt?: Date | string
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    user: UserCreateNestedOneWithoutWhoopLinkSessionsInput
  }

  export type WhoopLinkSessionUncheckedCreateInput = {
    id?: string
    userId: string
    state: string
    redirectUri: string
    scope?: WhoopLinkSessionCreatescopeInput | string[]
    expiresAt: Date | string
    createdAt?: Date | string
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type WhoopLinkSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    redirectUri?: StringFieldUpdateOperationsInput | string
    scope?: WhoopLinkSessionUpdatescopeInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutWhoopLinkSessionsNestedInput
  }

  export type WhoopLinkSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    redirectUri?: StringFieldUpdateOperationsInput | string
    scope?: WhoopLinkSessionUpdatescopeInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhoopLinkSessionCreateManyInput = {
    id?: string
    userId: string
    state: string
    redirectUri: string
    scope?: WhoopLinkSessionCreatescopeInput | string[]
    expiresAt: Date | string
    createdAt?: Date | string
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type WhoopLinkSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    redirectUri?: StringFieldUpdateOperationsInput | string
    scope?: WhoopLinkSessionUpdatescopeInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhoopLinkSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    redirectUri?: StringFieldUpdateOperationsInput | string
    scope?: WhoopLinkSessionUpdatescopeInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FeedPostCreateInput = {
    id?: string
    body: string
    tags?: FeedPostCreatetagsInput | string[]
    visibility?: $Enums.PostVisibility
    flagged?: boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutFeedPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    flags?: FlagCreateNestedManyWithoutPostInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutPostInput
  }

  export type FeedPostUncheckedCreateInput = {
    id?: string
    authorId: string
    body: string
    tags?: FeedPostCreatetagsInput | string[]
    visibility?: $Enums.PostVisibility
    flagged?: boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    flags?: FlagUncheckedCreateNestedManyWithoutPostInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutPostInput
  }

  export type FeedPostUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    tags?: FeedPostUpdatetagsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutFeedPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    flags?: FlagUpdateManyWithoutPostNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutPostNestedInput
  }

  export type FeedPostUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    tags?: FeedPostUpdatetagsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    flags?: FlagUncheckedUpdateManyWithoutPostNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutPostNestedInput
  }

  export type FeedPostCreateManyInput = {
    id?: string
    authorId: string
    body: string
    tags?: FeedPostCreatetagsInput | string[]
    visibility?: $Enums.PostVisibility
    flagged?: boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedPostUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    tags?: FeedPostUpdatetagsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedPostUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    tags?: FeedPostUpdatetagsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateInput = {
    id?: string
    body: string
    flagged?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    post: FeedPostCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
    reactions?: ReactionCreateNestedManyWithoutCommentInput
    flags?: FlagCreateNestedManyWithoutCommentInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateInput = {
    id?: string
    postId: string
    authorId: string
    body: string
    flagged?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ReactionUncheckedCreateNestedManyWithoutCommentInput
    flags?: FlagUncheckedCreateNestedManyWithoutCommentInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: FeedPostUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    reactions?: ReactionUpdateManyWithoutCommentNestedInput
    flags?: FlagUpdateManyWithoutCommentNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ReactionUncheckedUpdateManyWithoutCommentNestedInput
    flags?: FlagUncheckedUpdateManyWithoutCommentNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentCreateManyInput = {
    id?: string
    postId: string
    authorId: string
    body: string
    flagged?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionCreateInput = {
    id?: string
    type: $Enums.ReactionType
    createdAt?: Date | string
    post?: FeedPostCreateNestedOneWithoutReactionsInput
    comment?: CommentCreateNestedOneWithoutReactionsInput
    user: UserCreateNestedOneWithoutReactionsInput
  }

  export type ReactionUncheckedCreateInput = {
    id?: string
    type: $Enums.ReactionType
    postId?: string | null
    commentId?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type ReactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: FeedPostUpdateOneWithoutReactionsNestedInput
    comment?: CommentUpdateOneWithoutReactionsNestedInput
    user?: UserUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type ReactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionCreateManyInput = {
    id?: string
    type: $Enums.ReactionType
    postId?: string | null
    commentId?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type ReactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementEventCreateInput = {
    id?: string
    type: $Enums.EngagementEventType
    reactionType?: $Enums.ReactionType | null
    occurredAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutEngagementEventsInput
    post?: FeedPostCreateNestedOneWithoutEngagementEventsInput
    comment?: CommentCreateNestedOneWithoutEngagementEventsInput
  }

  export type EngagementEventUncheckedCreateInput = {
    id?: string
    type: $Enums.EngagementEventType
    userId: string
    postId?: string | null
    commentId?: string | null
    reactionType?: $Enums.ReactionType | null
    occurredAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EngagementEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementEventTypeFieldUpdateOperationsInput | $Enums.EngagementEventType
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutEngagementEventsNestedInput
    post?: FeedPostUpdateOneWithoutEngagementEventsNestedInput
    comment?: CommentUpdateOneWithoutEngagementEventsNestedInput
  }

  export type EngagementEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementEventTypeFieldUpdateOperationsInput | $Enums.EngagementEventType
    userId?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EngagementEventCreateManyInput = {
    id?: string
    type: $Enums.EngagementEventType
    userId: string
    postId?: string | null
    commentId?: string | null
    reactionType?: $Enums.ReactionType | null
    occurredAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EngagementEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementEventTypeFieldUpdateOperationsInput | $Enums.EngagementEventType
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EngagementEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementEventTypeFieldUpdateOperationsInput | $Enums.EngagementEventType
    userId?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type FlagCreateInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: FeedPostCreateNestedOneWithoutFlagsInput
    comment?: CommentCreateNestedOneWithoutFlagsInput
    insight?: InsightCreateNestedOneWithoutFlagsInput
    biomarkerLog?: BiomarkerLogCreateNestedOneWithoutFlagsInput
    openedBy: UserCreateNestedOneWithoutFlagsOpenedInput
    resolvedBy?: UserCreateNestedOneWithoutFlagsResolvedInput
  }

  export type FlagUncheckedCreateInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    postId?: string | null
    commentId?: string | null
    insightId?: string | null
    biomarkerLogId?: string | null
    openedById: string
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: FeedPostUpdateOneWithoutFlagsNestedInput
    comment?: CommentUpdateOneWithoutFlagsNestedInput
    insight?: InsightUpdateOneWithoutFlagsNestedInput
    biomarkerLog?: BiomarkerLogUpdateOneWithoutFlagsNestedInput
    openedBy?: UserUpdateOneRequiredWithoutFlagsOpenedNestedInput
    resolvedBy?: UserUpdateOneWithoutFlagsResolvedNestedInput
  }

  export type FlagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    insightId?: NullableStringFieldUpdateOperationsInput | string | null
    biomarkerLogId?: NullableStringFieldUpdateOperationsInput | string | null
    openedById?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlagCreateManyInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    postId?: string | null
    commentId?: string | null
    insightId?: string | null
    biomarkerLogId?: string | null
    openedById: string
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    insightId?: NullableStringFieldUpdateOperationsInput | string | null
    biomarkerLogId?: NullableStringFieldUpdateOperationsInput | string | null
    openedById?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogCreateInput = {
    id?: string
    action: string
    targetType: string
    targetId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    actor: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AdminAuditLogUncheckedCreateInput = {
    id?: string
    actorId: string
    action: string
    targetType: string
    targetId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AdminAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AdminAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogCreateManyInput = {
    id?: string
    actorId: string
    action: string
    targetType: string
    targetId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AdminAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiResponseAuditCreateInput = {
    id?: string
    provider: string
    model?: string | null
    role?: string | null
    prompt?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    plan?: LongevityPlanCreateNestedOneWithoutAuditsInput
    user?: UserCreateNestedOneWithoutAiResponseAuditsInput
  }

  export type AiResponseAuditUncheckedCreateInput = {
    id?: string
    planId?: string | null
    userId?: string | null
    provider: string
    model?: string | null
    role?: string | null
    prompt?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AiResponseAuditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: LongevityPlanUpdateOneWithoutAuditsNestedInput
    user?: UserUpdateOneWithoutAiResponseAuditsNestedInput
  }

  export type AiResponseAuditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiResponseAuditCreateManyInput = {
    id?: string
    planId?: string | null
    userId?: string | null
    provider: string
    model?: string | null
    role?: string | null
    prompt?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AiResponseAuditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiResponseAuditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateInput = {
    id?: string
    name?: string | null
    inviteCode: string
    status?: $Enums.RoomStatus
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    host: UserCreateNestedOneWithoutRoomsHostedInput
    memberships?: RoomMembershipCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id?: string
    name?: string | null
    inviteCode: string
    status?: $Enums.RoomStatus
    capacity: number
    hostId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: RoomMembershipUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    host?: UserUpdateOneRequiredWithoutRoomsHostedNestedInput
    memberships?: RoomMembershipUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    capacity?: IntFieldUpdateOperationsInput | number
    hostId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RoomMembershipUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id?: string
    name?: string | null
    inviteCode: string
    status?: $Enums.RoomStatus
    capacity: number
    hostId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    capacity?: IntFieldUpdateOperationsInput | number
    hostId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomMembershipCreateInput = {
    id?: string
    role?: $Enums.RoomMembershipRole
    status?: $Enums.RoomMembershipStatus
    joinedAt?: Date | string
    leftAt?: Date | string | null
    lastSeenAt?: Date | string | null
    reconnectToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    room: RoomCreateNestedOneWithoutMembershipsInput
    user: UserCreateNestedOneWithoutRoomMembershipsInput
  }

  export type RoomMembershipUncheckedCreateInput = {
    id?: string
    roomId: string
    userId: string
    role?: $Enums.RoomMembershipRole
    status?: $Enums.RoomMembershipStatus
    joinedAt?: Date | string
    leftAt?: Date | string | null
    lastSeenAt?: Date | string | null
    reconnectToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomMembershipUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoomMembershipRoleFieldUpdateOperationsInput | $Enums.RoomMembershipRole
    status?: EnumRoomMembershipStatusFieldUpdateOperationsInput | $Enums.RoomMembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconnectToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutMembershipsNestedInput
    user?: UserUpdateOneRequiredWithoutRoomMembershipsNestedInput
  }

  export type RoomMembershipUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoomMembershipRoleFieldUpdateOperationsInput | $Enums.RoomMembershipRole
    status?: EnumRoomMembershipStatusFieldUpdateOperationsInput | $Enums.RoomMembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconnectToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomMembershipCreateManyInput = {
    id?: string
    roomId: string
    userId: string
    role?: $Enums.RoomMembershipRole
    status?: $Enums.RoomMembershipStatus
    joinedAt?: Date | string
    leftAt?: Date | string | null
    lastSeenAt?: Date | string | null
    reconnectToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomMembershipUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoomMembershipRoleFieldUpdateOperationsInput | $Enums.RoomMembershipRole
    status?: EnumRoomMembershipStatusFieldUpdateOperationsInput | $Enums.RoomMembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconnectToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomMembershipUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoomMembershipRoleFieldUpdateOperationsInput | $Enums.RoomMembershipRole
    status?: EnumRoomMembershipStatusFieldUpdateOperationsInput | $Enums.RoomMembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconnectToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProfileNullableRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type AuthProviderListRelationFilter = {
    every?: AuthProviderWhereInput
    some?: AuthProviderWhereInput
    none?: AuthProviderWhereInput
  }

  export type WhoopIntegrationNullableRelationFilter = {
    is?: WhoopIntegrationWhereInput | null
    isNot?: WhoopIntegrationWhereInput | null
  }

  export type WhoopLinkSessionListRelationFilter = {
    every?: WhoopLinkSessionWhereInput
    some?: WhoopLinkSessionWhereInput
    none?: WhoopLinkSessionWhereInput
  }

  export type InsightListRelationFilter = {
    every?: InsightWhereInput
    some?: InsightWhereInput
    none?: InsightWhereInput
  }

  export type InsightActionListRelationFilter = {
    every?: InsightActionWhereInput
    some?: InsightActionWhereInput
    none?: InsightActionWhereInput
  }

  export type InsightGenerationJobListRelationFilter = {
    every?: InsightGenerationJobWhereInput
    some?: InsightGenerationJobWhereInput
    none?: InsightGenerationJobWhereInput
  }

  export type BiomarkerLogListRelationFilter = {
    every?: BiomarkerLogWhereInput
    some?: BiomarkerLogWhereInput
    none?: BiomarkerLogWhereInput
  }

  export type PanelUploadListRelationFilter = {
    every?: PanelUploadWhereInput
    some?: PanelUploadWhereInput
    none?: PanelUploadWhereInput
  }

  export type BiomarkerMeasurementListRelationFilter = {
    every?: BiomarkerMeasurementWhereInput
    some?: BiomarkerMeasurementWhereInput
    none?: BiomarkerMeasurementWhereInput
  }

  export type FeedPostListRelationFilter = {
    every?: FeedPostWhereInput
    some?: FeedPostWhereInput
    none?: FeedPostWhereInput
  }

  export type CommentListRelationFilter = {
    every?: CommentWhereInput
    some?: CommentWhereInput
    none?: CommentWhereInput
  }

  export type ReactionListRelationFilter = {
    every?: ReactionWhereInput
    some?: ReactionWhereInput
    none?: ReactionWhereInput
  }

  export type EngagementEventListRelationFilter = {
    every?: EngagementEventWhereInput
    some?: EngagementEventWhereInput
    none?: EngagementEventWhereInput
  }

  export type RoomListRelationFilter = {
    every?: RoomWhereInput
    some?: RoomWhereInput
    none?: RoomWhereInput
  }

  export type RoomMembershipListRelationFilter = {
    every?: RoomMembershipWhereInput
    some?: RoomMembershipWhereInput
    none?: RoomMembershipWhereInput
  }

  export type FlagListRelationFilter = {
    every?: FlagWhereInput
    some?: FlagWhereInput
    none?: FlagWhereInput
  }

  export type AdminAuditLogListRelationFilter = {
    every?: AdminAuditLogWhereInput
    some?: AdminAuditLogWhereInput
    none?: AdminAuditLogWhereInput
  }

  export type LongevityPlanListRelationFilter = {
    every?: LongevityPlanWhereInput
    some?: LongevityPlanWhereInput
    none?: LongevityPlanWhereInput
  }

  export type LongevityPlanJobListRelationFilter = {
    every?: LongevityPlanJobWhereInput
    some?: LongevityPlanJobWhereInput
    none?: LongevityPlanJobWhereInput
  }

  export type AiResponseAuditListRelationFilter = {
    every?: AiResponseAuditWhereInput
    some?: AiResponseAuditWhereInput
    none?: AiResponseAuditWhereInput
  }

  export type LoginAuditListRelationFilter = {
    every?: LoginAuditWhereInput
    some?: LoginAuditWhereInput
    none?: LoginAuditWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AuthProviderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WhoopLinkSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InsightOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InsightActionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InsightGenerationJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BiomarkerLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PanelUploadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BiomarkerMeasurementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FeedPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EngagementEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomMembershipOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FlagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AdminAuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LongevityPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LongevityPlanJobOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AiResponseAuditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LoginAuditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    whoopMemberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    whoopMemberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    role?: SortOrder
    status?: SortOrder
    whoopMemberId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    timezone?: SortOrder
    baselineSurvey?: SortOrder
    consents?: SortOrder
    onboardingCompletedAt?: SortOrder
    deleteRequested?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    timezone?: SortOrder
    onboardingCompletedAt?: SortOrder
    deleteRequested?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    displayName?: SortOrder
    timezone?: SortOrder
    onboardingCompletedAt?: SortOrder
    deleteRequested?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumInsightStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightStatus | EnumInsightStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsightStatus[] | ListEnumInsightStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightStatus[] | ListEnumInsightStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightStatusFilter<$PrismaModel> | $Enums.InsightStatus
  }

  export type InsightCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    body?: SortOrder
    modelUsed?: SortOrder
    promptMetadata?: SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsightMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    modelUsed?: SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsightMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    modelUsed?: SortOrder
    status?: SortOrder
    generatedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInsightStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightStatus | EnumInsightStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsightStatus[] | ListEnumInsightStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightStatus[] | ListEnumInsightStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightStatusWithAggregatesFilter<$PrismaModel> | $Enums.InsightStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightStatusFilter<$PrismaModel>
    _max?: NestedEnumInsightStatusFilter<$PrismaModel>
  }

  export type EnumLongevityPlanStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LongevityPlanStatus | EnumLongevityPlanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LongevityPlanStatus[] | ListEnumLongevityPlanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LongevityPlanStatus[] | ListEnumLongevityPlanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLongevityPlanStatusFilter<$PrismaModel> | $Enums.LongevityPlanStatus
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type LongevityPlanCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    focusAreas?: SortOrder
    sections?: SortOrder
    evidence?: SortOrder
    safetyState?: SortOrder
    validatedBy?: SortOrder
    validatedAt?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LongevityPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    validatedBy?: SortOrder
    validatedAt?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LongevityPlanMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    title?: SortOrder
    summary?: SortOrder
    validatedBy?: SortOrder
    validatedAt?: SortOrder
    requestedAt?: SortOrder
    completedAt?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLongevityPlanStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LongevityPlanStatus | EnumLongevityPlanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LongevityPlanStatus[] | ListEnumLongevityPlanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LongevityPlanStatus[] | ListEnumLongevityPlanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLongevityPlanStatusWithAggregatesFilter<$PrismaModel> | $Enums.LongevityPlanStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLongevityPlanStatusFilter<$PrismaModel>
    _max?: NestedEnumLongevityPlanStatusFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type EnumBiomarkerSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.BiomarkerSource | EnumBiomarkerSourceFieldRefInput<$PrismaModel>
    in?: $Enums.BiomarkerSource[] | ListEnumBiomarkerSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.BiomarkerSource[] | ListEnumBiomarkerSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumBiomarkerSourceFilter<$PrismaModel> | $Enums.BiomarkerSource
  }

  export type BiomarkerCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    referenceLow?: SortOrder
    referenceHigh?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiomarkerAvgOrderByAggregateInput = {
    referenceLow?: SortOrder
    referenceHigh?: SortOrder
  }

  export type BiomarkerMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    referenceLow?: SortOrder
    referenceHigh?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiomarkerMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    referenceLow?: SortOrder
    referenceHigh?: SortOrder
    source?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiomarkerSumOrderByAggregateInput = {
    referenceLow?: SortOrder
    referenceHigh?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumBiomarkerSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BiomarkerSource | EnumBiomarkerSourceFieldRefInput<$PrismaModel>
    in?: $Enums.BiomarkerSource[] | ListEnumBiomarkerSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.BiomarkerSource[] | ListEnumBiomarkerSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumBiomarkerSourceWithAggregatesFilter<$PrismaModel> | $Enums.BiomarkerSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBiomarkerSourceFilter<$PrismaModel>
    _max?: NestedEnumBiomarkerSourceFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BiomarkerRelationFilter = {
    is?: BiomarkerWhereInput
    isNot?: BiomarkerWhereInput
  }

  export type BiomarkerLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    biomarkerId?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    source?: SortOrder
    capturedAt?: SortOrder
    accepted?: SortOrder
    flagged?: SortOrder
    notes?: SortOrder
    rawPayload?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiomarkerLogAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type BiomarkerLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    biomarkerId?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    source?: SortOrder
    capturedAt?: SortOrder
    accepted?: SortOrder
    flagged?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiomarkerLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    biomarkerId?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    source?: SortOrder
    capturedAt?: SortOrder
    accepted?: SortOrder
    flagged?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiomarkerLogSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumPanelUploadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PanelUploadStatus | EnumPanelUploadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PanelUploadStatus[] | ListEnumPanelUploadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PanelUploadStatus[] | ListEnumPanelUploadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPanelUploadStatusFilter<$PrismaModel> | $Enums.PanelUploadStatus
  }

  export type EnumPanelUploadSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.PanelUploadSource | EnumPanelUploadSourceFieldRefInput<$PrismaModel>
    in?: $Enums.PanelUploadSource[] | ListEnumPanelUploadSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.PanelUploadSource[] | ListEnumPanelUploadSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumPanelUploadSourceFilter<$PrismaModel> | $Enums.PanelUploadSource
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PanelUploadCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    source?: SortOrder
    storageKey?: SortOrder
    contentType?: SortOrder
    pageCount?: SortOrder
    rawMetadata?: SortOrder
    normalizedPayload?: SortOrder
    measurementCount?: SortOrder
    processedAt?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PanelUploadAvgOrderByAggregateInput = {
    pageCount?: SortOrder
    measurementCount?: SortOrder
  }

  export type PanelUploadMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    source?: SortOrder
    storageKey?: SortOrder
    contentType?: SortOrder
    pageCount?: SortOrder
    measurementCount?: SortOrder
    processedAt?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PanelUploadMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    source?: SortOrder
    storageKey?: SortOrder
    contentType?: SortOrder
    pageCount?: SortOrder
    measurementCount?: SortOrder
    processedAt?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PanelUploadSumOrderByAggregateInput = {
    pageCount?: SortOrder
    measurementCount?: SortOrder
  }

  export type EnumPanelUploadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PanelUploadStatus | EnumPanelUploadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PanelUploadStatus[] | ListEnumPanelUploadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PanelUploadStatus[] | ListEnumPanelUploadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPanelUploadStatusWithAggregatesFilter<$PrismaModel> | $Enums.PanelUploadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPanelUploadStatusFilter<$PrismaModel>
    _max?: NestedEnumPanelUploadStatusFilter<$PrismaModel>
  }

  export type EnumPanelUploadSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PanelUploadSource | EnumPanelUploadSourceFieldRefInput<$PrismaModel>
    in?: $Enums.PanelUploadSource[] | ListEnumPanelUploadSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.PanelUploadSource[] | ListEnumPanelUploadSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumPanelUploadSourceWithAggregatesFilter<$PrismaModel> | $Enums.PanelUploadSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPanelUploadSourceFilter<$PrismaModel>
    _max?: NestedEnumPanelUploadSourceFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumMeasurementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MeasurementStatus | EnumMeasurementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MeasurementStatus[] | ListEnumMeasurementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeasurementStatus[] | ListEnumMeasurementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMeasurementStatusFilter<$PrismaModel> | $Enums.MeasurementStatus
  }

  export type BiomarkerNullableRelationFilter = {
    is?: BiomarkerWhereInput | null
    isNot?: BiomarkerWhereInput | null
  }

  export type PanelUploadNullableRelationFilter = {
    is?: PanelUploadWhereInput | null
    isNot?: PanelUploadWhereInput | null
  }

  export type BiomarkerMeasurementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    biomarkerId?: SortOrder
    panelUploadId?: SortOrder
    markerName?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    referenceLow?: SortOrder
    referenceHigh?: SortOrder
    capturedAt?: SortOrder
    status?: SortOrder
    source?: SortOrder
    confidence?: SortOrder
    flags?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiomarkerMeasurementAvgOrderByAggregateInput = {
    value?: SortOrder
    referenceLow?: SortOrder
    referenceHigh?: SortOrder
    confidence?: SortOrder
  }

  export type BiomarkerMeasurementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    biomarkerId?: SortOrder
    panelUploadId?: SortOrder
    markerName?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    referenceLow?: SortOrder
    referenceHigh?: SortOrder
    capturedAt?: SortOrder
    status?: SortOrder
    source?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiomarkerMeasurementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    biomarkerId?: SortOrder
    panelUploadId?: SortOrder
    markerName?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    referenceLow?: SortOrder
    referenceHigh?: SortOrder
    capturedAt?: SortOrder
    status?: SortOrder
    source?: SortOrder
    confidence?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BiomarkerMeasurementSumOrderByAggregateInput = {
    value?: SortOrder
    referenceLow?: SortOrder
    referenceHigh?: SortOrder
    confidence?: SortOrder
  }

  export type EnumMeasurementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MeasurementStatus | EnumMeasurementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MeasurementStatus[] | ListEnumMeasurementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeasurementStatus[] | ListEnumMeasurementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMeasurementStatusWithAggregatesFilter<$PrismaModel> | $Enums.MeasurementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMeasurementStatusFilter<$PrismaModel>
    _max?: NestedEnumMeasurementStatusFilter<$PrismaModel>
  }

  export type EnumAuthProviderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProviderType | EnumAuthProviderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProviderType[] | ListEnumAuthProviderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProviderType[] | ListEnumAuthProviderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderTypeFilter<$PrismaModel> | $Enums.AuthProviderType
  }

  export type AuthProviderUserIdTypeCompoundUniqueInput = {
    userId: string
    type: $Enums.AuthProviderType
  }

  export type AuthProviderCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    providerUserId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    scopes?: SortOrder
    expiresAt?: SortOrder
    linkedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    providerUserId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    linkedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuthProviderMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    providerUserId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    linkedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAuthProviderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProviderType | EnumAuthProviderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProviderType[] | ListEnumAuthProviderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProviderType[] | ListEnumAuthProviderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuthProviderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderTypeFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderTypeFilter<$PrismaModel>
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type LoginAuditCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    provider?: SortOrder
    success?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
  }

  export type LoginAuditMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    provider?: SortOrder
    success?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
  }

  export type LoginAuditMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    email?: SortOrder
    provider?: SortOrder
    success?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    failureReason?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumInsightActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightActionType | EnumInsightActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsightActionType[] | ListEnumInsightActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightActionType[] | ListEnumInsightActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightActionTypeFilter<$PrismaModel> | $Enums.InsightActionType
  }

  export type InsightRelationFilter = {
    is?: InsightWhereInput
    isNot?: InsightWhereInput
  }

  export type InsightActionCountOrderByAggregateInput = {
    id?: SortOrder
    insightId?: SortOrder
    actorId?: SortOrder
    actionType?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type InsightActionMaxOrderByAggregateInput = {
    id?: SortOrder
    insightId?: SortOrder
    actorId?: SortOrder
    actionType?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type InsightActionMinOrderByAggregateInput = {
    id?: SortOrder
    insightId?: SortOrder
    actorId?: SortOrder
    actionType?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumInsightActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightActionType | EnumInsightActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsightActionType[] | ListEnumInsightActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightActionType[] | ListEnumInsightActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InsightActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightActionTypeFilter<$PrismaModel>
    _max?: NestedEnumInsightActionTypeFilter<$PrismaModel>
  }

  export type EnumInsightGenerationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightGenerationStatus | EnumInsightGenerationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsightGenerationStatus[] | ListEnumInsightGenerationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightGenerationStatus[] | ListEnumInsightGenerationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightGenerationStatusFilter<$PrismaModel> | $Enums.InsightGenerationStatus
  }

  export type InsightNullableRelationFilter = {
    is?: InsightWhereInput | null
    isNot?: InsightWhereInput | null
  }

  export type CloudTaskMetadataNullableRelationFilter = {
    is?: CloudTaskMetadataWhereInput | null
    isNot?: CloudTaskMetadataWhereInput | null
  }

  export type InsightGenerationJobCountOrderByAggregateInput = {
    id?: SortOrder
    insightId?: SortOrder
    requestedById?: SortOrder
    status?: SortOrder
    cloudTaskName?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    scheduledAt?: SortOrder
    dispatchedAt?: SortOrder
    completedAt?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsightGenerationJobMaxOrderByAggregateInput = {
    id?: SortOrder
    insightId?: SortOrder
    requestedById?: SortOrder
    status?: SortOrder
    cloudTaskName?: SortOrder
    queue?: SortOrder
    scheduledAt?: SortOrder
    dispatchedAt?: SortOrder
    completedAt?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InsightGenerationJobMinOrderByAggregateInput = {
    id?: SortOrder
    insightId?: SortOrder
    requestedById?: SortOrder
    status?: SortOrder
    cloudTaskName?: SortOrder
    queue?: SortOrder
    scheduledAt?: SortOrder
    dispatchedAt?: SortOrder
    completedAt?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInsightGenerationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightGenerationStatus | EnumInsightGenerationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsightGenerationStatus[] | ListEnumInsightGenerationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightGenerationStatus[] | ListEnumInsightGenerationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightGenerationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InsightGenerationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightGenerationStatusFilter<$PrismaModel>
    _max?: NestedEnumInsightGenerationStatusFilter<$PrismaModel>
  }

  export type EnumLongevityPlanJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LongevityPlanJobStatus | EnumLongevityPlanJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LongevityPlanJobStatus[] | ListEnumLongevityPlanJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LongevityPlanJobStatus[] | ListEnumLongevityPlanJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLongevityPlanJobStatusFilter<$PrismaModel> | $Enums.LongevityPlanJobStatus
  }

  export type LongevityPlanNullableRelationFilter = {
    is?: LongevityPlanWhereInput | null
    isNot?: LongevityPlanWhereInput | null
  }

  export type LongevityPlanJobCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    requestedById?: SortOrder
    status?: SortOrder
    cloudTaskName?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    scheduledAt?: SortOrder
    dispatchedAt?: SortOrder
    completedAt?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LongevityPlanJobMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    requestedById?: SortOrder
    status?: SortOrder
    cloudTaskName?: SortOrder
    queue?: SortOrder
    scheduledAt?: SortOrder
    dispatchedAt?: SortOrder
    completedAt?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LongevityPlanJobMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    requestedById?: SortOrder
    status?: SortOrder
    cloudTaskName?: SortOrder
    queue?: SortOrder
    scheduledAt?: SortOrder
    dispatchedAt?: SortOrder
    completedAt?: SortOrder
    errorCode?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLongevityPlanJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LongevityPlanJobStatus | EnumLongevityPlanJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LongevityPlanJobStatus[] | ListEnumLongevityPlanJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LongevityPlanJobStatus[] | ListEnumLongevityPlanJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLongevityPlanJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.LongevityPlanJobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLongevityPlanJobStatusFilter<$PrismaModel>
    _max?: NestedEnumLongevityPlanJobStatusFilter<$PrismaModel>
  }

  export type EnumCloudTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CloudTaskStatus | EnumCloudTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CloudTaskStatus[] | ListEnumCloudTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CloudTaskStatus[] | ListEnumCloudTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCloudTaskStatusFilter<$PrismaModel> | $Enums.CloudTaskStatus
  }

  export type InsightGenerationJobNullableRelationFilter = {
    is?: InsightGenerationJobWhereInput | null
    isNot?: InsightGenerationJobWhereInput | null
  }

  export type LongevityPlanJobNullableRelationFilter = {
    is?: LongevityPlanJobWhereInput | null
    isNot?: LongevityPlanJobWhereInput | null
  }

  export type CloudTaskMetadataCountOrderByAggregateInput = {
    id?: SortOrder
    taskName?: SortOrder
    queue?: SortOrder
    status?: SortOrder
    jobId?: SortOrder
    planJobId?: SortOrder
    payload?: SortOrder
    scheduleTime?: SortOrder
    firstAttemptAt?: SortOrder
    lastAttemptAt?: SortOrder
    attemptCount?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CloudTaskMetadataAvgOrderByAggregateInput = {
    attemptCount?: SortOrder
  }

  export type CloudTaskMetadataMaxOrderByAggregateInput = {
    id?: SortOrder
    taskName?: SortOrder
    queue?: SortOrder
    status?: SortOrder
    jobId?: SortOrder
    planJobId?: SortOrder
    scheduleTime?: SortOrder
    firstAttemptAt?: SortOrder
    lastAttemptAt?: SortOrder
    attemptCount?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CloudTaskMetadataMinOrderByAggregateInput = {
    id?: SortOrder
    taskName?: SortOrder
    queue?: SortOrder
    status?: SortOrder
    jobId?: SortOrder
    planJobId?: SortOrder
    scheduleTime?: SortOrder
    firstAttemptAt?: SortOrder
    lastAttemptAt?: SortOrder
    attemptCount?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CloudTaskMetadataSumOrderByAggregateInput = {
    attemptCount?: SortOrder
  }

  export type EnumCloudTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CloudTaskStatus | EnumCloudTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CloudTaskStatus[] | ListEnumCloudTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CloudTaskStatus[] | ListEnumCloudTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCloudTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.CloudTaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCloudTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumCloudTaskStatusFilter<$PrismaModel>
  }

  export type EnumWhoopSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WhoopSyncStatus | EnumWhoopSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhoopSyncStatus[] | ListEnumWhoopSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhoopSyncStatus[] | ListEnumWhoopSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhoopSyncStatusFilter<$PrismaModel> | $Enums.WhoopSyncStatus
  }

  export type WhoopIntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    whoopUserId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    scope?: SortOrder
    tokenKeyId?: SortOrder
    tokenRotatedAt?: SortOrder
    syncStatus?: SortOrder
    lastSyncedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhoopIntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    whoopUserId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    tokenKeyId?: SortOrder
    tokenRotatedAt?: SortOrder
    syncStatus?: SortOrder
    lastSyncedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type WhoopIntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    whoopUserId?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    expiresAt?: SortOrder
    tokenKeyId?: SortOrder
    tokenRotatedAt?: SortOrder
    syncStatus?: SortOrder
    lastSyncedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumWhoopSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WhoopSyncStatus | EnumWhoopSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhoopSyncStatus[] | ListEnumWhoopSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhoopSyncStatus[] | ListEnumWhoopSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhoopSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.WhoopSyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWhoopSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumWhoopSyncStatusFilter<$PrismaModel>
  }

  export type WhoopLinkSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    state?: SortOrder
    redirectUri?: SortOrder
    scope?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    cancelledAt?: SortOrder
  }

  export type WhoopLinkSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    state?: SortOrder
    redirectUri?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    cancelledAt?: SortOrder
  }

  export type WhoopLinkSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    state?: SortOrder
    redirectUri?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    completedAt?: SortOrder
    cancelledAt?: SortOrder
  }

  export type EnumPostVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityFilter<$PrismaModel> | $Enums.PostVisibility
  }

  export type FeedPostCountOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    body?: SortOrder
    tags?: SortOrder
    visibility?: SortOrder
    flagged?: SortOrder
    reactionSummary?: SortOrder
    commentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedPostAvgOrderByAggregateInput = {
    commentCount?: SortOrder
  }

  export type FeedPostMaxOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    body?: SortOrder
    visibility?: SortOrder
    flagged?: SortOrder
    commentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedPostMinOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    body?: SortOrder
    visibility?: SortOrder
    flagged?: SortOrder
    commentCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FeedPostSumOrderByAggregateInput = {
    commentCount?: SortOrder
  }

  export type EnumPostVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.PostVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostVisibilityFilter<$PrismaModel>
    _max?: NestedEnumPostVisibilityFilter<$PrismaModel>
  }

  export type FeedPostRelationFilter = {
    is?: FeedPostWhereInput
    isNot?: FeedPostWhereInput
  }

  export type CommentCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    body?: SortOrder
    flagged?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    body?: SortOrder
    flagged?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CommentMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    authorId?: SortOrder
    body?: SortOrder
    flagged?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeFilter<$PrismaModel> | $Enums.ReactionType
  }

  export type FeedPostNullableRelationFilter = {
    is?: FeedPostWhereInput | null
    isNot?: FeedPostWhereInput | null
  }

  export type CommentNullableRelationFilter = {
    is?: CommentWhereInput | null
    isNot?: CommentWhereInput | null
  }

  export type ReactionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReactionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type ReactionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumReactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeFilter<$PrismaModel>
  }

  export type EnumEngagementEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementEventType | EnumEngagementEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EngagementEventType[] | ListEnumEngagementEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EngagementEventType[] | ListEnumEngagementEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEngagementEventTypeFilter<$PrismaModel> | $Enums.EngagementEventType
  }

  export type EnumReactionTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReactionTypeNullableFilter<$PrismaModel> | $Enums.ReactionType | null
  }

  export type EngagementEventCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    reactionType?: SortOrder
    occurredAt?: SortOrder
    metadata?: SortOrder
  }

  export type EngagementEventMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    reactionType?: SortOrder
    occurredAt?: SortOrder
  }

  export type EngagementEventMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    userId?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    reactionType?: SortOrder
    occurredAt?: SortOrder
  }

  export type EnumEngagementEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementEventType | EnumEngagementEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EngagementEventType[] | ListEnumEngagementEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EngagementEventType[] | ListEnumEngagementEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEngagementEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EngagementEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEngagementEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEngagementEventTypeFilter<$PrismaModel>
  }

  export type EnumReactionTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReactionTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeNullableFilter<$PrismaModel>
  }

  export type EnumFlagTargetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FlagTargetType | EnumFlagTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FlagTargetType[] | ListEnumFlagTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlagTargetType[] | ListEnumFlagTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFlagTargetTypeFilter<$PrismaModel> | $Enums.FlagTargetType
  }

  export type EnumFlagStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FlagStatus | EnumFlagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlagStatusFilter<$PrismaModel> | $Enums.FlagStatus
  }

  export type BiomarkerLogNullableRelationFilter = {
    is?: BiomarkerLogWhereInput | null
    isNot?: BiomarkerLogWhereInput | null
  }

  export type FlagCountOrderByAggregateInput = {
    id?: SortOrder
    targetType?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    insightId?: SortOrder
    biomarkerLogId?: SortOrder
    openedById?: SortOrder
    resolvedById?: SortOrder
    resolvedAt?: SortOrder
    auditTrail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlagMaxOrderByAggregateInput = {
    id?: SortOrder
    targetType?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    insightId?: SortOrder
    biomarkerLogId?: SortOrder
    openedById?: SortOrder
    resolvedById?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FlagMinOrderByAggregateInput = {
    id?: SortOrder
    targetType?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    postId?: SortOrder
    commentId?: SortOrder
    insightId?: SortOrder
    biomarkerLogId?: SortOrder
    openedById?: SortOrder
    resolvedById?: SortOrder
    resolvedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumFlagTargetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlagTargetType | EnumFlagTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FlagTargetType[] | ListEnumFlagTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlagTargetType[] | ListEnumFlagTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFlagTargetTypeWithAggregatesFilter<$PrismaModel> | $Enums.FlagTargetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlagTargetTypeFilter<$PrismaModel>
    _max?: NestedEnumFlagTargetTypeFilter<$PrismaModel>
  }

  export type EnumFlagStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlagStatus | EnumFlagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlagStatusWithAggregatesFilter<$PrismaModel> | $Enums.FlagStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlagStatusFilter<$PrismaModel>
    _max?: NestedEnumFlagStatusFilter<$PrismaModel>
  }

  export type AdminAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
  }

  export type AdminAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    action?: SortOrder
    targetType?: SortOrder
    targetId?: SortOrder
    createdAt?: SortOrder
  }

  export type AiResponseAuditCountOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    role?: SortOrder
    prompt?: SortOrder
    response?: SortOrder
    createdAt?: SortOrder
  }

  export type AiResponseAuditMaxOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type AiResponseAuditMinOrderByAggregateInput = {
    id?: SortOrder
    planId?: SortOrder
    userId?: SortOrder
    provider?: SortOrder
    model?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumRoomStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomStatus | EnumRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomStatusFilter<$PrismaModel> | $Enums.RoomStatus
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    inviteCode?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    hostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomAvgOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    inviteCode?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    hostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    inviteCode?: SortOrder
    status?: SortOrder
    capacity?: SortOrder
    hostId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomSumOrderByAggregateInput = {
    capacity?: SortOrder
  }

  export type EnumRoomStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomStatus | EnumRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomStatusWithAggregatesFilter<$PrismaModel> | $Enums.RoomStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomStatusFilter<$PrismaModel>
    _max?: NestedEnumRoomStatusFilter<$PrismaModel>
  }

  export type EnumRoomMembershipRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomMembershipRole | EnumRoomMembershipRoleFieldRefInput<$PrismaModel>
    in?: $Enums.RoomMembershipRole[] | ListEnumRoomMembershipRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomMembershipRole[] | ListEnumRoomMembershipRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomMembershipRoleFilter<$PrismaModel> | $Enums.RoomMembershipRole
  }

  export type EnumRoomMembershipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomMembershipStatus | EnumRoomMembershipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomMembershipStatus[] | ListEnumRoomMembershipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomMembershipStatus[] | ListEnumRoomMembershipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomMembershipStatusFilter<$PrismaModel> | $Enums.RoomMembershipStatus
  }

  export type RoomRelationFilter = {
    is?: RoomWhereInput
    isNot?: RoomWhereInput
  }

  export type RoomMembershipRoomIdUserIdCompoundUniqueInput = {
    roomId: string
    userId: string
  }

  export type RoomMembershipCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    lastSeenAt?: SortOrder
    reconnectToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomMembershipMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    lastSeenAt?: SortOrder
    reconnectToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomMembershipMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    userId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
    lastSeenAt?: SortOrder
    reconnectToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRoomMembershipRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomMembershipRole | EnumRoomMembershipRoleFieldRefInput<$PrismaModel>
    in?: $Enums.RoomMembershipRole[] | ListEnumRoomMembershipRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomMembershipRole[] | ListEnumRoomMembershipRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomMembershipRoleWithAggregatesFilter<$PrismaModel> | $Enums.RoomMembershipRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomMembershipRoleFilter<$PrismaModel>
    _max?: NestedEnumRoomMembershipRoleFilter<$PrismaModel>
  }

  export type EnumRoomMembershipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomMembershipStatus | EnumRoomMembershipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomMembershipStatus[] | ListEnumRoomMembershipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomMembershipStatus[] | ListEnumRoomMembershipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomMembershipStatusWithAggregatesFilter<$PrismaModel> | $Enums.RoomMembershipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomMembershipStatusFilter<$PrismaModel>
    _max?: NestedEnumRoomMembershipStatusFilter<$PrismaModel>
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type AuthProviderCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthProviderCreateWithoutUserInput, AuthProviderUncheckedCreateWithoutUserInput> | AuthProviderCreateWithoutUserInput[] | AuthProviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthProviderCreateOrConnectWithoutUserInput | AuthProviderCreateOrConnectWithoutUserInput[]
    createMany?: AuthProviderCreateManyUserInputEnvelope
    connect?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
  }

  export type WhoopIntegrationCreateNestedOneWithoutUserInput = {
    create?: XOR<WhoopIntegrationCreateWithoutUserInput, WhoopIntegrationUncheckedCreateWithoutUserInput>
    connectOrCreate?: WhoopIntegrationCreateOrConnectWithoutUserInput
    connect?: WhoopIntegrationWhereUniqueInput
  }

  export type WhoopLinkSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<WhoopLinkSessionCreateWithoutUserInput, WhoopLinkSessionUncheckedCreateWithoutUserInput> | WhoopLinkSessionCreateWithoutUserInput[] | WhoopLinkSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhoopLinkSessionCreateOrConnectWithoutUserInput | WhoopLinkSessionCreateOrConnectWithoutUserInput[]
    createMany?: WhoopLinkSessionCreateManyUserInputEnvelope
    connect?: WhoopLinkSessionWhereUniqueInput | WhoopLinkSessionWhereUniqueInput[]
  }

  export type InsightCreateNestedManyWithoutUserInput = {
    create?: XOR<InsightCreateWithoutUserInput, InsightUncheckedCreateWithoutUserInput> | InsightCreateWithoutUserInput[] | InsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InsightCreateOrConnectWithoutUserInput | InsightCreateOrConnectWithoutUserInput[]
    createMany?: InsightCreateManyUserInputEnvelope
    connect?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
  }

  export type InsightActionCreateNestedManyWithoutActorInput = {
    create?: XOR<InsightActionCreateWithoutActorInput, InsightActionUncheckedCreateWithoutActorInput> | InsightActionCreateWithoutActorInput[] | InsightActionUncheckedCreateWithoutActorInput[]
    connectOrCreate?: InsightActionCreateOrConnectWithoutActorInput | InsightActionCreateOrConnectWithoutActorInput[]
    createMany?: InsightActionCreateManyActorInputEnvelope
    connect?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
  }

  export type InsightGenerationJobCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<InsightGenerationJobCreateWithoutRequestedByInput, InsightGenerationJobUncheckedCreateWithoutRequestedByInput> | InsightGenerationJobCreateWithoutRequestedByInput[] | InsightGenerationJobUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: InsightGenerationJobCreateOrConnectWithoutRequestedByInput | InsightGenerationJobCreateOrConnectWithoutRequestedByInput[]
    createMany?: InsightGenerationJobCreateManyRequestedByInputEnvelope
    connect?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
  }

  export type BiomarkerLogCreateNestedManyWithoutUserInput = {
    create?: XOR<BiomarkerLogCreateWithoutUserInput, BiomarkerLogUncheckedCreateWithoutUserInput> | BiomarkerLogCreateWithoutUserInput[] | BiomarkerLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BiomarkerLogCreateOrConnectWithoutUserInput | BiomarkerLogCreateOrConnectWithoutUserInput[]
    createMany?: BiomarkerLogCreateManyUserInputEnvelope
    connect?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
  }

  export type PanelUploadCreateNestedManyWithoutUserInput = {
    create?: XOR<PanelUploadCreateWithoutUserInput, PanelUploadUncheckedCreateWithoutUserInput> | PanelUploadCreateWithoutUserInput[] | PanelUploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PanelUploadCreateOrConnectWithoutUserInput | PanelUploadCreateOrConnectWithoutUserInput[]
    createMany?: PanelUploadCreateManyUserInputEnvelope
    connect?: PanelUploadWhereUniqueInput | PanelUploadWhereUniqueInput[]
  }

  export type BiomarkerMeasurementCreateNestedManyWithoutUserInput = {
    create?: XOR<BiomarkerMeasurementCreateWithoutUserInput, BiomarkerMeasurementUncheckedCreateWithoutUserInput> | BiomarkerMeasurementCreateWithoutUserInput[] | BiomarkerMeasurementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BiomarkerMeasurementCreateOrConnectWithoutUserInput | BiomarkerMeasurementCreateOrConnectWithoutUserInput[]
    createMany?: BiomarkerMeasurementCreateManyUserInputEnvelope
    connect?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
  }

  export type FeedPostCreateNestedManyWithoutAuthorInput = {
    create?: XOR<FeedPostCreateWithoutAuthorInput, FeedPostUncheckedCreateWithoutAuthorInput> | FeedPostCreateWithoutAuthorInput[] | FeedPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: FeedPostCreateOrConnectWithoutAuthorInput | FeedPostCreateOrConnectWithoutAuthorInput[]
    createMany?: FeedPostCreateManyAuthorInputEnvelope
    connect?: FeedPostWhereUniqueInput | FeedPostWhereUniqueInput[]
  }

  export type CommentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReactionCreateNestedManyWithoutUserInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type EngagementEventCreateNestedManyWithoutUserInput = {
    create?: XOR<EngagementEventCreateWithoutUserInput, EngagementEventUncheckedCreateWithoutUserInput> | EngagementEventCreateWithoutUserInput[] | EngagementEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EngagementEventCreateOrConnectWithoutUserInput | EngagementEventCreateOrConnectWithoutUserInput[]
    createMany?: EngagementEventCreateManyUserInputEnvelope
    connect?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
  }

  export type RoomCreateNestedManyWithoutHostInput = {
    create?: XOR<RoomCreateWithoutHostInput, RoomUncheckedCreateWithoutHostInput> | RoomCreateWithoutHostInput[] | RoomUncheckedCreateWithoutHostInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutHostInput | RoomCreateOrConnectWithoutHostInput[]
    createMany?: RoomCreateManyHostInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomMembershipCreateNestedManyWithoutUserInput = {
    create?: XOR<RoomMembershipCreateWithoutUserInput, RoomMembershipUncheckedCreateWithoutUserInput> | RoomMembershipCreateWithoutUserInput[] | RoomMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutUserInput | RoomMembershipCreateOrConnectWithoutUserInput[]
    createMany?: RoomMembershipCreateManyUserInputEnvelope
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
  }

  export type FlagCreateNestedManyWithoutOpenedByInput = {
    create?: XOR<FlagCreateWithoutOpenedByInput, FlagUncheckedCreateWithoutOpenedByInput> | FlagCreateWithoutOpenedByInput[] | FlagUncheckedCreateWithoutOpenedByInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutOpenedByInput | FlagCreateOrConnectWithoutOpenedByInput[]
    createMany?: FlagCreateManyOpenedByInputEnvelope
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
  }

  export type FlagCreateNestedManyWithoutResolvedByInput = {
    create?: XOR<FlagCreateWithoutResolvedByInput, FlagUncheckedCreateWithoutResolvedByInput> | FlagCreateWithoutResolvedByInput[] | FlagUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutResolvedByInput | FlagCreateOrConnectWithoutResolvedByInput[]
    createMany?: FlagCreateManyResolvedByInputEnvelope
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
  }

  export type AdminAuditLogCreateNestedManyWithoutActorInput = {
    create?: XOR<AdminAuditLogCreateWithoutActorInput, AdminAuditLogUncheckedCreateWithoutActorInput> | AdminAuditLogCreateWithoutActorInput[] | AdminAuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutActorInput | AdminAuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AdminAuditLogCreateManyActorInputEnvelope
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
  }

  export type LongevityPlanCreateNestedManyWithoutUserInput = {
    create?: XOR<LongevityPlanCreateWithoutUserInput, LongevityPlanUncheckedCreateWithoutUserInput> | LongevityPlanCreateWithoutUserInput[] | LongevityPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LongevityPlanCreateOrConnectWithoutUserInput | LongevityPlanCreateOrConnectWithoutUserInput[]
    createMany?: LongevityPlanCreateManyUserInputEnvelope
    connect?: LongevityPlanWhereUniqueInput | LongevityPlanWhereUniqueInput[]
  }

  export type LongevityPlanJobCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<LongevityPlanJobCreateWithoutRequestedByInput, LongevityPlanJobUncheckedCreateWithoutRequestedByInput> | LongevityPlanJobCreateWithoutRequestedByInput[] | LongevityPlanJobUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: LongevityPlanJobCreateOrConnectWithoutRequestedByInput | LongevityPlanJobCreateOrConnectWithoutRequestedByInput[]
    createMany?: LongevityPlanJobCreateManyRequestedByInputEnvelope
    connect?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
  }

  export type AiResponseAuditCreateNestedManyWithoutUserInput = {
    create?: XOR<AiResponseAuditCreateWithoutUserInput, AiResponseAuditUncheckedCreateWithoutUserInput> | AiResponseAuditCreateWithoutUserInput[] | AiResponseAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiResponseAuditCreateOrConnectWithoutUserInput | AiResponseAuditCreateOrConnectWithoutUserInput[]
    createMany?: AiResponseAuditCreateManyUserInputEnvelope
    connect?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
  }

  export type LoginAuditCreateNestedManyWithoutUserInput = {
    create?: XOR<LoginAuditCreateWithoutUserInput, LoginAuditUncheckedCreateWithoutUserInput> | LoginAuditCreateWithoutUserInput[] | LoginAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginAuditCreateOrConnectWithoutUserInput | LoginAuditCreateOrConnectWithoutUserInput[]
    createMany?: LoginAuditCreateManyUserInputEnvelope
    connect?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type AuthProviderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuthProviderCreateWithoutUserInput, AuthProviderUncheckedCreateWithoutUserInput> | AuthProviderCreateWithoutUserInput[] | AuthProviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthProviderCreateOrConnectWithoutUserInput | AuthProviderCreateOrConnectWithoutUserInput[]
    createMany?: AuthProviderCreateManyUserInputEnvelope
    connect?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
  }

  export type WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<WhoopIntegrationCreateWithoutUserInput, WhoopIntegrationUncheckedCreateWithoutUserInput>
    connectOrCreate?: WhoopIntegrationCreateOrConnectWithoutUserInput
    connect?: WhoopIntegrationWhereUniqueInput
  }

  export type WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WhoopLinkSessionCreateWithoutUserInput, WhoopLinkSessionUncheckedCreateWithoutUserInput> | WhoopLinkSessionCreateWithoutUserInput[] | WhoopLinkSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhoopLinkSessionCreateOrConnectWithoutUserInput | WhoopLinkSessionCreateOrConnectWithoutUserInput[]
    createMany?: WhoopLinkSessionCreateManyUserInputEnvelope
    connect?: WhoopLinkSessionWhereUniqueInput | WhoopLinkSessionWhereUniqueInput[]
  }

  export type InsightUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InsightCreateWithoutUserInput, InsightUncheckedCreateWithoutUserInput> | InsightCreateWithoutUserInput[] | InsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InsightCreateOrConnectWithoutUserInput | InsightCreateOrConnectWithoutUserInput[]
    createMany?: InsightCreateManyUserInputEnvelope
    connect?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
  }

  export type InsightActionUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<InsightActionCreateWithoutActorInput, InsightActionUncheckedCreateWithoutActorInput> | InsightActionCreateWithoutActorInput[] | InsightActionUncheckedCreateWithoutActorInput[]
    connectOrCreate?: InsightActionCreateOrConnectWithoutActorInput | InsightActionCreateOrConnectWithoutActorInput[]
    createMany?: InsightActionCreateManyActorInputEnvelope
    connect?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
  }

  export type InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<InsightGenerationJobCreateWithoutRequestedByInput, InsightGenerationJobUncheckedCreateWithoutRequestedByInput> | InsightGenerationJobCreateWithoutRequestedByInput[] | InsightGenerationJobUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: InsightGenerationJobCreateOrConnectWithoutRequestedByInput | InsightGenerationJobCreateOrConnectWithoutRequestedByInput[]
    createMany?: InsightGenerationJobCreateManyRequestedByInputEnvelope
    connect?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
  }

  export type BiomarkerLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BiomarkerLogCreateWithoutUserInput, BiomarkerLogUncheckedCreateWithoutUserInput> | BiomarkerLogCreateWithoutUserInput[] | BiomarkerLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BiomarkerLogCreateOrConnectWithoutUserInput | BiomarkerLogCreateOrConnectWithoutUserInput[]
    createMany?: BiomarkerLogCreateManyUserInputEnvelope
    connect?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
  }

  export type PanelUploadUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PanelUploadCreateWithoutUserInput, PanelUploadUncheckedCreateWithoutUserInput> | PanelUploadCreateWithoutUserInput[] | PanelUploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PanelUploadCreateOrConnectWithoutUserInput | PanelUploadCreateOrConnectWithoutUserInput[]
    createMany?: PanelUploadCreateManyUserInputEnvelope
    connect?: PanelUploadWhereUniqueInput | PanelUploadWhereUniqueInput[]
  }

  export type BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<BiomarkerMeasurementCreateWithoutUserInput, BiomarkerMeasurementUncheckedCreateWithoutUserInput> | BiomarkerMeasurementCreateWithoutUserInput[] | BiomarkerMeasurementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BiomarkerMeasurementCreateOrConnectWithoutUserInput | BiomarkerMeasurementCreateOrConnectWithoutUserInput[]
    createMany?: BiomarkerMeasurementCreateManyUserInputEnvelope
    connect?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
  }

  export type FeedPostUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<FeedPostCreateWithoutAuthorInput, FeedPostUncheckedCreateWithoutAuthorInput> | FeedPostCreateWithoutAuthorInput[] | FeedPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: FeedPostCreateOrConnectWithoutAuthorInput | FeedPostCreateOrConnectWithoutAuthorInput[]
    createMany?: FeedPostCreateManyAuthorInputEnvelope
    connect?: FeedPostWhereUniqueInput | FeedPostWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type EngagementEventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EngagementEventCreateWithoutUserInput, EngagementEventUncheckedCreateWithoutUserInput> | EngagementEventCreateWithoutUserInput[] | EngagementEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EngagementEventCreateOrConnectWithoutUserInput | EngagementEventCreateOrConnectWithoutUserInput[]
    createMany?: EngagementEventCreateManyUserInputEnvelope
    connect?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutHostInput = {
    create?: XOR<RoomCreateWithoutHostInput, RoomUncheckedCreateWithoutHostInput> | RoomCreateWithoutHostInput[] | RoomUncheckedCreateWithoutHostInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutHostInput | RoomCreateOrConnectWithoutHostInput[]
    createMany?: RoomCreateManyHostInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type RoomMembershipUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RoomMembershipCreateWithoutUserInput, RoomMembershipUncheckedCreateWithoutUserInput> | RoomMembershipCreateWithoutUserInput[] | RoomMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutUserInput | RoomMembershipCreateOrConnectWithoutUserInput[]
    createMany?: RoomMembershipCreateManyUserInputEnvelope
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
  }

  export type FlagUncheckedCreateNestedManyWithoutOpenedByInput = {
    create?: XOR<FlagCreateWithoutOpenedByInput, FlagUncheckedCreateWithoutOpenedByInput> | FlagCreateWithoutOpenedByInput[] | FlagUncheckedCreateWithoutOpenedByInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutOpenedByInput | FlagCreateOrConnectWithoutOpenedByInput[]
    createMany?: FlagCreateManyOpenedByInputEnvelope
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
  }

  export type FlagUncheckedCreateNestedManyWithoutResolvedByInput = {
    create?: XOR<FlagCreateWithoutResolvedByInput, FlagUncheckedCreateWithoutResolvedByInput> | FlagCreateWithoutResolvedByInput[] | FlagUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutResolvedByInput | FlagCreateOrConnectWithoutResolvedByInput[]
    createMany?: FlagCreateManyResolvedByInputEnvelope
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
  }

  export type AdminAuditLogUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<AdminAuditLogCreateWithoutActorInput, AdminAuditLogUncheckedCreateWithoutActorInput> | AdminAuditLogCreateWithoutActorInput[] | AdminAuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutActorInput | AdminAuditLogCreateOrConnectWithoutActorInput[]
    createMany?: AdminAuditLogCreateManyActorInputEnvelope
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
  }

  export type LongevityPlanUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LongevityPlanCreateWithoutUserInput, LongevityPlanUncheckedCreateWithoutUserInput> | LongevityPlanCreateWithoutUserInput[] | LongevityPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LongevityPlanCreateOrConnectWithoutUserInput | LongevityPlanCreateOrConnectWithoutUserInput[]
    createMany?: LongevityPlanCreateManyUserInputEnvelope
    connect?: LongevityPlanWhereUniqueInput | LongevityPlanWhereUniqueInput[]
  }

  export type LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput = {
    create?: XOR<LongevityPlanJobCreateWithoutRequestedByInput, LongevityPlanJobUncheckedCreateWithoutRequestedByInput> | LongevityPlanJobCreateWithoutRequestedByInput[] | LongevityPlanJobUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: LongevityPlanJobCreateOrConnectWithoutRequestedByInput | LongevityPlanJobCreateOrConnectWithoutRequestedByInput[]
    createMany?: LongevityPlanJobCreateManyRequestedByInputEnvelope
    connect?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
  }

  export type AiResponseAuditUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AiResponseAuditCreateWithoutUserInput, AiResponseAuditUncheckedCreateWithoutUserInput> | AiResponseAuditCreateWithoutUserInput[] | AiResponseAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiResponseAuditCreateOrConnectWithoutUserInput | AiResponseAuditCreateOrConnectWithoutUserInput[]
    createMany?: AiResponseAuditCreateManyUserInputEnvelope
    connect?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
  }

  export type LoginAuditUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LoginAuditCreateWithoutUserInput, LoginAuditUncheckedCreateWithoutUserInput> | LoginAuditCreateWithoutUserInput[] | LoginAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginAuditCreateOrConnectWithoutUserInput | LoginAuditCreateOrConnectWithoutUserInput[]
    createMany?: LoginAuditCreateManyUserInputEnvelope
    connect?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type AuthProviderUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthProviderCreateWithoutUserInput, AuthProviderUncheckedCreateWithoutUserInput> | AuthProviderCreateWithoutUserInput[] | AuthProviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthProviderCreateOrConnectWithoutUserInput | AuthProviderCreateOrConnectWithoutUserInput[]
    upsert?: AuthProviderUpsertWithWhereUniqueWithoutUserInput | AuthProviderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthProviderCreateManyUserInputEnvelope
    set?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
    disconnect?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
    delete?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
    connect?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
    update?: AuthProviderUpdateWithWhereUniqueWithoutUserInput | AuthProviderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthProviderUpdateManyWithWhereWithoutUserInput | AuthProviderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthProviderScalarWhereInput | AuthProviderScalarWhereInput[]
  }

  export type WhoopIntegrationUpdateOneWithoutUserNestedInput = {
    create?: XOR<WhoopIntegrationCreateWithoutUserInput, WhoopIntegrationUncheckedCreateWithoutUserInput>
    connectOrCreate?: WhoopIntegrationCreateOrConnectWithoutUserInput
    upsert?: WhoopIntegrationUpsertWithoutUserInput
    disconnect?: WhoopIntegrationWhereInput | boolean
    delete?: WhoopIntegrationWhereInput | boolean
    connect?: WhoopIntegrationWhereUniqueInput
    update?: XOR<XOR<WhoopIntegrationUpdateToOneWithWhereWithoutUserInput, WhoopIntegrationUpdateWithoutUserInput>, WhoopIntegrationUncheckedUpdateWithoutUserInput>
  }

  export type WhoopLinkSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhoopLinkSessionCreateWithoutUserInput, WhoopLinkSessionUncheckedCreateWithoutUserInput> | WhoopLinkSessionCreateWithoutUserInput[] | WhoopLinkSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhoopLinkSessionCreateOrConnectWithoutUserInput | WhoopLinkSessionCreateOrConnectWithoutUserInput[]
    upsert?: WhoopLinkSessionUpsertWithWhereUniqueWithoutUserInput | WhoopLinkSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhoopLinkSessionCreateManyUserInputEnvelope
    set?: WhoopLinkSessionWhereUniqueInput | WhoopLinkSessionWhereUniqueInput[]
    disconnect?: WhoopLinkSessionWhereUniqueInput | WhoopLinkSessionWhereUniqueInput[]
    delete?: WhoopLinkSessionWhereUniqueInput | WhoopLinkSessionWhereUniqueInput[]
    connect?: WhoopLinkSessionWhereUniqueInput | WhoopLinkSessionWhereUniqueInput[]
    update?: WhoopLinkSessionUpdateWithWhereUniqueWithoutUserInput | WhoopLinkSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhoopLinkSessionUpdateManyWithWhereWithoutUserInput | WhoopLinkSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhoopLinkSessionScalarWhereInput | WhoopLinkSessionScalarWhereInput[]
  }

  export type InsightUpdateManyWithoutUserNestedInput = {
    create?: XOR<InsightCreateWithoutUserInput, InsightUncheckedCreateWithoutUserInput> | InsightCreateWithoutUserInput[] | InsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InsightCreateOrConnectWithoutUserInput | InsightCreateOrConnectWithoutUserInput[]
    upsert?: InsightUpsertWithWhereUniqueWithoutUserInput | InsightUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InsightCreateManyUserInputEnvelope
    set?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    disconnect?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    delete?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    connect?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    update?: InsightUpdateWithWhereUniqueWithoutUserInput | InsightUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InsightUpdateManyWithWhereWithoutUserInput | InsightUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InsightScalarWhereInput | InsightScalarWhereInput[]
  }

  export type InsightActionUpdateManyWithoutActorNestedInput = {
    create?: XOR<InsightActionCreateWithoutActorInput, InsightActionUncheckedCreateWithoutActorInput> | InsightActionCreateWithoutActorInput[] | InsightActionUncheckedCreateWithoutActorInput[]
    connectOrCreate?: InsightActionCreateOrConnectWithoutActorInput | InsightActionCreateOrConnectWithoutActorInput[]
    upsert?: InsightActionUpsertWithWhereUniqueWithoutActorInput | InsightActionUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: InsightActionCreateManyActorInputEnvelope
    set?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
    disconnect?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
    delete?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
    connect?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
    update?: InsightActionUpdateWithWhereUniqueWithoutActorInput | InsightActionUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: InsightActionUpdateManyWithWhereWithoutActorInput | InsightActionUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: InsightActionScalarWhereInput | InsightActionScalarWhereInput[]
  }

  export type InsightGenerationJobUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<InsightGenerationJobCreateWithoutRequestedByInput, InsightGenerationJobUncheckedCreateWithoutRequestedByInput> | InsightGenerationJobCreateWithoutRequestedByInput[] | InsightGenerationJobUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: InsightGenerationJobCreateOrConnectWithoutRequestedByInput | InsightGenerationJobCreateOrConnectWithoutRequestedByInput[]
    upsert?: InsightGenerationJobUpsertWithWhereUniqueWithoutRequestedByInput | InsightGenerationJobUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: InsightGenerationJobCreateManyRequestedByInputEnvelope
    set?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
    disconnect?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
    delete?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
    connect?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
    update?: InsightGenerationJobUpdateWithWhereUniqueWithoutRequestedByInput | InsightGenerationJobUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: InsightGenerationJobUpdateManyWithWhereWithoutRequestedByInput | InsightGenerationJobUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: InsightGenerationJobScalarWhereInput | InsightGenerationJobScalarWhereInput[]
  }

  export type BiomarkerLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<BiomarkerLogCreateWithoutUserInput, BiomarkerLogUncheckedCreateWithoutUserInput> | BiomarkerLogCreateWithoutUserInput[] | BiomarkerLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BiomarkerLogCreateOrConnectWithoutUserInput | BiomarkerLogCreateOrConnectWithoutUserInput[]
    upsert?: BiomarkerLogUpsertWithWhereUniqueWithoutUserInput | BiomarkerLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BiomarkerLogCreateManyUserInputEnvelope
    set?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
    disconnect?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
    delete?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
    connect?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
    update?: BiomarkerLogUpdateWithWhereUniqueWithoutUserInput | BiomarkerLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BiomarkerLogUpdateManyWithWhereWithoutUserInput | BiomarkerLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BiomarkerLogScalarWhereInput | BiomarkerLogScalarWhereInput[]
  }

  export type PanelUploadUpdateManyWithoutUserNestedInput = {
    create?: XOR<PanelUploadCreateWithoutUserInput, PanelUploadUncheckedCreateWithoutUserInput> | PanelUploadCreateWithoutUserInput[] | PanelUploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PanelUploadCreateOrConnectWithoutUserInput | PanelUploadCreateOrConnectWithoutUserInput[]
    upsert?: PanelUploadUpsertWithWhereUniqueWithoutUserInput | PanelUploadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PanelUploadCreateManyUserInputEnvelope
    set?: PanelUploadWhereUniqueInput | PanelUploadWhereUniqueInput[]
    disconnect?: PanelUploadWhereUniqueInput | PanelUploadWhereUniqueInput[]
    delete?: PanelUploadWhereUniqueInput | PanelUploadWhereUniqueInput[]
    connect?: PanelUploadWhereUniqueInput | PanelUploadWhereUniqueInput[]
    update?: PanelUploadUpdateWithWhereUniqueWithoutUserInput | PanelUploadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PanelUploadUpdateManyWithWhereWithoutUserInput | PanelUploadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PanelUploadScalarWhereInput | PanelUploadScalarWhereInput[]
  }

  export type BiomarkerMeasurementUpdateManyWithoutUserNestedInput = {
    create?: XOR<BiomarkerMeasurementCreateWithoutUserInput, BiomarkerMeasurementUncheckedCreateWithoutUserInput> | BiomarkerMeasurementCreateWithoutUserInput[] | BiomarkerMeasurementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BiomarkerMeasurementCreateOrConnectWithoutUserInput | BiomarkerMeasurementCreateOrConnectWithoutUserInput[]
    upsert?: BiomarkerMeasurementUpsertWithWhereUniqueWithoutUserInput | BiomarkerMeasurementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BiomarkerMeasurementCreateManyUserInputEnvelope
    set?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    disconnect?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    delete?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    connect?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    update?: BiomarkerMeasurementUpdateWithWhereUniqueWithoutUserInput | BiomarkerMeasurementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BiomarkerMeasurementUpdateManyWithWhereWithoutUserInput | BiomarkerMeasurementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BiomarkerMeasurementScalarWhereInput | BiomarkerMeasurementScalarWhereInput[]
  }

  export type FeedPostUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<FeedPostCreateWithoutAuthorInput, FeedPostUncheckedCreateWithoutAuthorInput> | FeedPostCreateWithoutAuthorInput[] | FeedPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: FeedPostCreateOrConnectWithoutAuthorInput | FeedPostCreateOrConnectWithoutAuthorInput[]
    upsert?: FeedPostUpsertWithWhereUniqueWithoutAuthorInput | FeedPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: FeedPostCreateManyAuthorInputEnvelope
    set?: FeedPostWhereUniqueInput | FeedPostWhereUniqueInput[]
    disconnect?: FeedPostWhereUniqueInput | FeedPostWhereUniqueInput[]
    delete?: FeedPostWhereUniqueInput | FeedPostWhereUniqueInput[]
    connect?: FeedPostWhereUniqueInput | FeedPostWhereUniqueInput[]
    update?: FeedPostUpdateWithWhereUniqueWithoutAuthorInput | FeedPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: FeedPostUpdateManyWithWhereWithoutAuthorInput | FeedPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: FeedPostScalarWhereInput | FeedPostScalarWhereInput[]
  }

  export type CommentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutUserInput | ReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutUserInput | ReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutUserInput | ReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type EngagementEventUpdateManyWithoutUserNestedInput = {
    create?: XOR<EngagementEventCreateWithoutUserInput, EngagementEventUncheckedCreateWithoutUserInput> | EngagementEventCreateWithoutUserInput[] | EngagementEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EngagementEventCreateOrConnectWithoutUserInput | EngagementEventCreateOrConnectWithoutUserInput[]
    upsert?: EngagementEventUpsertWithWhereUniqueWithoutUserInput | EngagementEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EngagementEventCreateManyUserInputEnvelope
    set?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    disconnect?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    delete?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    connect?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    update?: EngagementEventUpdateWithWhereUniqueWithoutUserInput | EngagementEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EngagementEventUpdateManyWithWhereWithoutUserInput | EngagementEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EngagementEventScalarWhereInput | EngagementEventScalarWhereInput[]
  }

  export type RoomUpdateManyWithoutHostNestedInput = {
    create?: XOR<RoomCreateWithoutHostInput, RoomUncheckedCreateWithoutHostInput> | RoomCreateWithoutHostInput[] | RoomUncheckedCreateWithoutHostInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutHostInput | RoomCreateOrConnectWithoutHostInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutHostInput | RoomUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: RoomCreateManyHostInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutHostInput | RoomUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutHostInput | RoomUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type RoomMembershipUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoomMembershipCreateWithoutUserInput, RoomMembershipUncheckedCreateWithoutUserInput> | RoomMembershipCreateWithoutUserInput[] | RoomMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutUserInput | RoomMembershipCreateOrConnectWithoutUserInput[]
    upsert?: RoomMembershipUpsertWithWhereUniqueWithoutUserInput | RoomMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoomMembershipCreateManyUserInputEnvelope
    set?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    disconnect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    delete?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    update?: RoomMembershipUpdateWithWhereUniqueWithoutUserInput | RoomMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoomMembershipUpdateManyWithWhereWithoutUserInput | RoomMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoomMembershipScalarWhereInput | RoomMembershipScalarWhereInput[]
  }

  export type FlagUpdateManyWithoutOpenedByNestedInput = {
    create?: XOR<FlagCreateWithoutOpenedByInput, FlagUncheckedCreateWithoutOpenedByInput> | FlagCreateWithoutOpenedByInput[] | FlagUncheckedCreateWithoutOpenedByInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutOpenedByInput | FlagCreateOrConnectWithoutOpenedByInput[]
    upsert?: FlagUpsertWithWhereUniqueWithoutOpenedByInput | FlagUpsertWithWhereUniqueWithoutOpenedByInput[]
    createMany?: FlagCreateManyOpenedByInputEnvelope
    set?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    disconnect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    delete?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    update?: FlagUpdateWithWhereUniqueWithoutOpenedByInput | FlagUpdateWithWhereUniqueWithoutOpenedByInput[]
    updateMany?: FlagUpdateManyWithWhereWithoutOpenedByInput | FlagUpdateManyWithWhereWithoutOpenedByInput[]
    deleteMany?: FlagScalarWhereInput | FlagScalarWhereInput[]
  }

  export type FlagUpdateManyWithoutResolvedByNestedInput = {
    create?: XOR<FlagCreateWithoutResolvedByInput, FlagUncheckedCreateWithoutResolvedByInput> | FlagCreateWithoutResolvedByInput[] | FlagUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutResolvedByInput | FlagCreateOrConnectWithoutResolvedByInput[]
    upsert?: FlagUpsertWithWhereUniqueWithoutResolvedByInput | FlagUpsertWithWhereUniqueWithoutResolvedByInput[]
    createMany?: FlagCreateManyResolvedByInputEnvelope
    set?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    disconnect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    delete?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    update?: FlagUpdateWithWhereUniqueWithoutResolvedByInput | FlagUpdateWithWhereUniqueWithoutResolvedByInput[]
    updateMany?: FlagUpdateManyWithWhereWithoutResolvedByInput | FlagUpdateManyWithWhereWithoutResolvedByInput[]
    deleteMany?: FlagScalarWhereInput | FlagScalarWhereInput[]
  }

  export type AdminAuditLogUpdateManyWithoutActorNestedInput = {
    create?: XOR<AdminAuditLogCreateWithoutActorInput, AdminAuditLogUncheckedCreateWithoutActorInput> | AdminAuditLogCreateWithoutActorInput[] | AdminAuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutActorInput | AdminAuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AdminAuditLogUpsertWithWhereUniqueWithoutActorInput | AdminAuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AdminAuditLogCreateManyActorInputEnvelope
    set?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    disconnect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    delete?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    update?: AdminAuditLogUpdateWithWhereUniqueWithoutActorInput | AdminAuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AdminAuditLogUpdateManyWithWhereWithoutActorInput | AdminAuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
  }

  export type LongevityPlanUpdateManyWithoutUserNestedInput = {
    create?: XOR<LongevityPlanCreateWithoutUserInput, LongevityPlanUncheckedCreateWithoutUserInput> | LongevityPlanCreateWithoutUserInput[] | LongevityPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LongevityPlanCreateOrConnectWithoutUserInput | LongevityPlanCreateOrConnectWithoutUserInput[]
    upsert?: LongevityPlanUpsertWithWhereUniqueWithoutUserInput | LongevityPlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LongevityPlanCreateManyUserInputEnvelope
    set?: LongevityPlanWhereUniqueInput | LongevityPlanWhereUniqueInput[]
    disconnect?: LongevityPlanWhereUniqueInput | LongevityPlanWhereUniqueInput[]
    delete?: LongevityPlanWhereUniqueInput | LongevityPlanWhereUniqueInput[]
    connect?: LongevityPlanWhereUniqueInput | LongevityPlanWhereUniqueInput[]
    update?: LongevityPlanUpdateWithWhereUniqueWithoutUserInput | LongevityPlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LongevityPlanUpdateManyWithWhereWithoutUserInput | LongevityPlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LongevityPlanScalarWhereInput | LongevityPlanScalarWhereInput[]
  }

  export type LongevityPlanJobUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<LongevityPlanJobCreateWithoutRequestedByInput, LongevityPlanJobUncheckedCreateWithoutRequestedByInput> | LongevityPlanJobCreateWithoutRequestedByInput[] | LongevityPlanJobUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: LongevityPlanJobCreateOrConnectWithoutRequestedByInput | LongevityPlanJobCreateOrConnectWithoutRequestedByInput[]
    upsert?: LongevityPlanJobUpsertWithWhereUniqueWithoutRequestedByInput | LongevityPlanJobUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: LongevityPlanJobCreateManyRequestedByInputEnvelope
    set?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
    disconnect?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
    delete?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
    connect?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
    update?: LongevityPlanJobUpdateWithWhereUniqueWithoutRequestedByInput | LongevityPlanJobUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: LongevityPlanJobUpdateManyWithWhereWithoutRequestedByInput | LongevityPlanJobUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: LongevityPlanJobScalarWhereInput | LongevityPlanJobScalarWhereInput[]
  }

  export type AiResponseAuditUpdateManyWithoutUserNestedInput = {
    create?: XOR<AiResponseAuditCreateWithoutUserInput, AiResponseAuditUncheckedCreateWithoutUserInput> | AiResponseAuditCreateWithoutUserInput[] | AiResponseAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiResponseAuditCreateOrConnectWithoutUserInput | AiResponseAuditCreateOrConnectWithoutUserInput[]
    upsert?: AiResponseAuditUpsertWithWhereUniqueWithoutUserInput | AiResponseAuditUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AiResponseAuditCreateManyUserInputEnvelope
    set?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
    disconnect?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
    delete?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
    connect?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
    update?: AiResponseAuditUpdateWithWhereUniqueWithoutUserInput | AiResponseAuditUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AiResponseAuditUpdateManyWithWhereWithoutUserInput | AiResponseAuditUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AiResponseAuditScalarWhereInput | AiResponseAuditScalarWhereInput[]
  }

  export type LoginAuditUpdateManyWithoutUserNestedInput = {
    create?: XOR<LoginAuditCreateWithoutUserInput, LoginAuditUncheckedCreateWithoutUserInput> | LoginAuditCreateWithoutUserInput[] | LoginAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginAuditCreateOrConnectWithoutUserInput | LoginAuditCreateOrConnectWithoutUserInput[]
    upsert?: LoginAuditUpsertWithWhereUniqueWithoutUserInput | LoginAuditUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LoginAuditCreateManyUserInputEnvelope
    set?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
    disconnect?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
    delete?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
    connect?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
    update?: LoginAuditUpdateWithWhereUniqueWithoutUserInput | LoginAuditUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LoginAuditUpdateManyWithWhereWithoutUserInput | LoginAuditUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LoginAuditScalarWhereInput | LoginAuditScalarWhereInput[]
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type AuthProviderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuthProviderCreateWithoutUserInput, AuthProviderUncheckedCreateWithoutUserInput> | AuthProviderCreateWithoutUserInput[] | AuthProviderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuthProviderCreateOrConnectWithoutUserInput | AuthProviderCreateOrConnectWithoutUserInput[]
    upsert?: AuthProviderUpsertWithWhereUniqueWithoutUserInput | AuthProviderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuthProviderCreateManyUserInputEnvelope
    set?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
    disconnect?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
    delete?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
    connect?: AuthProviderWhereUniqueInput | AuthProviderWhereUniqueInput[]
    update?: AuthProviderUpdateWithWhereUniqueWithoutUserInput | AuthProviderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuthProviderUpdateManyWithWhereWithoutUserInput | AuthProviderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuthProviderScalarWhereInput | AuthProviderScalarWhereInput[]
  }

  export type WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<WhoopIntegrationCreateWithoutUserInput, WhoopIntegrationUncheckedCreateWithoutUserInput>
    connectOrCreate?: WhoopIntegrationCreateOrConnectWithoutUserInput
    upsert?: WhoopIntegrationUpsertWithoutUserInput
    disconnect?: WhoopIntegrationWhereInput | boolean
    delete?: WhoopIntegrationWhereInput | boolean
    connect?: WhoopIntegrationWhereUniqueInput
    update?: XOR<XOR<WhoopIntegrationUpdateToOneWithWhereWithoutUserInput, WhoopIntegrationUpdateWithoutUserInput>, WhoopIntegrationUncheckedUpdateWithoutUserInput>
  }

  export type WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WhoopLinkSessionCreateWithoutUserInput, WhoopLinkSessionUncheckedCreateWithoutUserInput> | WhoopLinkSessionCreateWithoutUserInput[] | WhoopLinkSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WhoopLinkSessionCreateOrConnectWithoutUserInput | WhoopLinkSessionCreateOrConnectWithoutUserInput[]
    upsert?: WhoopLinkSessionUpsertWithWhereUniqueWithoutUserInput | WhoopLinkSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WhoopLinkSessionCreateManyUserInputEnvelope
    set?: WhoopLinkSessionWhereUniqueInput | WhoopLinkSessionWhereUniqueInput[]
    disconnect?: WhoopLinkSessionWhereUniqueInput | WhoopLinkSessionWhereUniqueInput[]
    delete?: WhoopLinkSessionWhereUniqueInput | WhoopLinkSessionWhereUniqueInput[]
    connect?: WhoopLinkSessionWhereUniqueInput | WhoopLinkSessionWhereUniqueInput[]
    update?: WhoopLinkSessionUpdateWithWhereUniqueWithoutUserInput | WhoopLinkSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WhoopLinkSessionUpdateManyWithWhereWithoutUserInput | WhoopLinkSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WhoopLinkSessionScalarWhereInput | WhoopLinkSessionScalarWhereInput[]
  }

  export type InsightUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InsightCreateWithoutUserInput, InsightUncheckedCreateWithoutUserInput> | InsightCreateWithoutUserInput[] | InsightUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InsightCreateOrConnectWithoutUserInput | InsightCreateOrConnectWithoutUserInput[]
    upsert?: InsightUpsertWithWhereUniqueWithoutUserInput | InsightUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InsightCreateManyUserInputEnvelope
    set?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    disconnect?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    delete?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    connect?: InsightWhereUniqueInput | InsightWhereUniqueInput[]
    update?: InsightUpdateWithWhereUniqueWithoutUserInput | InsightUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InsightUpdateManyWithWhereWithoutUserInput | InsightUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InsightScalarWhereInput | InsightScalarWhereInput[]
  }

  export type InsightActionUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<InsightActionCreateWithoutActorInput, InsightActionUncheckedCreateWithoutActorInput> | InsightActionCreateWithoutActorInput[] | InsightActionUncheckedCreateWithoutActorInput[]
    connectOrCreate?: InsightActionCreateOrConnectWithoutActorInput | InsightActionCreateOrConnectWithoutActorInput[]
    upsert?: InsightActionUpsertWithWhereUniqueWithoutActorInput | InsightActionUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: InsightActionCreateManyActorInputEnvelope
    set?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
    disconnect?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
    delete?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
    connect?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
    update?: InsightActionUpdateWithWhereUniqueWithoutActorInput | InsightActionUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: InsightActionUpdateManyWithWhereWithoutActorInput | InsightActionUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: InsightActionScalarWhereInput | InsightActionScalarWhereInput[]
  }

  export type InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<InsightGenerationJobCreateWithoutRequestedByInput, InsightGenerationJobUncheckedCreateWithoutRequestedByInput> | InsightGenerationJobCreateWithoutRequestedByInput[] | InsightGenerationJobUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: InsightGenerationJobCreateOrConnectWithoutRequestedByInput | InsightGenerationJobCreateOrConnectWithoutRequestedByInput[]
    upsert?: InsightGenerationJobUpsertWithWhereUniqueWithoutRequestedByInput | InsightGenerationJobUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: InsightGenerationJobCreateManyRequestedByInputEnvelope
    set?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
    disconnect?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
    delete?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
    connect?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
    update?: InsightGenerationJobUpdateWithWhereUniqueWithoutRequestedByInput | InsightGenerationJobUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: InsightGenerationJobUpdateManyWithWhereWithoutRequestedByInput | InsightGenerationJobUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: InsightGenerationJobScalarWhereInput | InsightGenerationJobScalarWhereInput[]
  }

  export type BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BiomarkerLogCreateWithoutUserInput, BiomarkerLogUncheckedCreateWithoutUserInput> | BiomarkerLogCreateWithoutUserInput[] | BiomarkerLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BiomarkerLogCreateOrConnectWithoutUserInput | BiomarkerLogCreateOrConnectWithoutUserInput[]
    upsert?: BiomarkerLogUpsertWithWhereUniqueWithoutUserInput | BiomarkerLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BiomarkerLogCreateManyUserInputEnvelope
    set?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
    disconnect?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
    delete?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
    connect?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
    update?: BiomarkerLogUpdateWithWhereUniqueWithoutUserInput | BiomarkerLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BiomarkerLogUpdateManyWithWhereWithoutUserInput | BiomarkerLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BiomarkerLogScalarWhereInput | BiomarkerLogScalarWhereInput[]
  }

  export type PanelUploadUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PanelUploadCreateWithoutUserInput, PanelUploadUncheckedCreateWithoutUserInput> | PanelUploadCreateWithoutUserInput[] | PanelUploadUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PanelUploadCreateOrConnectWithoutUserInput | PanelUploadCreateOrConnectWithoutUserInput[]
    upsert?: PanelUploadUpsertWithWhereUniqueWithoutUserInput | PanelUploadUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PanelUploadCreateManyUserInputEnvelope
    set?: PanelUploadWhereUniqueInput | PanelUploadWhereUniqueInput[]
    disconnect?: PanelUploadWhereUniqueInput | PanelUploadWhereUniqueInput[]
    delete?: PanelUploadWhereUniqueInput | PanelUploadWhereUniqueInput[]
    connect?: PanelUploadWhereUniqueInput | PanelUploadWhereUniqueInput[]
    update?: PanelUploadUpdateWithWhereUniqueWithoutUserInput | PanelUploadUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PanelUploadUpdateManyWithWhereWithoutUserInput | PanelUploadUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PanelUploadScalarWhereInput | PanelUploadScalarWhereInput[]
  }

  export type BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<BiomarkerMeasurementCreateWithoutUserInput, BiomarkerMeasurementUncheckedCreateWithoutUserInput> | BiomarkerMeasurementCreateWithoutUserInput[] | BiomarkerMeasurementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: BiomarkerMeasurementCreateOrConnectWithoutUserInput | BiomarkerMeasurementCreateOrConnectWithoutUserInput[]
    upsert?: BiomarkerMeasurementUpsertWithWhereUniqueWithoutUserInput | BiomarkerMeasurementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: BiomarkerMeasurementCreateManyUserInputEnvelope
    set?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    disconnect?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    delete?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    connect?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    update?: BiomarkerMeasurementUpdateWithWhereUniqueWithoutUserInput | BiomarkerMeasurementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: BiomarkerMeasurementUpdateManyWithWhereWithoutUserInput | BiomarkerMeasurementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: BiomarkerMeasurementScalarWhereInput | BiomarkerMeasurementScalarWhereInput[]
  }

  export type FeedPostUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<FeedPostCreateWithoutAuthorInput, FeedPostUncheckedCreateWithoutAuthorInput> | FeedPostCreateWithoutAuthorInput[] | FeedPostUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: FeedPostCreateOrConnectWithoutAuthorInput | FeedPostCreateOrConnectWithoutAuthorInput[]
    upsert?: FeedPostUpsertWithWhereUniqueWithoutAuthorInput | FeedPostUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: FeedPostCreateManyAuthorInputEnvelope
    set?: FeedPostWhereUniqueInput | FeedPostWhereUniqueInput[]
    disconnect?: FeedPostWhereUniqueInput | FeedPostWhereUniqueInput[]
    delete?: FeedPostWhereUniqueInput | FeedPostWhereUniqueInput[]
    connect?: FeedPostWhereUniqueInput | FeedPostWhereUniqueInput[]
    update?: FeedPostUpdateWithWhereUniqueWithoutAuthorInput | FeedPostUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: FeedPostUpdateManyWithWhereWithoutAuthorInput | FeedPostUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: FeedPostScalarWhereInput | FeedPostScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput> | CommentCreateWithoutAuthorInput[] | CommentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutAuthorInput | CommentCreateOrConnectWithoutAuthorInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutAuthorInput | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: CommentCreateManyAuthorInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutAuthorInput | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutAuthorInput | CommentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput> | ReactionCreateWithoutUserInput[] | ReactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutUserInput | ReactionCreateOrConnectWithoutUserInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutUserInput | ReactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReactionCreateManyUserInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutUserInput | ReactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutUserInput | ReactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type EngagementEventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EngagementEventCreateWithoutUserInput, EngagementEventUncheckedCreateWithoutUserInput> | EngagementEventCreateWithoutUserInput[] | EngagementEventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EngagementEventCreateOrConnectWithoutUserInput | EngagementEventCreateOrConnectWithoutUserInput[]
    upsert?: EngagementEventUpsertWithWhereUniqueWithoutUserInput | EngagementEventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EngagementEventCreateManyUserInputEnvelope
    set?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    disconnect?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    delete?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    connect?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    update?: EngagementEventUpdateWithWhereUniqueWithoutUserInput | EngagementEventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EngagementEventUpdateManyWithWhereWithoutUserInput | EngagementEventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EngagementEventScalarWhereInput | EngagementEventScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutHostNestedInput = {
    create?: XOR<RoomCreateWithoutHostInput, RoomUncheckedCreateWithoutHostInput> | RoomCreateWithoutHostInput[] | RoomUncheckedCreateWithoutHostInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutHostInput | RoomCreateOrConnectWithoutHostInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutHostInput | RoomUpsertWithWhereUniqueWithoutHostInput[]
    createMany?: RoomCreateManyHostInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutHostInput | RoomUpdateWithWhereUniqueWithoutHostInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutHostInput | RoomUpdateManyWithWhereWithoutHostInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type RoomMembershipUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoomMembershipCreateWithoutUserInput, RoomMembershipUncheckedCreateWithoutUserInput> | RoomMembershipCreateWithoutUserInput[] | RoomMembershipUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutUserInput | RoomMembershipCreateOrConnectWithoutUserInput[]
    upsert?: RoomMembershipUpsertWithWhereUniqueWithoutUserInput | RoomMembershipUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoomMembershipCreateManyUserInputEnvelope
    set?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    disconnect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    delete?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    update?: RoomMembershipUpdateWithWhereUniqueWithoutUserInput | RoomMembershipUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoomMembershipUpdateManyWithWhereWithoutUserInput | RoomMembershipUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoomMembershipScalarWhereInput | RoomMembershipScalarWhereInput[]
  }

  export type FlagUncheckedUpdateManyWithoutOpenedByNestedInput = {
    create?: XOR<FlagCreateWithoutOpenedByInput, FlagUncheckedCreateWithoutOpenedByInput> | FlagCreateWithoutOpenedByInput[] | FlagUncheckedCreateWithoutOpenedByInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutOpenedByInput | FlagCreateOrConnectWithoutOpenedByInput[]
    upsert?: FlagUpsertWithWhereUniqueWithoutOpenedByInput | FlagUpsertWithWhereUniqueWithoutOpenedByInput[]
    createMany?: FlagCreateManyOpenedByInputEnvelope
    set?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    disconnect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    delete?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    update?: FlagUpdateWithWhereUniqueWithoutOpenedByInput | FlagUpdateWithWhereUniqueWithoutOpenedByInput[]
    updateMany?: FlagUpdateManyWithWhereWithoutOpenedByInput | FlagUpdateManyWithWhereWithoutOpenedByInput[]
    deleteMany?: FlagScalarWhereInput | FlagScalarWhereInput[]
  }

  export type FlagUncheckedUpdateManyWithoutResolvedByNestedInput = {
    create?: XOR<FlagCreateWithoutResolvedByInput, FlagUncheckedCreateWithoutResolvedByInput> | FlagCreateWithoutResolvedByInput[] | FlagUncheckedCreateWithoutResolvedByInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutResolvedByInput | FlagCreateOrConnectWithoutResolvedByInput[]
    upsert?: FlagUpsertWithWhereUniqueWithoutResolvedByInput | FlagUpsertWithWhereUniqueWithoutResolvedByInput[]
    createMany?: FlagCreateManyResolvedByInputEnvelope
    set?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    disconnect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    delete?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    update?: FlagUpdateWithWhereUniqueWithoutResolvedByInput | FlagUpdateWithWhereUniqueWithoutResolvedByInput[]
    updateMany?: FlagUpdateManyWithWhereWithoutResolvedByInput | FlagUpdateManyWithWhereWithoutResolvedByInput[]
    deleteMany?: FlagScalarWhereInput | FlagScalarWhereInput[]
  }

  export type AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<AdminAuditLogCreateWithoutActorInput, AdminAuditLogUncheckedCreateWithoutActorInput> | AdminAuditLogCreateWithoutActorInput[] | AdminAuditLogUncheckedCreateWithoutActorInput[]
    connectOrCreate?: AdminAuditLogCreateOrConnectWithoutActorInput | AdminAuditLogCreateOrConnectWithoutActorInput[]
    upsert?: AdminAuditLogUpsertWithWhereUniqueWithoutActorInput | AdminAuditLogUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: AdminAuditLogCreateManyActorInputEnvelope
    set?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    disconnect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    delete?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    connect?: AdminAuditLogWhereUniqueInput | AdminAuditLogWhereUniqueInput[]
    update?: AdminAuditLogUpdateWithWhereUniqueWithoutActorInput | AdminAuditLogUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: AdminAuditLogUpdateManyWithWhereWithoutActorInput | AdminAuditLogUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
  }

  export type LongevityPlanUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LongevityPlanCreateWithoutUserInput, LongevityPlanUncheckedCreateWithoutUserInput> | LongevityPlanCreateWithoutUserInput[] | LongevityPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LongevityPlanCreateOrConnectWithoutUserInput | LongevityPlanCreateOrConnectWithoutUserInput[]
    upsert?: LongevityPlanUpsertWithWhereUniqueWithoutUserInput | LongevityPlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LongevityPlanCreateManyUserInputEnvelope
    set?: LongevityPlanWhereUniqueInput | LongevityPlanWhereUniqueInput[]
    disconnect?: LongevityPlanWhereUniqueInput | LongevityPlanWhereUniqueInput[]
    delete?: LongevityPlanWhereUniqueInput | LongevityPlanWhereUniqueInput[]
    connect?: LongevityPlanWhereUniqueInput | LongevityPlanWhereUniqueInput[]
    update?: LongevityPlanUpdateWithWhereUniqueWithoutUserInput | LongevityPlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LongevityPlanUpdateManyWithWhereWithoutUserInput | LongevityPlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LongevityPlanScalarWhereInput | LongevityPlanScalarWhereInput[]
  }

  export type LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput = {
    create?: XOR<LongevityPlanJobCreateWithoutRequestedByInput, LongevityPlanJobUncheckedCreateWithoutRequestedByInput> | LongevityPlanJobCreateWithoutRequestedByInput[] | LongevityPlanJobUncheckedCreateWithoutRequestedByInput[]
    connectOrCreate?: LongevityPlanJobCreateOrConnectWithoutRequestedByInput | LongevityPlanJobCreateOrConnectWithoutRequestedByInput[]
    upsert?: LongevityPlanJobUpsertWithWhereUniqueWithoutRequestedByInput | LongevityPlanJobUpsertWithWhereUniqueWithoutRequestedByInput[]
    createMany?: LongevityPlanJobCreateManyRequestedByInputEnvelope
    set?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
    disconnect?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
    delete?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
    connect?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
    update?: LongevityPlanJobUpdateWithWhereUniqueWithoutRequestedByInput | LongevityPlanJobUpdateWithWhereUniqueWithoutRequestedByInput[]
    updateMany?: LongevityPlanJobUpdateManyWithWhereWithoutRequestedByInput | LongevityPlanJobUpdateManyWithWhereWithoutRequestedByInput[]
    deleteMany?: LongevityPlanJobScalarWhereInput | LongevityPlanJobScalarWhereInput[]
  }

  export type AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AiResponseAuditCreateWithoutUserInput, AiResponseAuditUncheckedCreateWithoutUserInput> | AiResponseAuditCreateWithoutUserInput[] | AiResponseAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AiResponseAuditCreateOrConnectWithoutUserInput | AiResponseAuditCreateOrConnectWithoutUserInput[]
    upsert?: AiResponseAuditUpsertWithWhereUniqueWithoutUserInput | AiResponseAuditUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AiResponseAuditCreateManyUserInputEnvelope
    set?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
    disconnect?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
    delete?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
    connect?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
    update?: AiResponseAuditUpdateWithWhereUniqueWithoutUserInput | AiResponseAuditUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AiResponseAuditUpdateManyWithWhereWithoutUserInput | AiResponseAuditUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AiResponseAuditScalarWhereInput | AiResponseAuditScalarWhereInput[]
  }

  export type LoginAuditUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LoginAuditCreateWithoutUserInput, LoginAuditUncheckedCreateWithoutUserInput> | LoginAuditCreateWithoutUserInput[] | LoginAuditUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LoginAuditCreateOrConnectWithoutUserInput | LoginAuditCreateOrConnectWithoutUserInput[]
    upsert?: LoginAuditUpsertWithWhereUniqueWithoutUserInput | LoginAuditUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LoginAuditCreateManyUserInputEnvelope
    set?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
    disconnect?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
    delete?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
    connect?: LoginAuditWhereUniqueInput | LoginAuditWhereUniqueInput[]
    update?: LoginAuditUpdateWithWhereUniqueWithoutUserInput | LoginAuditUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LoginAuditUpdateManyWithWhereWithoutUserInput | LoginAuditUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LoginAuditScalarWhereInput | LoginAuditScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutInsightsInput = {
    create?: XOR<UserCreateWithoutInsightsInput, UserUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInsightsInput
    connect?: UserWhereUniqueInput
  }

  export type InsightActionCreateNestedManyWithoutInsightInput = {
    create?: XOR<InsightActionCreateWithoutInsightInput, InsightActionUncheckedCreateWithoutInsightInput> | InsightActionCreateWithoutInsightInput[] | InsightActionUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightActionCreateOrConnectWithoutInsightInput | InsightActionCreateOrConnectWithoutInsightInput[]
    createMany?: InsightActionCreateManyInsightInputEnvelope
    connect?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
  }

  export type InsightGenerationJobCreateNestedManyWithoutInsightInput = {
    create?: XOR<InsightGenerationJobCreateWithoutInsightInput, InsightGenerationJobUncheckedCreateWithoutInsightInput> | InsightGenerationJobCreateWithoutInsightInput[] | InsightGenerationJobUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightGenerationJobCreateOrConnectWithoutInsightInput | InsightGenerationJobCreateOrConnectWithoutInsightInput[]
    createMany?: InsightGenerationJobCreateManyInsightInputEnvelope
    connect?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
  }

  export type FlagCreateNestedManyWithoutInsightInput = {
    create?: XOR<FlagCreateWithoutInsightInput, FlagUncheckedCreateWithoutInsightInput> | FlagCreateWithoutInsightInput[] | FlagUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutInsightInput | FlagCreateOrConnectWithoutInsightInput[]
    createMany?: FlagCreateManyInsightInputEnvelope
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
  }

  export type InsightActionUncheckedCreateNestedManyWithoutInsightInput = {
    create?: XOR<InsightActionCreateWithoutInsightInput, InsightActionUncheckedCreateWithoutInsightInput> | InsightActionCreateWithoutInsightInput[] | InsightActionUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightActionCreateOrConnectWithoutInsightInput | InsightActionCreateOrConnectWithoutInsightInput[]
    createMany?: InsightActionCreateManyInsightInputEnvelope
    connect?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
  }

  export type InsightGenerationJobUncheckedCreateNestedManyWithoutInsightInput = {
    create?: XOR<InsightGenerationJobCreateWithoutInsightInput, InsightGenerationJobUncheckedCreateWithoutInsightInput> | InsightGenerationJobCreateWithoutInsightInput[] | InsightGenerationJobUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightGenerationJobCreateOrConnectWithoutInsightInput | InsightGenerationJobCreateOrConnectWithoutInsightInput[]
    createMany?: InsightGenerationJobCreateManyInsightInputEnvelope
    connect?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
  }

  export type FlagUncheckedCreateNestedManyWithoutInsightInput = {
    create?: XOR<FlagCreateWithoutInsightInput, FlagUncheckedCreateWithoutInsightInput> | FlagCreateWithoutInsightInput[] | FlagUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutInsightInput | FlagCreateOrConnectWithoutInsightInput[]
    createMany?: FlagCreateManyInsightInputEnvelope
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
  }

  export type EnumInsightStatusFieldUpdateOperationsInput = {
    set?: $Enums.InsightStatus
  }

  export type UserUpdateOneRequiredWithoutInsightsNestedInput = {
    create?: XOR<UserCreateWithoutInsightsInput, UserUncheckedCreateWithoutInsightsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInsightsInput
    upsert?: UserUpsertWithoutInsightsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInsightsInput, UserUpdateWithoutInsightsInput>, UserUncheckedUpdateWithoutInsightsInput>
  }

  export type InsightActionUpdateManyWithoutInsightNestedInput = {
    create?: XOR<InsightActionCreateWithoutInsightInput, InsightActionUncheckedCreateWithoutInsightInput> | InsightActionCreateWithoutInsightInput[] | InsightActionUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightActionCreateOrConnectWithoutInsightInput | InsightActionCreateOrConnectWithoutInsightInput[]
    upsert?: InsightActionUpsertWithWhereUniqueWithoutInsightInput | InsightActionUpsertWithWhereUniqueWithoutInsightInput[]
    createMany?: InsightActionCreateManyInsightInputEnvelope
    set?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
    disconnect?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
    delete?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
    connect?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
    update?: InsightActionUpdateWithWhereUniqueWithoutInsightInput | InsightActionUpdateWithWhereUniqueWithoutInsightInput[]
    updateMany?: InsightActionUpdateManyWithWhereWithoutInsightInput | InsightActionUpdateManyWithWhereWithoutInsightInput[]
    deleteMany?: InsightActionScalarWhereInput | InsightActionScalarWhereInput[]
  }

  export type InsightGenerationJobUpdateManyWithoutInsightNestedInput = {
    create?: XOR<InsightGenerationJobCreateWithoutInsightInput, InsightGenerationJobUncheckedCreateWithoutInsightInput> | InsightGenerationJobCreateWithoutInsightInput[] | InsightGenerationJobUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightGenerationJobCreateOrConnectWithoutInsightInput | InsightGenerationJobCreateOrConnectWithoutInsightInput[]
    upsert?: InsightGenerationJobUpsertWithWhereUniqueWithoutInsightInput | InsightGenerationJobUpsertWithWhereUniqueWithoutInsightInput[]
    createMany?: InsightGenerationJobCreateManyInsightInputEnvelope
    set?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
    disconnect?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
    delete?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
    connect?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
    update?: InsightGenerationJobUpdateWithWhereUniqueWithoutInsightInput | InsightGenerationJobUpdateWithWhereUniqueWithoutInsightInput[]
    updateMany?: InsightGenerationJobUpdateManyWithWhereWithoutInsightInput | InsightGenerationJobUpdateManyWithWhereWithoutInsightInput[]
    deleteMany?: InsightGenerationJobScalarWhereInput | InsightGenerationJobScalarWhereInput[]
  }

  export type FlagUpdateManyWithoutInsightNestedInput = {
    create?: XOR<FlagCreateWithoutInsightInput, FlagUncheckedCreateWithoutInsightInput> | FlagCreateWithoutInsightInput[] | FlagUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutInsightInput | FlagCreateOrConnectWithoutInsightInput[]
    upsert?: FlagUpsertWithWhereUniqueWithoutInsightInput | FlagUpsertWithWhereUniqueWithoutInsightInput[]
    createMany?: FlagCreateManyInsightInputEnvelope
    set?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    disconnect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    delete?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    update?: FlagUpdateWithWhereUniqueWithoutInsightInput | FlagUpdateWithWhereUniqueWithoutInsightInput[]
    updateMany?: FlagUpdateManyWithWhereWithoutInsightInput | FlagUpdateManyWithWhereWithoutInsightInput[]
    deleteMany?: FlagScalarWhereInput | FlagScalarWhereInput[]
  }

  export type InsightActionUncheckedUpdateManyWithoutInsightNestedInput = {
    create?: XOR<InsightActionCreateWithoutInsightInput, InsightActionUncheckedCreateWithoutInsightInput> | InsightActionCreateWithoutInsightInput[] | InsightActionUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightActionCreateOrConnectWithoutInsightInput | InsightActionCreateOrConnectWithoutInsightInput[]
    upsert?: InsightActionUpsertWithWhereUniqueWithoutInsightInput | InsightActionUpsertWithWhereUniqueWithoutInsightInput[]
    createMany?: InsightActionCreateManyInsightInputEnvelope
    set?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
    disconnect?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
    delete?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
    connect?: InsightActionWhereUniqueInput | InsightActionWhereUniqueInput[]
    update?: InsightActionUpdateWithWhereUniqueWithoutInsightInput | InsightActionUpdateWithWhereUniqueWithoutInsightInput[]
    updateMany?: InsightActionUpdateManyWithWhereWithoutInsightInput | InsightActionUpdateManyWithWhereWithoutInsightInput[]
    deleteMany?: InsightActionScalarWhereInput | InsightActionScalarWhereInput[]
  }

  export type InsightGenerationJobUncheckedUpdateManyWithoutInsightNestedInput = {
    create?: XOR<InsightGenerationJobCreateWithoutInsightInput, InsightGenerationJobUncheckedCreateWithoutInsightInput> | InsightGenerationJobCreateWithoutInsightInput[] | InsightGenerationJobUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: InsightGenerationJobCreateOrConnectWithoutInsightInput | InsightGenerationJobCreateOrConnectWithoutInsightInput[]
    upsert?: InsightGenerationJobUpsertWithWhereUniqueWithoutInsightInput | InsightGenerationJobUpsertWithWhereUniqueWithoutInsightInput[]
    createMany?: InsightGenerationJobCreateManyInsightInputEnvelope
    set?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
    disconnect?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
    delete?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
    connect?: InsightGenerationJobWhereUniqueInput | InsightGenerationJobWhereUniqueInput[]
    update?: InsightGenerationJobUpdateWithWhereUniqueWithoutInsightInput | InsightGenerationJobUpdateWithWhereUniqueWithoutInsightInput[]
    updateMany?: InsightGenerationJobUpdateManyWithWhereWithoutInsightInput | InsightGenerationJobUpdateManyWithWhereWithoutInsightInput[]
    deleteMany?: InsightGenerationJobScalarWhereInput | InsightGenerationJobScalarWhereInput[]
  }

  export type FlagUncheckedUpdateManyWithoutInsightNestedInput = {
    create?: XOR<FlagCreateWithoutInsightInput, FlagUncheckedCreateWithoutInsightInput> | FlagCreateWithoutInsightInput[] | FlagUncheckedCreateWithoutInsightInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutInsightInput | FlagCreateOrConnectWithoutInsightInput[]
    upsert?: FlagUpsertWithWhereUniqueWithoutInsightInput | FlagUpsertWithWhereUniqueWithoutInsightInput[]
    createMany?: FlagCreateManyInsightInputEnvelope
    set?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    disconnect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    delete?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    update?: FlagUpdateWithWhereUniqueWithoutInsightInput | FlagUpdateWithWhereUniqueWithoutInsightInput[]
    updateMany?: FlagUpdateManyWithWhereWithoutInsightInput | FlagUpdateManyWithWhereWithoutInsightInput[]
    deleteMany?: FlagScalarWhereInput | FlagScalarWhereInput[]
  }

  export type LongevityPlanCreatefocusAreasInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutLongevityPlansInput = {
    create?: XOR<UserCreateWithoutLongevityPlansInput, UserUncheckedCreateWithoutLongevityPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutLongevityPlansInput
    connect?: UserWhereUniqueInput
  }

  export type LongevityPlanJobCreateNestedManyWithoutPlanInput = {
    create?: XOR<LongevityPlanJobCreateWithoutPlanInput, LongevityPlanJobUncheckedCreateWithoutPlanInput> | LongevityPlanJobCreateWithoutPlanInput[] | LongevityPlanJobUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: LongevityPlanJobCreateOrConnectWithoutPlanInput | LongevityPlanJobCreateOrConnectWithoutPlanInput[]
    createMany?: LongevityPlanJobCreateManyPlanInputEnvelope
    connect?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
  }

  export type AiResponseAuditCreateNestedManyWithoutPlanInput = {
    create?: XOR<AiResponseAuditCreateWithoutPlanInput, AiResponseAuditUncheckedCreateWithoutPlanInput> | AiResponseAuditCreateWithoutPlanInput[] | AiResponseAuditUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: AiResponseAuditCreateOrConnectWithoutPlanInput | AiResponseAuditCreateOrConnectWithoutPlanInput[]
    createMany?: AiResponseAuditCreateManyPlanInputEnvelope
    connect?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
  }

  export type LongevityPlanJobUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<LongevityPlanJobCreateWithoutPlanInput, LongevityPlanJobUncheckedCreateWithoutPlanInput> | LongevityPlanJobCreateWithoutPlanInput[] | LongevityPlanJobUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: LongevityPlanJobCreateOrConnectWithoutPlanInput | LongevityPlanJobCreateOrConnectWithoutPlanInput[]
    createMany?: LongevityPlanJobCreateManyPlanInputEnvelope
    connect?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
  }

  export type AiResponseAuditUncheckedCreateNestedManyWithoutPlanInput = {
    create?: XOR<AiResponseAuditCreateWithoutPlanInput, AiResponseAuditUncheckedCreateWithoutPlanInput> | AiResponseAuditCreateWithoutPlanInput[] | AiResponseAuditUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: AiResponseAuditCreateOrConnectWithoutPlanInput | AiResponseAuditCreateOrConnectWithoutPlanInput[]
    createMany?: AiResponseAuditCreateManyPlanInputEnvelope
    connect?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
  }

  export type EnumLongevityPlanStatusFieldUpdateOperationsInput = {
    set?: $Enums.LongevityPlanStatus
  }

  export type LongevityPlanUpdatefocusAreasInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutLongevityPlansNestedInput = {
    create?: XOR<UserCreateWithoutLongevityPlansInput, UserUncheckedCreateWithoutLongevityPlansInput>
    connectOrCreate?: UserCreateOrConnectWithoutLongevityPlansInput
    upsert?: UserUpsertWithoutLongevityPlansInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLongevityPlansInput, UserUpdateWithoutLongevityPlansInput>, UserUncheckedUpdateWithoutLongevityPlansInput>
  }

  export type LongevityPlanJobUpdateManyWithoutPlanNestedInput = {
    create?: XOR<LongevityPlanJobCreateWithoutPlanInput, LongevityPlanJobUncheckedCreateWithoutPlanInput> | LongevityPlanJobCreateWithoutPlanInput[] | LongevityPlanJobUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: LongevityPlanJobCreateOrConnectWithoutPlanInput | LongevityPlanJobCreateOrConnectWithoutPlanInput[]
    upsert?: LongevityPlanJobUpsertWithWhereUniqueWithoutPlanInput | LongevityPlanJobUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: LongevityPlanJobCreateManyPlanInputEnvelope
    set?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
    disconnect?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
    delete?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
    connect?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
    update?: LongevityPlanJobUpdateWithWhereUniqueWithoutPlanInput | LongevityPlanJobUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: LongevityPlanJobUpdateManyWithWhereWithoutPlanInput | LongevityPlanJobUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: LongevityPlanJobScalarWhereInput | LongevityPlanJobScalarWhereInput[]
  }

  export type AiResponseAuditUpdateManyWithoutPlanNestedInput = {
    create?: XOR<AiResponseAuditCreateWithoutPlanInput, AiResponseAuditUncheckedCreateWithoutPlanInput> | AiResponseAuditCreateWithoutPlanInput[] | AiResponseAuditUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: AiResponseAuditCreateOrConnectWithoutPlanInput | AiResponseAuditCreateOrConnectWithoutPlanInput[]
    upsert?: AiResponseAuditUpsertWithWhereUniqueWithoutPlanInput | AiResponseAuditUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: AiResponseAuditCreateManyPlanInputEnvelope
    set?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
    disconnect?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
    delete?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
    connect?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
    update?: AiResponseAuditUpdateWithWhereUniqueWithoutPlanInput | AiResponseAuditUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: AiResponseAuditUpdateManyWithWhereWithoutPlanInput | AiResponseAuditUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: AiResponseAuditScalarWhereInput | AiResponseAuditScalarWhereInput[]
  }

  export type LongevityPlanJobUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<LongevityPlanJobCreateWithoutPlanInput, LongevityPlanJobUncheckedCreateWithoutPlanInput> | LongevityPlanJobCreateWithoutPlanInput[] | LongevityPlanJobUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: LongevityPlanJobCreateOrConnectWithoutPlanInput | LongevityPlanJobCreateOrConnectWithoutPlanInput[]
    upsert?: LongevityPlanJobUpsertWithWhereUniqueWithoutPlanInput | LongevityPlanJobUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: LongevityPlanJobCreateManyPlanInputEnvelope
    set?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
    disconnect?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
    delete?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
    connect?: LongevityPlanJobWhereUniqueInput | LongevityPlanJobWhereUniqueInput[]
    update?: LongevityPlanJobUpdateWithWhereUniqueWithoutPlanInput | LongevityPlanJobUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: LongevityPlanJobUpdateManyWithWhereWithoutPlanInput | LongevityPlanJobUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: LongevityPlanJobScalarWhereInput | LongevityPlanJobScalarWhereInput[]
  }

  export type AiResponseAuditUncheckedUpdateManyWithoutPlanNestedInput = {
    create?: XOR<AiResponseAuditCreateWithoutPlanInput, AiResponseAuditUncheckedCreateWithoutPlanInput> | AiResponseAuditCreateWithoutPlanInput[] | AiResponseAuditUncheckedCreateWithoutPlanInput[]
    connectOrCreate?: AiResponseAuditCreateOrConnectWithoutPlanInput | AiResponseAuditCreateOrConnectWithoutPlanInput[]
    upsert?: AiResponseAuditUpsertWithWhereUniqueWithoutPlanInput | AiResponseAuditUpsertWithWhereUniqueWithoutPlanInput[]
    createMany?: AiResponseAuditCreateManyPlanInputEnvelope
    set?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
    disconnect?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
    delete?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
    connect?: AiResponseAuditWhereUniqueInput | AiResponseAuditWhereUniqueInput[]
    update?: AiResponseAuditUpdateWithWhereUniqueWithoutPlanInput | AiResponseAuditUpdateWithWhereUniqueWithoutPlanInput[]
    updateMany?: AiResponseAuditUpdateManyWithWhereWithoutPlanInput | AiResponseAuditUpdateManyWithWhereWithoutPlanInput[]
    deleteMany?: AiResponseAuditScalarWhereInput | AiResponseAuditScalarWhereInput[]
  }

  export type BiomarkerLogCreateNestedManyWithoutBiomarkerInput = {
    create?: XOR<BiomarkerLogCreateWithoutBiomarkerInput, BiomarkerLogUncheckedCreateWithoutBiomarkerInput> | BiomarkerLogCreateWithoutBiomarkerInput[] | BiomarkerLogUncheckedCreateWithoutBiomarkerInput[]
    connectOrCreate?: BiomarkerLogCreateOrConnectWithoutBiomarkerInput | BiomarkerLogCreateOrConnectWithoutBiomarkerInput[]
    createMany?: BiomarkerLogCreateManyBiomarkerInputEnvelope
    connect?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
  }

  export type BiomarkerMeasurementCreateNestedManyWithoutBiomarkerInput = {
    create?: XOR<BiomarkerMeasurementCreateWithoutBiomarkerInput, BiomarkerMeasurementUncheckedCreateWithoutBiomarkerInput> | BiomarkerMeasurementCreateWithoutBiomarkerInput[] | BiomarkerMeasurementUncheckedCreateWithoutBiomarkerInput[]
    connectOrCreate?: BiomarkerMeasurementCreateOrConnectWithoutBiomarkerInput | BiomarkerMeasurementCreateOrConnectWithoutBiomarkerInput[]
    createMany?: BiomarkerMeasurementCreateManyBiomarkerInputEnvelope
    connect?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
  }

  export type BiomarkerLogUncheckedCreateNestedManyWithoutBiomarkerInput = {
    create?: XOR<BiomarkerLogCreateWithoutBiomarkerInput, BiomarkerLogUncheckedCreateWithoutBiomarkerInput> | BiomarkerLogCreateWithoutBiomarkerInput[] | BiomarkerLogUncheckedCreateWithoutBiomarkerInput[]
    connectOrCreate?: BiomarkerLogCreateOrConnectWithoutBiomarkerInput | BiomarkerLogCreateOrConnectWithoutBiomarkerInput[]
    createMany?: BiomarkerLogCreateManyBiomarkerInputEnvelope
    connect?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
  }

  export type BiomarkerMeasurementUncheckedCreateNestedManyWithoutBiomarkerInput = {
    create?: XOR<BiomarkerMeasurementCreateWithoutBiomarkerInput, BiomarkerMeasurementUncheckedCreateWithoutBiomarkerInput> | BiomarkerMeasurementCreateWithoutBiomarkerInput[] | BiomarkerMeasurementUncheckedCreateWithoutBiomarkerInput[]
    connectOrCreate?: BiomarkerMeasurementCreateOrConnectWithoutBiomarkerInput | BiomarkerMeasurementCreateOrConnectWithoutBiomarkerInput[]
    createMany?: BiomarkerMeasurementCreateManyBiomarkerInputEnvelope
    connect?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumBiomarkerSourceFieldUpdateOperationsInput = {
    set?: $Enums.BiomarkerSource
  }

  export type BiomarkerLogUpdateManyWithoutBiomarkerNestedInput = {
    create?: XOR<BiomarkerLogCreateWithoutBiomarkerInput, BiomarkerLogUncheckedCreateWithoutBiomarkerInput> | BiomarkerLogCreateWithoutBiomarkerInput[] | BiomarkerLogUncheckedCreateWithoutBiomarkerInput[]
    connectOrCreate?: BiomarkerLogCreateOrConnectWithoutBiomarkerInput | BiomarkerLogCreateOrConnectWithoutBiomarkerInput[]
    upsert?: BiomarkerLogUpsertWithWhereUniqueWithoutBiomarkerInput | BiomarkerLogUpsertWithWhereUniqueWithoutBiomarkerInput[]
    createMany?: BiomarkerLogCreateManyBiomarkerInputEnvelope
    set?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
    disconnect?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
    delete?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
    connect?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
    update?: BiomarkerLogUpdateWithWhereUniqueWithoutBiomarkerInput | BiomarkerLogUpdateWithWhereUniqueWithoutBiomarkerInput[]
    updateMany?: BiomarkerLogUpdateManyWithWhereWithoutBiomarkerInput | BiomarkerLogUpdateManyWithWhereWithoutBiomarkerInput[]
    deleteMany?: BiomarkerLogScalarWhereInput | BiomarkerLogScalarWhereInput[]
  }

  export type BiomarkerMeasurementUpdateManyWithoutBiomarkerNestedInput = {
    create?: XOR<BiomarkerMeasurementCreateWithoutBiomarkerInput, BiomarkerMeasurementUncheckedCreateWithoutBiomarkerInput> | BiomarkerMeasurementCreateWithoutBiomarkerInput[] | BiomarkerMeasurementUncheckedCreateWithoutBiomarkerInput[]
    connectOrCreate?: BiomarkerMeasurementCreateOrConnectWithoutBiomarkerInput | BiomarkerMeasurementCreateOrConnectWithoutBiomarkerInput[]
    upsert?: BiomarkerMeasurementUpsertWithWhereUniqueWithoutBiomarkerInput | BiomarkerMeasurementUpsertWithWhereUniqueWithoutBiomarkerInput[]
    createMany?: BiomarkerMeasurementCreateManyBiomarkerInputEnvelope
    set?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    disconnect?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    delete?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    connect?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    update?: BiomarkerMeasurementUpdateWithWhereUniqueWithoutBiomarkerInput | BiomarkerMeasurementUpdateWithWhereUniqueWithoutBiomarkerInput[]
    updateMany?: BiomarkerMeasurementUpdateManyWithWhereWithoutBiomarkerInput | BiomarkerMeasurementUpdateManyWithWhereWithoutBiomarkerInput[]
    deleteMany?: BiomarkerMeasurementScalarWhereInput | BiomarkerMeasurementScalarWhereInput[]
  }

  export type BiomarkerLogUncheckedUpdateManyWithoutBiomarkerNestedInput = {
    create?: XOR<BiomarkerLogCreateWithoutBiomarkerInput, BiomarkerLogUncheckedCreateWithoutBiomarkerInput> | BiomarkerLogCreateWithoutBiomarkerInput[] | BiomarkerLogUncheckedCreateWithoutBiomarkerInput[]
    connectOrCreate?: BiomarkerLogCreateOrConnectWithoutBiomarkerInput | BiomarkerLogCreateOrConnectWithoutBiomarkerInput[]
    upsert?: BiomarkerLogUpsertWithWhereUniqueWithoutBiomarkerInput | BiomarkerLogUpsertWithWhereUniqueWithoutBiomarkerInput[]
    createMany?: BiomarkerLogCreateManyBiomarkerInputEnvelope
    set?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
    disconnect?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
    delete?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
    connect?: BiomarkerLogWhereUniqueInput | BiomarkerLogWhereUniqueInput[]
    update?: BiomarkerLogUpdateWithWhereUniqueWithoutBiomarkerInput | BiomarkerLogUpdateWithWhereUniqueWithoutBiomarkerInput[]
    updateMany?: BiomarkerLogUpdateManyWithWhereWithoutBiomarkerInput | BiomarkerLogUpdateManyWithWhereWithoutBiomarkerInput[]
    deleteMany?: BiomarkerLogScalarWhereInput | BiomarkerLogScalarWhereInput[]
  }

  export type BiomarkerMeasurementUncheckedUpdateManyWithoutBiomarkerNestedInput = {
    create?: XOR<BiomarkerMeasurementCreateWithoutBiomarkerInput, BiomarkerMeasurementUncheckedCreateWithoutBiomarkerInput> | BiomarkerMeasurementCreateWithoutBiomarkerInput[] | BiomarkerMeasurementUncheckedCreateWithoutBiomarkerInput[]
    connectOrCreate?: BiomarkerMeasurementCreateOrConnectWithoutBiomarkerInput | BiomarkerMeasurementCreateOrConnectWithoutBiomarkerInput[]
    upsert?: BiomarkerMeasurementUpsertWithWhereUniqueWithoutBiomarkerInput | BiomarkerMeasurementUpsertWithWhereUniqueWithoutBiomarkerInput[]
    createMany?: BiomarkerMeasurementCreateManyBiomarkerInputEnvelope
    set?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    disconnect?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    delete?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    connect?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    update?: BiomarkerMeasurementUpdateWithWhereUniqueWithoutBiomarkerInput | BiomarkerMeasurementUpdateWithWhereUniqueWithoutBiomarkerInput[]
    updateMany?: BiomarkerMeasurementUpdateManyWithWhereWithoutBiomarkerInput | BiomarkerMeasurementUpdateManyWithWhereWithoutBiomarkerInput[]
    deleteMany?: BiomarkerMeasurementScalarWhereInput | BiomarkerMeasurementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBiomarkerLogsInput = {
    create?: XOR<UserCreateWithoutBiomarkerLogsInput, UserUncheckedCreateWithoutBiomarkerLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBiomarkerLogsInput
    connect?: UserWhereUniqueInput
  }

  export type BiomarkerCreateNestedOneWithoutLogsInput = {
    create?: XOR<BiomarkerCreateWithoutLogsInput, BiomarkerUncheckedCreateWithoutLogsInput>
    connectOrCreate?: BiomarkerCreateOrConnectWithoutLogsInput
    connect?: BiomarkerWhereUniqueInput
  }

  export type FlagCreateNestedManyWithoutBiomarkerLogInput = {
    create?: XOR<FlagCreateWithoutBiomarkerLogInput, FlagUncheckedCreateWithoutBiomarkerLogInput> | FlagCreateWithoutBiomarkerLogInput[] | FlagUncheckedCreateWithoutBiomarkerLogInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutBiomarkerLogInput | FlagCreateOrConnectWithoutBiomarkerLogInput[]
    createMany?: FlagCreateManyBiomarkerLogInputEnvelope
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
  }

  export type FlagUncheckedCreateNestedManyWithoutBiomarkerLogInput = {
    create?: XOR<FlagCreateWithoutBiomarkerLogInput, FlagUncheckedCreateWithoutBiomarkerLogInput> | FlagCreateWithoutBiomarkerLogInput[] | FlagUncheckedCreateWithoutBiomarkerLogInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutBiomarkerLogInput | FlagCreateOrConnectWithoutBiomarkerLogInput[]
    createMany?: FlagCreateManyBiomarkerLogInputEnvelope
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutBiomarkerLogsNestedInput = {
    create?: XOR<UserCreateWithoutBiomarkerLogsInput, UserUncheckedCreateWithoutBiomarkerLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBiomarkerLogsInput
    upsert?: UserUpsertWithoutBiomarkerLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBiomarkerLogsInput, UserUpdateWithoutBiomarkerLogsInput>, UserUncheckedUpdateWithoutBiomarkerLogsInput>
  }

  export type BiomarkerUpdateOneRequiredWithoutLogsNestedInput = {
    create?: XOR<BiomarkerCreateWithoutLogsInput, BiomarkerUncheckedCreateWithoutLogsInput>
    connectOrCreate?: BiomarkerCreateOrConnectWithoutLogsInput
    upsert?: BiomarkerUpsertWithoutLogsInput
    connect?: BiomarkerWhereUniqueInput
    update?: XOR<XOR<BiomarkerUpdateToOneWithWhereWithoutLogsInput, BiomarkerUpdateWithoutLogsInput>, BiomarkerUncheckedUpdateWithoutLogsInput>
  }

  export type FlagUpdateManyWithoutBiomarkerLogNestedInput = {
    create?: XOR<FlagCreateWithoutBiomarkerLogInput, FlagUncheckedCreateWithoutBiomarkerLogInput> | FlagCreateWithoutBiomarkerLogInput[] | FlagUncheckedCreateWithoutBiomarkerLogInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutBiomarkerLogInput | FlagCreateOrConnectWithoutBiomarkerLogInput[]
    upsert?: FlagUpsertWithWhereUniqueWithoutBiomarkerLogInput | FlagUpsertWithWhereUniqueWithoutBiomarkerLogInput[]
    createMany?: FlagCreateManyBiomarkerLogInputEnvelope
    set?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    disconnect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    delete?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    update?: FlagUpdateWithWhereUniqueWithoutBiomarkerLogInput | FlagUpdateWithWhereUniqueWithoutBiomarkerLogInput[]
    updateMany?: FlagUpdateManyWithWhereWithoutBiomarkerLogInput | FlagUpdateManyWithWhereWithoutBiomarkerLogInput[]
    deleteMany?: FlagScalarWhereInput | FlagScalarWhereInput[]
  }

  export type FlagUncheckedUpdateManyWithoutBiomarkerLogNestedInput = {
    create?: XOR<FlagCreateWithoutBiomarkerLogInput, FlagUncheckedCreateWithoutBiomarkerLogInput> | FlagCreateWithoutBiomarkerLogInput[] | FlagUncheckedCreateWithoutBiomarkerLogInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutBiomarkerLogInput | FlagCreateOrConnectWithoutBiomarkerLogInput[]
    upsert?: FlagUpsertWithWhereUniqueWithoutBiomarkerLogInput | FlagUpsertWithWhereUniqueWithoutBiomarkerLogInput[]
    createMany?: FlagCreateManyBiomarkerLogInputEnvelope
    set?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    disconnect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    delete?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    update?: FlagUpdateWithWhereUniqueWithoutBiomarkerLogInput | FlagUpdateWithWhereUniqueWithoutBiomarkerLogInput[]
    updateMany?: FlagUpdateManyWithWhereWithoutBiomarkerLogInput | FlagUpdateManyWithWhereWithoutBiomarkerLogInput[]
    deleteMany?: FlagScalarWhereInput | FlagScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPanelUploadsInput = {
    create?: XOR<UserCreateWithoutPanelUploadsInput, UserUncheckedCreateWithoutPanelUploadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPanelUploadsInput
    connect?: UserWhereUniqueInput
  }

  export type BiomarkerMeasurementCreateNestedManyWithoutPanelUploadInput = {
    create?: XOR<BiomarkerMeasurementCreateWithoutPanelUploadInput, BiomarkerMeasurementUncheckedCreateWithoutPanelUploadInput> | BiomarkerMeasurementCreateWithoutPanelUploadInput[] | BiomarkerMeasurementUncheckedCreateWithoutPanelUploadInput[]
    connectOrCreate?: BiomarkerMeasurementCreateOrConnectWithoutPanelUploadInput | BiomarkerMeasurementCreateOrConnectWithoutPanelUploadInput[]
    createMany?: BiomarkerMeasurementCreateManyPanelUploadInputEnvelope
    connect?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
  }

  export type BiomarkerMeasurementUncheckedCreateNestedManyWithoutPanelUploadInput = {
    create?: XOR<BiomarkerMeasurementCreateWithoutPanelUploadInput, BiomarkerMeasurementUncheckedCreateWithoutPanelUploadInput> | BiomarkerMeasurementCreateWithoutPanelUploadInput[] | BiomarkerMeasurementUncheckedCreateWithoutPanelUploadInput[]
    connectOrCreate?: BiomarkerMeasurementCreateOrConnectWithoutPanelUploadInput | BiomarkerMeasurementCreateOrConnectWithoutPanelUploadInput[]
    createMany?: BiomarkerMeasurementCreateManyPanelUploadInputEnvelope
    connect?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
  }

  export type EnumPanelUploadStatusFieldUpdateOperationsInput = {
    set?: $Enums.PanelUploadStatus
  }

  export type EnumPanelUploadSourceFieldUpdateOperationsInput = {
    set?: $Enums.PanelUploadSource
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutPanelUploadsNestedInput = {
    create?: XOR<UserCreateWithoutPanelUploadsInput, UserUncheckedCreateWithoutPanelUploadsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPanelUploadsInput
    upsert?: UserUpsertWithoutPanelUploadsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPanelUploadsInput, UserUpdateWithoutPanelUploadsInput>, UserUncheckedUpdateWithoutPanelUploadsInput>
  }

  export type BiomarkerMeasurementUpdateManyWithoutPanelUploadNestedInput = {
    create?: XOR<BiomarkerMeasurementCreateWithoutPanelUploadInput, BiomarkerMeasurementUncheckedCreateWithoutPanelUploadInput> | BiomarkerMeasurementCreateWithoutPanelUploadInput[] | BiomarkerMeasurementUncheckedCreateWithoutPanelUploadInput[]
    connectOrCreate?: BiomarkerMeasurementCreateOrConnectWithoutPanelUploadInput | BiomarkerMeasurementCreateOrConnectWithoutPanelUploadInput[]
    upsert?: BiomarkerMeasurementUpsertWithWhereUniqueWithoutPanelUploadInput | BiomarkerMeasurementUpsertWithWhereUniqueWithoutPanelUploadInput[]
    createMany?: BiomarkerMeasurementCreateManyPanelUploadInputEnvelope
    set?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    disconnect?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    delete?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    connect?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    update?: BiomarkerMeasurementUpdateWithWhereUniqueWithoutPanelUploadInput | BiomarkerMeasurementUpdateWithWhereUniqueWithoutPanelUploadInput[]
    updateMany?: BiomarkerMeasurementUpdateManyWithWhereWithoutPanelUploadInput | BiomarkerMeasurementUpdateManyWithWhereWithoutPanelUploadInput[]
    deleteMany?: BiomarkerMeasurementScalarWhereInput | BiomarkerMeasurementScalarWhereInput[]
  }

  export type BiomarkerMeasurementUncheckedUpdateManyWithoutPanelUploadNestedInput = {
    create?: XOR<BiomarkerMeasurementCreateWithoutPanelUploadInput, BiomarkerMeasurementUncheckedCreateWithoutPanelUploadInput> | BiomarkerMeasurementCreateWithoutPanelUploadInput[] | BiomarkerMeasurementUncheckedCreateWithoutPanelUploadInput[]
    connectOrCreate?: BiomarkerMeasurementCreateOrConnectWithoutPanelUploadInput | BiomarkerMeasurementCreateOrConnectWithoutPanelUploadInput[]
    upsert?: BiomarkerMeasurementUpsertWithWhereUniqueWithoutPanelUploadInput | BiomarkerMeasurementUpsertWithWhereUniqueWithoutPanelUploadInput[]
    createMany?: BiomarkerMeasurementCreateManyPanelUploadInputEnvelope
    set?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    disconnect?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    delete?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    connect?: BiomarkerMeasurementWhereUniqueInput | BiomarkerMeasurementWhereUniqueInput[]
    update?: BiomarkerMeasurementUpdateWithWhereUniqueWithoutPanelUploadInput | BiomarkerMeasurementUpdateWithWhereUniqueWithoutPanelUploadInput[]
    updateMany?: BiomarkerMeasurementUpdateManyWithWhereWithoutPanelUploadInput | BiomarkerMeasurementUpdateManyWithWhereWithoutPanelUploadInput[]
    deleteMany?: BiomarkerMeasurementScalarWhereInput | BiomarkerMeasurementScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutBiomarkerMeasurementsInput = {
    create?: XOR<UserCreateWithoutBiomarkerMeasurementsInput, UserUncheckedCreateWithoutBiomarkerMeasurementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBiomarkerMeasurementsInput
    connect?: UserWhereUniqueInput
  }

  export type BiomarkerCreateNestedOneWithoutMeasurementsInput = {
    create?: XOR<BiomarkerCreateWithoutMeasurementsInput, BiomarkerUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: BiomarkerCreateOrConnectWithoutMeasurementsInput
    connect?: BiomarkerWhereUniqueInput
  }

  export type PanelUploadCreateNestedOneWithoutMeasurementsInput = {
    create?: XOR<PanelUploadCreateWithoutMeasurementsInput, PanelUploadUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: PanelUploadCreateOrConnectWithoutMeasurementsInput
    connect?: PanelUploadWhereUniqueInput
  }

  export type EnumMeasurementStatusFieldUpdateOperationsInput = {
    set?: $Enums.MeasurementStatus
  }

  export type UserUpdateOneRequiredWithoutBiomarkerMeasurementsNestedInput = {
    create?: XOR<UserCreateWithoutBiomarkerMeasurementsInput, UserUncheckedCreateWithoutBiomarkerMeasurementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBiomarkerMeasurementsInput
    upsert?: UserUpsertWithoutBiomarkerMeasurementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBiomarkerMeasurementsInput, UserUpdateWithoutBiomarkerMeasurementsInput>, UserUncheckedUpdateWithoutBiomarkerMeasurementsInput>
  }

  export type BiomarkerUpdateOneWithoutMeasurementsNestedInput = {
    create?: XOR<BiomarkerCreateWithoutMeasurementsInput, BiomarkerUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: BiomarkerCreateOrConnectWithoutMeasurementsInput
    upsert?: BiomarkerUpsertWithoutMeasurementsInput
    disconnect?: BiomarkerWhereInput | boolean
    delete?: BiomarkerWhereInput | boolean
    connect?: BiomarkerWhereUniqueInput
    update?: XOR<XOR<BiomarkerUpdateToOneWithWhereWithoutMeasurementsInput, BiomarkerUpdateWithoutMeasurementsInput>, BiomarkerUncheckedUpdateWithoutMeasurementsInput>
  }

  export type PanelUploadUpdateOneWithoutMeasurementsNestedInput = {
    create?: XOR<PanelUploadCreateWithoutMeasurementsInput, PanelUploadUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: PanelUploadCreateOrConnectWithoutMeasurementsInput
    upsert?: PanelUploadUpsertWithoutMeasurementsInput
    disconnect?: PanelUploadWhereInput | boolean
    delete?: PanelUploadWhereInput | boolean
    connect?: PanelUploadWhereUniqueInput
    update?: XOR<XOR<PanelUploadUpdateToOneWithWhereWithoutMeasurementsInput, PanelUploadUpdateWithoutMeasurementsInput>, PanelUploadUncheckedUpdateWithoutMeasurementsInput>
  }

  export type AuthProviderCreatescopesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutAuthProvidersInput = {
    create?: XOR<UserCreateWithoutAuthProvidersInput, UserUncheckedCreateWithoutAuthProvidersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthProvidersInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuthProviderTypeFieldUpdateOperationsInput = {
    set?: $Enums.AuthProviderType
  }

  export type AuthProviderUpdatescopesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutAuthProvidersNestedInput = {
    create?: XOR<UserCreateWithoutAuthProvidersInput, UserUncheckedCreateWithoutAuthProvidersInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuthProvidersInput
    upsert?: UserUpsertWithoutAuthProvidersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuthProvidersInput, UserUpdateWithoutAuthProvidersInput>, UserUncheckedUpdateWithoutAuthProvidersInput>
  }

  export type UserCreateNestedOneWithoutLoginAuditsInput = {
    create?: XOR<UserCreateWithoutLoginAuditsInput, UserUncheckedCreateWithoutLoginAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginAuditsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutLoginAuditsNestedInput = {
    create?: XOR<UserCreateWithoutLoginAuditsInput, UserUncheckedCreateWithoutLoginAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLoginAuditsInput
    upsert?: UserUpsertWithoutLoginAuditsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLoginAuditsInput, UserUpdateWithoutLoginAuditsInput>, UserUncheckedUpdateWithoutLoginAuditsInput>
  }

  export type InsightCreateNestedOneWithoutActionsInput = {
    create?: XOR<InsightCreateWithoutActionsInput, InsightUncheckedCreateWithoutActionsInput>
    connectOrCreate?: InsightCreateOrConnectWithoutActionsInput
    connect?: InsightWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInsightActionsInput = {
    create?: XOR<UserCreateWithoutInsightActionsInput, UserUncheckedCreateWithoutInsightActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInsightActionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumInsightActionTypeFieldUpdateOperationsInput = {
    set?: $Enums.InsightActionType
  }

  export type InsightUpdateOneRequiredWithoutActionsNestedInput = {
    create?: XOR<InsightCreateWithoutActionsInput, InsightUncheckedCreateWithoutActionsInput>
    connectOrCreate?: InsightCreateOrConnectWithoutActionsInput
    upsert?: InsightUpsertWithoutActionsInput
    connect?: InsightWhereUniqueInput
    update?: XOR<XOR<InsightUpdateToOneWithWhereWithoutActionsInput, InsightUpdateWithoutActionsInput>, InsightUncheckedUpdateWithoutActionsInput>
  }

  export type UserUpdateOneWithoutInsightActionsNestedInput = {
    create?: XOR<UserCreateWithoutInsightActionsInput, UserUncheckedCreateWithoutInsightActionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInsightActionsInput
    upsert?: UserUpsertWithoutInsightActionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInsightActionsInput, UserUpdateWithoutInsightActionsInput>, UserUncheckedUpdateWithoutInsightActionsInput>
  }

  export type InsightCreateNestedOneWithoutGenerationJobsInput = {
    create?: XOR<InsightCreateWithoutGenerationJobsInput, InsightUncheckedCreateWithoutGenerationJobsInput>
    connectOrCreate?: InsightCreateOrConnectWithoutGenerationJobsInput
    connect?: InsightWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInsightGenerationJobsInput = {
    create?: XOR<UserCreateWithoutInsightGenerationJobsInput, UserUncheckedCreateWithoutInsightGenerationJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInsightGenerationJobsInput
    connect?: UserWhereUniqueInput
  }

  export type CloudTaskMetadataCreateNestedOneWithoutJobInput = {
    create?: XOR<CloudTaskMetadataCreateWithoutJobInput, CloudTaskMetadataUncheckedCreateWithoutJobInput>
    connectOrCreate?: CloudTaskMetadataCreateOrConnectWithoutJobInput
    connect?: CloudTaskMetadataWhereUniqueInput
  }

  export type CloudTaskMetadataUncheckedCreateNestedOneWithoutJobInput = {
    create?: XOR<CloudTaskMetadataCreateWithoutJobInput, CloudTaskMetadataUncheckedCreateWithoutJobInput>
    connectOrCreate?: CloudTaskMetadataCreateOrConnectWithoutJobInput
    connect?: CloudTaskMetadataWhereUniqueInput
  }

  export type EnumInsightGenerationStatusFieldUpdateOperationsInput = {
    set?: $Enums.InsightGenerationStatus
  }

  export type InsightUpdateOneWithoutGenerationJobsNestedInput = {
    create?: XOR<InsightCreateWithoutGenerationJobsInput, InsightUncheckedCreateWithoutGenerationJobsInput>
    connectOrCreate?: InsightCreateOrConnectWithoutGenerationJobsInput
    upsert?: InsightUpsertWithoutGenerationJobsInput
    disconnect?: InsightWhereInput | boolean
    delete?: InsightWhereInput | boolean
    connect?: InsightWhereUniqueInput
    update?: XOR<XOR<InsightUpdateToOneWithWhereWithoutGenerationJobsInput, InsightUpdateWithoutGenerationJobsInput>, InsightUncheckedUpdateWithoutGenerationJobsInput>
  }

  export type UserUpdateOneWithoutInsightGenerationJobsNestedInput = {
    create?: XOR<UserCreateWithoutInsightGenerationJobsInput, UserUncheckedCreateWithoutInsightGenerationJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInsightGenerationJobsInput
    upsert?: UserUpsertWithoutInsightGenerationJobsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInsightGenerationJobsInput, UserUpdateWithoutInsightGenerationJobsInput>, UserUncheckedUpdateWithoutInsightGenerationJobsInput>
  }

  export type CloudTaskMetadataUpdateOneWithoutJobNestedInput = {
    create?: XOR<CloudTaskMetadataCreateWithoutJobInput, CloudTaskMetadataUncheckedCreateWithoutJobInput>
    connectOrCreate?: CloudTaskMetadataCreateOrConnectWithoutJobInput
    upsert?: CloudTaskMetadataUpsertWithoutJobInput
    disconnect?: CloudTaskMetadataWhereInput | boolean
    delete?: CloudTaskMetadataWhereInput | boolean
    connect?: CloudTaskMetadataWhereUniqueInput
    update?: XOR<XOR<CloudTaskMetadataUpdateToOneWithWhereWithoutJobInput, CloudTaskMetadataUpdateWithoutJobInput>, CloudTaskMetadataUncheckedUpdateWithoutJobInput>
  }

  export type CloudTaskMetadataUncheckedUpdateOneWithoutJobNestedInput = {
    create?: XOR<CloudTaskMetadataCreateWithoutJobInput, CloudTaskMetadataUncheckedCreateWithoutJobInput>
    connectOrCreate?: CloudTaskMetadataCreateOrConnectWithoutJobInput
    upsert?: CloudTaskMetadataUpsertWithoutJobInput
    disconnect?: CloudTaskMetadataWhereInput | boolean
    delete?: CloudTaskMetadataWhereInput | boolean
    connect?: CloudTaskMetadataWhereUniqueInput
    update?: XOR<XOR<CloudTaskMetadataUpdateToOneWithWhereWithoutJobInput, CloudTaskMetadataUpdateWithoutJobInput>, CloudTaskMetadataUncheckedUpdateWithoutJobInput>
  }

  export type LongevityPlanCreateNestedOneWithoutJobsInput = {
    create?: XOR<LongevityPlanCreateWithoutJobsInput, LongevityPlanUncheckedCreateWithoutJobsInput>
    connectOrCreate?: LongevityPlanCreateOrConnectWithoutJobsInput
    connect?: LongevityPlanWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutLongevityPlanJobsInput = {
    create?: XOR<UserCreateWithoutLongevityPlanJobsInput, UserUncheckedCreateWithoutLongevityPlanJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLongevityPlanJobsInput
    connect?: UserWhereUniqueInput
  }

  export type CloudTaskMetadataCreateNestedOneWithoutPlanJobInput = {
    create?: XOR<CloudTaskMetadataCreateWithoutPlanJobInput, CloudTaskMetadataUncheckedCreateWithoutPlanJobInput>
    connectOrCreate?: CloudTaskMetadataCreateOrConnectWithoutPlanJobInput
    connect?: CloudTaskMetadataWhereUniqueInput
  }

  export type CloudTaskMetadataUncheckedCreateNestedOneWithoutPlanJobInput = {
    create?: XOR<CloudTaskMetadataCreateWithoutPlanJobInput, CloudTaskMetadataUncheckedCreateWithoutPlanJobInput>
    connectOrCreate?: CloudTaskMetadataCreateOrConnectWithoutPlanJobInput
    connect?: CloudTaskMetadataWhereUniqueInput
  }

  export type EnumLongevityPlanJobStatusFieldUpdateOperationsInput = {
    set?: $Enums.LongevityPlanJobStatus
  }

  export type LongevityPlanUpdateOneWithoutJobsNestedInput = {
    create?: XOR<LongevityPlanCreateWithoutJobsInput, LongevityPlanUncheckedCreateWithoutJobsInput>
    connectOrCreate?: LongevityPlanCreateOrConnectWithoutJobsInput
    upsert?: LongevityPlanUpsertWithoutJobsInput
    disconnect?: LongevityPlanWhereInput | boolean
    delete?: LongevityPlanWhereInput | boolean
    connect?: LongevityPlanWhereUniqueInput
    update?: XOR<XOR<LongevityPlanUpdateToOneWithWhereWithoutJobsInput, LongevityPlanUpdateWithoutJobsInput>, LongevityPlanUncheckedUpdateWithoutJobsInput>
  }

  export type UserUpdateOneWithoutLongevityPlanJobsNestedInput = {
    create?: XOR<UserCreateWithoutLongevityPlanJobsInput, UserUncheckedCreateWithoutLongevityPlanJobsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLongevityPlanJobsInput
    upsert?: UserUpsertWithoutLongevityPlanJobsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLongevityPlanJobsInput, UserUpdateWithoutLongevityPlanJobsInput>, UserUncheckedUpdateWithoutLongevityPlanJobsInput>
  }

  export type CloudTaskMetadataUpdateOneWithoutPlanJobNestedInput = {
    create?: XOR<CloudTaskMetadataCreateWithoutPlanJobInput, CloudTaskMetadataUncheckedCreateWithoutPlanJobInput>
    connectOrCreate?: CloudTaskMetadataCreateOrConnectWithoutPlanJobInput
    upsert?: CloudTaskMetadataUpsertWithoutPlanJobInput
    disconnect?: CloudTaskMetadataWhereInput | boolean
    delete?: CloudTaskMetadataWhereInput | boolean
    connect?: CloudTaskMetadataWhereUniqueInput
    update?: XOR<XOR<CloudTaskMetadataUpdateToOneWithWhereWithoutPlanJobInput, CloudTaskMetadataUpdateWithoutPlanJobInput>, CloudTaskMetadataUncheckedUpdateWithoutPlanJobInput>
  }

  export type CloudTaskMetadataUncheckedUpdateOneWithoutPlanJobNestedInput = {
    create?: XOR<CloudTaskMetadataCreateWithoutPlanJobInput, CloudTaskMetadataUncheckedCreateWithoutPlanJobInput>
    connectOrCreate?: CloudTaskMetadataCreateOrConnectWithoutPlanJobInput
    upsert?: CloudTaskMetadataUpsertWithoutPlanJobInput
    disconnect?: CloudTaskMetadataWhereInput | boolean
    delete?: CloudTaskMetadataWhereInput | boolean
    connect?: CloudTaskMetadataWhereUniqueInput
    update?: XOR<XOR<CloudTaskMetadataUpdateToOneWithWhereWithoutPlanJobInput, CloudTaskMetadataUpdateWithoutPlanJobInput>, CloudTaskMetadataUncheckedUpdateWithoutPlanJobInput>
  }

  export type InsightGenerationJobCreateNestedOneWithoutCloudTaskInput = {
    create?: XOR<InsightGenerationJobCreateWithoutCloudTaskInput, InsightGenerationJobUncheckedCreateWithoutCloudTaskInput>
    connectOrCreate?: InsightGenerationJobCreateOrConnectWithoutCloudTaskInput
    connect?: InsightGenerationJobWhereUniqueInput
  }

  export type LongevityPlanJobCreateNestedOneWithoutCloudTaskInput = {
    create?: XOR<LongevityPlanJobCreateWithoutCloudTaskInput, LongevityPlanJobUncheckedCreateWithoutCloudTaskInput>
    connectOrCreate?: LongevityPlanJobCreateOrConnectWithoutCloudTaskInput
    connect?: LongevityPlanJobWhereUniqueInput
  }

  export type EnumCloudTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.CloudTaskStatus
  }

  export type InsightGenerationJobUpdateOneWithoutCloudTaskNestedInput = {
    create?: XOR<InsightGenerationJobCreateWithoutCloudTaskInput, InsightGenerationJobUncheckedCreateWithoutCloudTaskInput>
    connectOrCreate?: InsightGenerationJobCreateOrConnectWithoutCloudTaskInput
    upsert?: InsightGenerationJobUpsertWithoutCloudTaskInput
    disconnect?: InsightGenerationJobWhereInput | boolean
    delete?: InsightGenerationJobWhereInput | boolean
    connect?: InsightGenerationJobWhereUniqueInput
    update?: XOR<XOR<InsightGenerationJobUpdateToOneWithWhereWithoutCloudTaskInput, InsightGenerationJobUpdateWithoutCloudTaskInput>, InsightGenerationJobUncheckedUpdateWithoutCloudTaskInput>
  }

  export type LongevityPlanJobUpdateOneWithoutCloudTaskNestedInput = {
    create?: XOR<LongevityPlanJobCreateWithoutCloudTaskInput, LongevityPlanJobUncheckedCreateWithoutCloudTaskInput>
    connectOrCreate?: LongevityPlanJobCreateOrConnectWithoutCloudTaskInput
    upsert?: LongevityPlanJobUpsertWithoutCloudTaskInput
    disconnect?: LongevityPlanJobWhereInput | boolean
    delete?: LongevityPlanJobWhereInput | boolean
    connect?: LongevityPlanJobWhereUniqueInput
    update?: XOR<XOR<LongevityPlanJobUpdateToOneWithWhereWithoutCloudTaskInput, LongevityPlanJobUpdateWithoutCloudTaskInput>, LongevityPlanJobUncheckedUpdateWithoutCloudTaskInput>
  }

  export type WhoopIntegrationCreatescopeInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutWhoopIntegrationInput = {
    create?: XOR<UserCreateWithoutWhoopIntegrationInput, UserUncheckedCreateWithoutWhoopIntegrationInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhoopIntegrationInput
    connect?: UserWhereUniqueInput
  }

  export type WhoopIntegrationUpdatescopeInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumWhoopSyncStatusFieldUpdateOperationsInput = {
    set?: $Enums.WhoopSyncStatus
  }

  export type UserUpdateOneRequiredWithoutWhoopIntegrationNestedInput = {
    create?: XOR<UserCreateWithoutWhoopIntegrationInput, UserUncheckedCreateWithoutWhoopIntegrationInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhoopIntegrationInput
    upsert?: UserUpsertWithoutWhoopIntegrationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWhoopIntegrationInput, UserUpdateWithoutWhoopIntegrationInput>, UserUncheckedUpdateWithoutWhoopIntegrationInput>
  }

  export type WhoopLinkSessionCreatescopeInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutWhoopLinkSessionsInput = {
    create?: XOR<UserCreateWithoutWhoopLinkSessionsInput, UserUncheckedCreateWithoutWhoopLinkSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhoopLinkSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type WhoopLinkSessionUpdatescopeInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutWhoopLinkSessionsNestedInput = {
    create?: XOR<UserCreateWithoutWhoopLinkSessionsInput, UserUncheckedCreateWithoutWhoopLinkSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutWhoopLinkSessionsInput
    upsert?: UserUpsertWithoutWhoopLinkSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWhoopLinkSessionsInput, UserUpdateWithoutWhoopLinkSessionsInput>, UserUncheckedUpdateWithoutWhoopLinkSessionsInput>
  }

  export type FeedPostCreatetagsInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutFeedPostsInput = {
    create?: XOR<UserCreateWithoutFeedPostsInput, UserUncheckedCreateWithoutFeedPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedPostsInput
    connect?: UserWhereUniqueInput
  }

  export type CommentCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReactionCreateNestedManyWithoutPostInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput> | ReactionCreateWithoutPostInput[] | ReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput | ReactionCreateOrConnectWithoutPostInput[]
    createMany?: ReactionCreateManyPostInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type FlagCreateNestedManyWithoutPostInput = {
    create?: XOR<FlagCreateWithoutPostInput, FlagUncheckedCreateWithoutPostInput> | FlagCreateWithoutPostInput[] | FlagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutPostInput | FlagCreateOrConnectWithoutPostInput[]
    createMany?: FlagCreateManyPostInputEnvelope
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
  }

  export type EngagementEventCreateNestedManyWithoutPostInput = {
    create?: XOR<EngagementEventCreateWithoutPostInput, EngagementEventUncheckedCreateWithoutPostInput> | EngagementEventCreateWithoutPostInput[] | EngagementEventUncheckedCreateWithoutPostInput[]
    connectOrCreate?: EngagementEventCreateOrConnectWithoutPostInput | EngagementEventCreateOrConnectWithoutPostInput[]
    createMany?: EngagementEventCreateManyPostInputEnvelope
    connect?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
  }

  export type CommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
  }

  export type ReactionUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput> | ReactionCreateWithoutPostInput[] | ReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput | ReactionCreateOrConnectWithoutPostInput[]
    createMany?: ReactionCreateManyPostInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type FlagUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<FlagCreateWithoutPostInput, FlagUncheckedCreateWithoutPostInput> | FlagCreateWithoutPostInput[] | FlagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutPostInput | FlagCreateOrConnectWithoutPostInput[]
    createMany?: FlagCreateManyPostInputEnvelope
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
  }

  export type EngagementEventUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<EngagementEventCreateWithoutPostInput, EngagementEventUncheckedCreateWithoutPostInput> | EngagementEventCreateWithoutPostInput[] | EngagementEventUncheckedCreateWithoutPostInput[]
    connectOrCreate?: EngagementEventCreateOrConnectWithoutPostInput | EngagementEventCreateOrConnectWithoutPostInput[]
    createMany?: EngagementEventCreateManyPostInputEnvelope
    connect?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
  }

  export type FeedPostUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumPostVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.PostVisibility
  }

  export type UserUpdateOneRequiredWithoutFeedPostsNestedInput = {
    create?: XOR<UserCreateWithoutFeedPostsInput, UserUncheckedCreateWithoutFeedPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutFeedPostsInput
    upsert?: UserUpsertWithoutFeedPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFeedPostsInput, UserUpdateWithoutFeedPostsInput>, UserUncheckedUpdateWithoutFeedPostsInput>
  }

  export type CommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReactionUpdateManyWithoutPostNestedInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput> | ReactionCreateWithoutPostInput[] | ReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput | ReactionCreateOrConnectWithoutPostInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutPostInput | ReactionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ReactionCreateManyPostInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutPostInput | ReactionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutPostInput | ReactionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type FlagUpdateManyWithoutPostNestedInput = {
    create?: XOR<FlagCreateWithoutPostInput, FlagUncheckedCreateWithoutPostInput> | FlagCreateWithoutPostInput[] | FlagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutPostInput | FlagCreateOrConnectWithoutPostInput[]
    upsert?: FlagUpsertWithWhereUniqueWithoutPostInput | FlagUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: FlagCreateManyPostInputEnvelope
    set?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    disconnect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    delete?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    update?: FlagUpdateWithWhereUniqueWithoutPostInput | FlagUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: FlagUpdateManyWithWhereWithoutPostInput | FlagUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: FlagScalarWhereInput | FlagScalarWhereInput[]
  }

  export type EngagementEventUpdateManyWithoutPostNestedInput = {
    create?: XOR<EngagementEventCreateWithoutPostInput, EngagementEventUncheckedCreateWithoutPostInput> | EngagementEventCreateWithoutPostInput[] | EngagementEventUncheckedCreateWithoutPostInput[]
    connectOrCreate?: EngagementEventCreateOrConnectWithoutPostInput | EngagementEventCreateOrConnectWithoutPostInput[]
    upsert?: EngagementEventUpsertWithWhereUniqueWithoutPostInput | EngagementEventUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: EngagementEventCreateManyPostInputEnvelope
    set?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    disconnect?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    delete?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    connect?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    update?: EngagementEventUpdateWithWhereUniqueWithoutPostInput | EngagementEventUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: EngagementEventUpdateManyWithWhereWithoutPostInput | EngagementEventUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: EngagementEventScalarWhereInput | EngagementEventScalarWhereInput[]
  }

  export type CommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput> | CommentCreateWithoutPostInput[] | CommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: CommentCreateOrConnectWithoutPostInput | CommentCreateOrConnectWithoutPostInput[]
    upsert?: CommentUpsertWithWhereUniqueWithoutPostInput | CommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: CommentCreateManyPostInputEnvelope
    set?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    disconnect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    delete?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    connect?: CommentWhereUniqueInput | CommentWhereUniqueInput[]
    update?: CommentUpdateWithWhereUniqueWithoutPostInput | CommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: CommentUpdateManyWithWhereWithoutPostInput | CommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: CommentScalarWhereInput | CommentScalarWhereInput[]
  }

  export type ReactionUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput> | ReactionCreateWithoutPostInput[] | ReactionUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutPostInput | ReactionCreateOrConnectWithoutPostInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutPostInput | ReactionUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ReactionCreateManyPostInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutPostInput | ReactionUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutPostInput | ReactionUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type FlagUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<FlagCreateWithoutPostInput, FlagUncheckedCreateWithoutPostInput> | FlagCreateWithoutPostInput[] | FlagUncheckedCreateWithoutPostInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutPostInput | FlagCreateOrConnectWithoutPostInput[]
    upsert?: FlagUpsertWithWhereUniqueWithoutPostInput | FlagUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: FlagCreateManyPostInputEnvelope
    set?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    disconnect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    delete?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    update?: FlagUpdateWithWhereUniqueWithoutPostInput | FlagUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: FlagUpdateManyWithWhereWithoutPostInput | FlagUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: FlagScalarWhereInput | FlagScalarWhereInput[]
  }

  export type EngagementEventUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<EngagementEventCreateWithoutPostInput, EngagementEventUncheckedCreateWithoutPostInput> | EngagementEventCreateWithoutPostInput[] | EngagementEventUncheckedCreateWithoutPostInput[]
    connectOrCreate?: EngagementEventCreateOrConnectWithoutPostInput | EngagementEventCreateOrConnectWithoutPostInput[]
    upsert?: EngagementEventUpsertWithWhereUniqueWithoutPostInput | EngagementEventUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: EngagementEventCreateManyPostInputEnvelope
    set?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    disconnect?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    delete?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    connect?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    update?: EngagementEventUpdateWithWhereUniqueWithoutPostInput | EngagementEventUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: EngagementEventUpdateManyWithWhereWithoutPostInput | EngagementEventUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: EngagementEventScalarWhereInput | EngagementEventScalarWhereInput[]
  }

  export type FeedPostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<FeedPostCreateWithoutCommentsInput, FeedPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: FeedPostCreateOrConnectWithoutCommentsInput
    connect?: FeedPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentsInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type ReactionCreateNestedManyWithoutCommentInput = {
    create?: XOR<ReactionCreateWithoutCommentInput, ReactionUncheckedCreateWithoutCommentInput> | ReactionCreateWithoutCommentInput[] | ReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutCommentInput | ReactionCreateOrConnectWithoutCommentInput[]
    createMany?: ReactionCreateManyCommentInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type FlagCreateNestedManyWithoutCommentInput = {
    create?: XOR<FlagCreateWithoutCommentInput, FlagUncheckedCreateWithoutCommentInput> | FlagCreateWithoutCommentInput[] | FlagUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutCommentInput | FlagCreateOrConnectWithoutCommentInput[]
    createMany?: FlagCreateManyCommentInputEnvelope
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
  }

  export type EngagementEventCreateNestedManyWithoutCommentInput = {
    create?: XOR<EngagementEventCreateWithoutCommentInput, EngagementEventUncheckedCreateWithoutCommentInput> | EngagementEventCreateWithoutCommentInput[] | EngagementEventUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: EngagementEventCreateOrConnectWithoutCommentInput | EngagementEventCreateOrConnectWithoutCommentInput[]
    createMany?: EngagementEventCreateManyCommentInputEnvelope
    connect?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
  }

  export type ReactionUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<ReactionCreateWithoutCommentInput, ReactionUncheckedCreateWithoutCommentInput> | ReactionCreateWithoutCommentInput[] | ReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutCommentInput | ReactionCreateOrConnectWithoutCommentInput[]
    createMany?: ReactionCreateManyCommentInputEnvelope
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
  }

  export type FlagUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<FlagCreateWithoutCommentInput, FlagUncheckedCreateWithoutCommentInput> | FlagCreateWithoutCommentInput[] | FlagUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutCommentInput | FlagCreateOrConnectWithoutCommentInput[]
    createMany?: FlagCreateManyCommentInputEnvelope
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
  }

  export type EngagementEventUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<EngagementEventCreateWithoutCommentInput, EngagementEventUncheckedCreateWithoutCommentInput> | EngagementEventCreateWithoutCommentInput[] | EngagementEventUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: EngagementEventCreateOrConnectWithoutCommentInput | EngagementEventCreateOrConnectWithoutCommentInput[]
    createMany?: EngagementEventCreateManyCommentInputEnvelope
    connect?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
  }

  export type FeedPostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<FeedPostCreateWithoutCommentsInput, FeedPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: FeedPostCreateOrConnectWithoutCommentsInput
    upsert?: FeedPostUpsertWithoutCommentsInput
    connect?: FeedPostWhereUniqueInput
    update?: XOR<XOR<FeedPostUpdateToOneWithWhereWithoutCommentsInput, FeedPostUpdateWithoutCommentsInput>, FeedPostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentsInput
    upsert?: UserUpsertWithoutCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentsInput, UserUpdateWithoutCommentsInput>, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type ReactionUpdateManyWithoutCommentNestedInput = {
    create?: XOR<ReactionCreateWithoutCommentInput, ReactionUncheckedCreateWithoutCommentInput> | ReactionCreateWithoutCommentInput[] | ReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutCommentInput | ReactionCreateOrConnectWithoutCommentInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutCommentInput | ReactionUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: ReactionCreateManyCommentInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutCommentInput | ReactionUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutCommentInput | ReactionUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type FlagUpdateManyWithoutCommentNestedInput = {
    create?: XOR<FlagCreateWithoutCommentInput, FlagUncheckedCreateWithoutCommentInput> | FlagCreateWithoutCommentInput[] | FlagUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutCommentInput | FlagCreateOrConnectWithoutCommentInput[]
    upsert?: FlagUpsertWithWhereUniqueWithoutCommentInput | FlagUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: FlagCreateManyCommentInputEnvelope
    set?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    disconnect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    delete?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    update?: FlagUpdateWithWhereUniqueWithoutCommentInput | FlagUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: FlagUpdateManyWithWhereWithoutCommentInput | FlagUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: FlagScalarWhereInput | FlagScalarWhereInput[]
  }

  export type EngagementEventUpdateManyWithoutCommentNestedInput = {
    create?: XOR<EngagementEventCreateWithoutCommentInput, EngagementEventUncheckedCreateWithoutCommentInput> | EngagementEventCreateWithoutCommentInput[] | EngagementEventUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: EngagementEventCreateOrConnectWithoutCommentInput | EngagementEventCreateOrConnectWithoutCommentInput[]
    upsert?: EngagementEventUpsertWithWhereUniqueWithoutCommentInput | EngagementEventUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: EngagementEventCreateManyCommentInputEnvelope
    set?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    disconnect?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    delete?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    connect?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    update?: EngagementEventUpdateWithWhereUniqueWithoutCommentInput | EngagementEventUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: EngagementEventUpdateManyWithWhereWithoutCommentInput | EngagementEventUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: EngagementEventScalarWhereInput | EngagementEventScalarWhereInput[]
  }

  export type ReactionUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<ReactionCreateWithoutCommentInput, ReactionUncheckedCreateWithoutCommentInput> | ReactionCreateWithoutCommentInput[] | ReactionUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: ReactionCreateOrConnectWithoutCommentInput | ReactionCreateOrConnectWithoutCommentInput[]
    upsert?: ReactionUpsertWithWhereUniqueWithoutCommentInput | ReactionUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: ReactionCreateManyCommentInputEnvelope
    set?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    disconnect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    delete?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    connect?: ReactionWhereUniqueInput | ReactionWhereUniqueInput[]
    update?: ReactionUpdateWithWhereUniqueWithoutCommentInput | ReactionUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: ReactionUpdateManyWithWhereWithoutCommentInput | ReactionUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
  }

  export type FlagUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<FlagCreateWithoutCommentInput, FlagUncheckedCreateWithoutCommentInput> | FlagCreateWithoutCommentInput[] | FlagUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: FlagCreateOrConnectWithoutCommentInput | FlagCreateOrConnectWithoutCommentInput[]
    upsert?: FlagUpsertWithWhereUniqueWithoutCommentInput | FlagUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: FlagCreateManyCommentInputEnvelope
    set?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    disconnect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    delete?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    connect?: FlagWhereUniqueInput | FlagWhereUniqueInput[]
    update?: FlagUpdateWithWhereUniqueWithoutCommentInput | FlagUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: FlagUpdateManyWithWhereWithoutCommentInput | FlagUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: FlagScalarWhereInput | FlagScalarWhereInput[]
  }

  export type EngagementEventUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<EngagementEventCreateWithoutCommentInput, EngagementEventUncheckedCreateWithoutCommentInput> | EngagementEventCreateWithoutCommentInput[] | EngagementEventUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: EngagementEventCreateOrConnectWithoutCommentInput | EngagementEventCreateOrConnectWithoutCommentInput[]
    upsert?: EngagementEventUpsertWithWhereUniqueWithoutCommentInput | EngagementEventUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: EngagementEventCreateManyCommentInputEnvelope
    set?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    disconnect?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    delete?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    connect?: EngagementEventWhereUniqueInput | EngagementEventWhereUniqueInput[]
    update?: EngagementEventUpdateWithWhereUniqueWithoutCommentInput | EngagementEventUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: EngagementEventUpdateManyWithWhereWithoutCommentInput | EngagementEventUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: EngagementEventScalarWhereInput | EngagementEventScalarWhereInput[]
  }

  export type FeedPostCreateNestedOneWithoutReactionsInput = {
    create?: XOR<FeedPostCreateWithoutReactionsInput, FeedPostUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: FeedPostCreateOrConnectWithoutReactionsInput
    connect?: FeedPostWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutReactionsInput = {
    create?: XOR<CommentCreateWithoutReactionsInput, CommentUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutReactionsInput
    connect?: CommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReactionsInput = {
    create?: XOR<UserCreateWithoutReactionsInput, UserUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReactionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReactionType
  }

  export type FeedPostUpdateOneWithoutReactionsNestedInput = {
    create?: XOR<FeedPostCreateWithoutReactionsInput, FeedPostUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: FeedPostCreateOrConnectWithoutReactionsInput
    upsert?: FeedPostUpsertWithoutReactionsInput
    disconnect?: FeedPostWhereInput | boolean
    delete?: FeedPostWhereInput | boolean
    connect?: FeedPostWhereUniqueInput
    update?: XOR<XOR<FeedPostUpdateToOneWithWhereWithoutReactionsInput, FeedPostUpdateWithoutReactionsInput>, FeedPostUncheckedUpdateWithoutReactionsInput>
  }

  export type CommentUpdateOneWithoutReactionsNestedInput = {
    create?: XOR<CommentCreateWithoutReactionsInput, CommentUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutReactionsInput
    upsert?: CommentUpsertWithoutReactionsInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutReactionsInput, CommentUpdateWithoutReactionsInput>, CommentUncheckedUpdateWithoutReactionsInput>
  }

  export type UserUpdateOneRequiredWithoutReactionsNestedInput = {
    create?: XOR<UserCreateWithoutReactionsInput, UserUncheckedCreateWithoutReactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReactionsInput
    upsert?: UserUpsertWithoutReactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReactionsInput, UserUpdateWithoutReactionsInput>, UserUncheckedUpdateWithoutReactionsInput>
  }

  export type UserCreateNestedOneWithoutEngagementEventsInput = {
    create?: XOR<UserCreateWithoutEngagementEventsInput, UserUncheckedCreateWithoutEngagementEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEngagementEventsInput
    connect?: UserWhereUniqueInput
  }

  export type FeedPostCreateNestedOneWithoutEngagementEventsInput = {
    create?: XOR<FeedPostCreateWithoutEngagementEventsInput, FeedPostUncheckedCreateWithoutEngagementEventsInput>
    connectOrCreate?: FeedPostCreateOrConnectWithoutEngagementEventsInput
    connect?: FeedPostWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutEngagementEventsInput = {
    create?: XOR<CommentCreateWithoutEngagementEventsInput, CommentUncheckedCreateWithoutEngagementEventsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutEngagementEventsInput
    connect?: CommentWhereUniqueInput
  }

  export type EnumEngagementEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.EngagementEventType
  }

  export type NullableEnumReactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReactionType | null
  }

  export type UserUpdateOneRequiredWithoutEngagementEventsNestedInput = {
    create?: XOR<UserCreateWithoutEngagementEventsInput, UserUncheckedCreateWithoutEngagementEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEngagementEventsInput
    upsert?: UserUpsertWithoutEngagementEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEngagementEventsInput, UserUpdateWithoutEngagementEventsInput>, UserUncheckedUpdateWithoutEngagementEventsInput>
  }

  export type FeedPostUpdateOneWithoutEngagementEventsNestedInput = {
    create?: XOR<FeedPostCreateWithoutEngagementEventsInput, FeedPostUncheckedCreateWithoutEngagementEventsInput>
    connectOrCreate?: FeedPostCreateOrConnectWithoutEngagementEventsInput
    upsert?: FeedPostUpsertWithoutEngagementEventsInput
    disconnect?: FeedPostWhereInput | boolean
    delete?: FeedPostWhereInput | boolean
    connect?: FeedPostWhereUniqueInput
    update?: XOR<XOR<FeedPostUpdateToOneWithWhereWithoutEngagementEventsInput, FeedPostUpdateWithoutEngagementEventsInput>, FeedPostUncheckedUpdateWithoutEngagementEventsInput>
  }

  export type CommentUpdateOneWithoutEngagementEventsNestedInput = {
    create?: XOR<CommentCreateWithoutEngagementEventsInput, CommentUncheckedCreateWithoutEngagementEventsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutEngagementEventsInput
    upsert?: CommentUpsertWithoutEngagementEventsInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutEngagementEventsInput, CommentUpdateWithoutEngagementEventsInput>, CommentUncheckedUpdateWithoutEngagementEventsInput>
  }

  export type FeedPostCreateNestedOneWithoutFlagsInput = {
    create?: XOR<FeedPostCreateWithoutFlagsInput, FeedPostUncheckedCreateWithoutFlagsInput>
    connectOrCreate?: FeedPostCreateOrConnectWithoutFlagsInput
    connect?: FeedPostWhereUniqueInput
  }

  export type CommentCreateNestedOneWithoutFlagsInput = {
    create?: XOR<CommentCreateWithoutFlagsInput, CommentUncheckedCreateWithoutFlagsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutFlagsInput
    connect?: CommentWhereUniqueInput
  }

  export type InsightCreateNestedOneWithoutFlagsInput = {
    create?: XOR<InsightCreateWithoutFlagsInput, InsightUncheckedCreateWithoutFlagsInput>
    connectOrCreate?: InsightCreateOrConnectWithoutFlagsInput
    connect?: InsightWhereUniqueInput
  }

  export type BiomarkerLogCreateNestedOneWithoutFlagsInput = {
    create?: XOR<BiomarkerLogCreateWithoutFlagsInput, BiomarkerLogUncheckedCreateWithoutFlagsInput>
    connectOrCreate?: BiomarkerLogCreateOrConnectWithoutFlagsInput
    connect?: BiomarkerLogWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFlagsOpenedInput = {
    create?: XOR<UserCreateWithoutFlagsOpenedInput, UserUncheckedCreateWithoutFlagsOpenedInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlagsOpenedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutFlagsResolvedInput = {
    create?: XOR<UserCreateWithoutFlagsResolvedInput, UserUncheckedCreateWithoutFlagsResolvedInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlagsResolvedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFlagTargetTypeFieldUpdateOperationsInput = {
    set?: $Enums.FlagTargetType
  }

  export type EnumFlagStatusFieldUpdateOperationsInput = {
    set?: $Enums.FlagStatus
  }

  export type FeedPostUpdateOneWithoutFlagsNestedInput = {
    create?: XOR<FeedPostCreateWithoutFlagsInput, FeedPostUncheckedCreateWithoutFlagsInput>
    connectOrCreate?: FeedPostCreateOrConnectWithoutFlagsInput
    upsert?: FeedPostUpsertWithoutFlagsInput
    disconnect?: FeedPostWhereInput | boolean
    delete?: FeedPostWhereInput | boolean
    connect?: FeedPostWhereUniqueInput
    update?: XOR<XOR<FeedPostUpdateToOneWithWhereWithoutFlagsInput, FeedPostUpdateWithoutFlagsInput>, FeedPostUncheckedUpdateWithoutFlagsInput>
  }

  export type CommentUpdateOneWithoutFlagsNestedInput = {
    create?: XOR<CommentCreateWithoutFlagsInput, CommentUncheckedCreateWithoutFlagsInput>
    connectOrCreate?: CommentCreateOrConnectWithoutFlagsInput
    upsert?: CommentUpsertWithoutFlagsInput
    disconnect?: CommentWhereInput | boolean
    delete?: CommentWhereInput | boolean
    connect?: CommentWhereUniqueInput
    update?: XOR<XOR<CommentUpdateToOneWithWhereWithoutFlagsInput, CommentUpdateWithoutFlagsInput>, CommentUncheckedUpdateWithoutFlagsInput>
  }

  export type InsightUpdateOneWithoutFlagsNestedInput = {
    create?: XOR<InsightCreateWithoutFlagsInput, InsightUncheckedCreateWithoutFlagsInput>
    connectOrCreate?: InsightCreateOrConnectWithoutFlagsInput
    upsert?: InsightUpsertWithoutFlagsInput
    disconnect?: InsightWhereInput | boolean
    delete?: InsightWhereInput | boolean
    connect?: InsightWhereUniqueInput
    update?: XOR<XOR<InsightUpdateToOneWithWhereWithoutFlagsInput, InsightUpdateWithoutFlagsInput>, InsightUncheckedUpdateWithoutFlagsInput>
  }

  export type BiomarkerLogUpdateOneWithoutFlagsNestedInput = {
    create?: XOR<BiomarkerLogCreateWithoutFlagsInput, BiomarkerLogUncheckedCreateWithoutFlagsInput>
    connectOrCreate?: BiomarkerLogCreateOrConnectWithoutFlagsInput
    upsert?: BiomarkerLogUpsertWithoutFlagsInput
    disconnect?: BiomarkerLogWhereInput | boolean
    delete?: BiomarkerLogWhereInput | boolean
    connect?: BiomarkerLogWhereUniqueInput
    update?: XOR<XOR<BiomarkerLogUpdateToOneWithWhereWithoutFlagsInput, BiomarkerLogUpdateWithoutFlagsInput>, BiomarkerLogUncheckedUpdateWithoutFlagsInput>
  }

  export type UserUpdateOneRequiredWithoutFlagsOpenedNestedInput = {
    create?: XOR<UserCreateWithoutFlagsOpenedInput, UserUncheckedCreateWithoutFlagsOpenedInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlagsOpenedInput
    upsert?: UserUpsertWithoutFlagsOpenedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFlagsOpenedInput, UserUpdateWithoutFlagsOpenedInput>, UserUncheckedUpdateWithoutFlagsOpenedInput>
  }

  export type UserUpdateOneWithoutFlagsResolvedNestedInput = {
    create?: XOR<UserCreateWithoutFlagsResolvedInput, UserUncheckedCreateWithoutFlagsResolvedInput>
    connectOrCreate?: UserCreateOrConnectWithoutFlagsResolvedInput
    upsert?: UserUpsertWithoutFlagsResolvedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFlagsResolvedInput, UserUpdateWithoutFlagsResolvedInput>, UserUncheckedUpdateWithoutFlagsResolvedInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type LongevityPlanCreateNestedOneWithoutAuditsInput = {
    create?: XOR<LongevityPlanCreateWithoutAuditsInput, LongevityPlanUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: LongevityPlanCreateOrConnectWithoutAuditsInput
    connect?: LongevityPlanWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAiResponseAuditsInput = {
    create?: XOR<UserCreateWithoutAiResponseAuditsInput, UserUncheckedCreateWithoutAiResponseAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiResponseAuditsInput
    connect?: UserWhereUniqueInput
  }

  export type LongevityPlanUpdateOneWithoutAuditsNestedInput = {
    create?: XOR<LongevityPlanCreateWithoutAuditsInput, LongevityPlanUncheckedCreateWithoutAuditsInput>
    connectOrCreate?: LongevityPlanCreateOrConnectWithoutAuditsInput
    upsert?: LongevityPlanUpsertWithoutAuditsInput
    disconnect?: LongevityPlanWhereInput | boolean
    delete?: LongevityPlanWhereInput | boolean
    connect?: LongevityPlanWhereUniqueInput
    update?: XOR<XOR<LongevityPlanUpdateToOneWithWhereWithoutAuditsInput, LongevityPlanUpdateWithoutAuditsInput>, LongevityPlanUncheckedUpdateWithoutAuditsInput>
  }

  export type UserUpdateOneWithoutAiResponseAuditsNestedInput = {
    create?: XOR<UserCreateWithoutAiResponseAuditsInput, UserUncheckedCreateWithoutAiResponseAuditsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAiResponseAuditsInput
    upsert?: UserUpsertWithoutAiResponseAuditsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAiResponseAuditsInput, UserUpdateWithoutAiResponseAuditsInput>, UserUncheckedUpdateWithoutAiResponseAuditsInput>
  }

  export type UserCreateNestedOneWithoutRoomsHostedInput = {
    create?: XOR<UserCreateWithoutRoomsHostedInput, UserUncheckedCreateWithoutRoomsHostedInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoomsHostedInput
    connect?: UserWhereUniqueInput
  }

  export type RoomMembershipCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomMembershipCreateWithoutRoomInput, RoomMembershipUncheckedCreateWithoutRoomInput> | RoomMembershipCreateWithoutRoomInput[] | RoomMembershipUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutRoomInput | RoomMembershipCreateOrConnectWithoutRoomInput[]
    createMany?: RoomMembershipCreateManyRoomInputEnvelope
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
  }

  export type RoomMembershipUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomMembershipCreateWithoutRoomInput, RoomMembershipUncheckedCreateWithoutRoomInput> | RoomMembershipCreateWithoutRoomInput[] | RoomMembershipUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutRoomInput | RoomMembershipCreateOrConnectWithoutRoomInput[]
    createMany?: RoomMembershipCreateManyRoomInputEnvelope
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
  }

  export type EnumRoomStatusFieldUpdateOperationsInput = {
    set?: $Enums.RoomStatus
  }

  export type UserUpdateOneRequiredWithoutRoomsHostedNestedInput = {
    create?: XOR<UserCreateWithoutRoomsHostedInput, UserUncheckedCreateWithoutRoomsHostedInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoomsHostedInput
    upsert?: UserUpsertWithoutRoomsHostedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRoomsHostedInput, UserUpdateWithoutRoomsHostedInput>, UserUncheckedUpdateWithoutRoomsHostedInput>
  }

  export type RoomMembershipUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomMembershipCreateWithoutRoomInput, RoomMembershipUncheckedCreateWithoutRoomInput> | RoomMembershipCreateWithoutRoomInput[] | RoomMembershipUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutRoomInput | RoomMembershipCreateOrConnectWithoutRoomInput[]
    upsert?: RoomMembershipUpsertWithWhereUniqueWithoutRoomInput | RoomMembershipUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomMembershipCreateManyRoomInputEnvelope
    set?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    disconnect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    delete?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    update?: RoomMembershipUpdateWithWhereUniqueWithoutRoomInput | RoomMembershipUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomMembershipUpdateManyWithWhereWithoutRoomInput | RoomMembershipUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomMembershipScalarWhereInput | RoomMembershipScalarWhereInput[]
  }

  export type RoomMembershipUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomMembershipCreateWithoutRoomInput, RoomMembershipUncheckedCreateWithoutRoomInput> | RoomMembershipCreateWithoutRoomInput[] | RoomMembershipUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomMembershipCreateOrConnectWithoutRoomInput | RoomMembershipCreateOrConnectWithoutRoomInput[]
    upsert?: RoomMembershipUpsertWithWhereUniqueWithoutRoomInput | RoomMembershipUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomMembershipCreateManyRoomInputEnvelope
    set?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    disconnect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    delete?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    connect?: RoomMembershipWhereUniqueInput | RoomMembershipWhereUniqueInput[]
    update?: RoomMembershipUpdateWithWhereUniqueWithoutRoomInput | RoomMembershipUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomMembershipUpdateManyWithWhereWithoutRoomInput | RoomMembershipUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomMembershipScalarWhereInput | RoomMembershipScalarWhereInput[]
  }

  export type RoomCreateNestedOneWithoutMembershipsInput = {
    create?: XOR<RoomCreateWithoutMembershipsInput, RoomUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutMembershipsInput
    connect?: RoomWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRoomMembershipsInput = {
    create?: XOR<UserCreateWithoutRoomMembershipsInput, UserUncheckedCreateWithoutRoomMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoomMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumRoomMembershipRoleFieldUpdateOperationsInput = {
    set?: $Enums.RoomMembershipRole
  }

  export type EnumRoomMembershipStatusFieldUpdateOperationsInput = {
    set?: $Enums.RoomMembershipStatus
  }

  export type RoomUpdateOneRequiredWithoutMembershipsNestedInput = {
    create?: XOR<RoomCreateWithoutMembershipsInput, RoomUncheckedCreateWithoutMembershipsInput>
    connectOrCreate?: RoomCreateOrConnectWithoutMembershipsInput
    upsert?: RoomUpsertWithoutMembershipsInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutMembershipsInput, RoomUpdateWithoutMembershipsInput>, RoomUncheckedUpdateWithoutMembershipsInput>
  }

  export type UserUpdateOneRequiredWithoutRoomMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutRoomMembershipsInput, UserUncheckedCreateWithoutRoomMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoomMembershipsInput
    upsert?: UserUpsertWithoutRoomMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRoomMembershipsInput, UserUpdateWithoutRoomMembershipsInput>, UserUncheckedUpdateWithoutRoomMembershipsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserStatusFilter<$PrismaModel>
    _max?: NestedEnumUserStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumInsightStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightStatus | EnumInsightStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsightStatus[] | ListEnumInsightStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightStatus[] | ListEnumInsightStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightStatusFilter<$PrismaModel> | $Enums.InsightStatus
  }

  export type NestedEnumInsightStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightStatus | EnumInsightStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsightStatus[] | ListEnumInsightStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightStatus[] | ListEnumInsightStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightStatusWithAggregatesFilter<$PrismaModel> | $Enums.InsightStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightStatusFilter<$PrismaModel>
    _max?: NestedEnumInsightStatusFilter<$PrismaModel>
  }

  export type NestedEnumLongevityPlanStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LongevityPlanStatus | EnumLongevityPlanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LongevityPlanStatus[] | ListEnumLongevityPlanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LongevityPlanStatus[] | ListEnumLongevityPlanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLongevityPlanStatusFilter<$PrismaModel> | $Enums.LongevityPlanStatus
  }

  export type NestedEnumLongevityPlanStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LongevityPlanStatus | EnumLongevityPlanStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LongevityPlanStatus[] | ListEnumLongevityPlanStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LongevityPlanStatus[] | ListEnumLongevityPlanStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLongevityPlanStatusWithAggregatesFilter<$PrismaModel> | $Enums.LongevityPlanStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLongevityPlanStatusFilter<$PrismaModel>
    _max?: NestedEnumLongevityPlanStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumBiomarkerSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.BiomarkerSource | EnumBiomarkerSourceFieldRefInput<$PrismaModel>
    in?: $Enums.BiomarkerSource[] | ListEnumBiomarkerSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.BiomarkerSource[] | ListEnumBiomarkerSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumBiomarkerSourceFilter<$PrismaModel> | $Enums.BiomarkerSource
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumBiomarkerSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BiomarkerSource | EnumBiomarkerSourceFieldRefInput<$PrismaModel>
    in?: $Enums.BiomarkerSource[] | ListEnumBiomarkerSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.BiomarkerSource[] | ListEnumBiomarkerSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumBiomarkerSourceWithAggregatesFilter<$PrismaModel> | $Enums.BiomarkerSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBiomarkerSourceFilter<$PrismaModel>
    _max?: NestedEnumBiomarkerSourceFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumPanelUploadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PanelUploadStatus | EnumPanelUploadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PanelUploadStatus[] | ListEnumPanelUploadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PanelUploadStatus[] | ListEnumPanelUploadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPanelUploadStatusFilter<$PrismaModel> | $Enums.PanelUploadStatus
  }

  export type NestedEnumPanelUploadSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.PanelUploadSource | EnumPanelUploadSourceFieldRefInput<$PrismaModel>
    in?: $Enums.PanelUploadSource[] | ListEnumPanelUploadSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.PanelUploadSource[] | ListEnumPanelUploadSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumPanelUploadSourceFilter<$PrismaModel> | $Enums.PanelUploadSource
  }

  export type NestedEnumPanelUploadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PanelUploadStatus | EnumPanelUploadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PanelUploadStatus[] | ListEnumPanelUploadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PanelUploadStatus[] | ListEnumPanelUploadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPanelUploadStatusWithAggregatesFilter<$PrismaModel> | $Enums.PanelUploadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPanelUploadStatusFilter<$PrismaModel>
    _max?: NestedEnumPanelUploadStatusFilter<$PrismaModel>
  }

  export type NestedEnumPanelUploadSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PanelUploadSource | EnumPanelUploadSourceFieldRefInput<$PrismaModel>
    in?: $Enums.PanelUploadSource[] | ListEnumPanelUploadSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.PanelUploadSource[] | ListEnumPanelUploadSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumPanelUploadSourceWithAggregatesFilter<$PrismaModel> | $Enums.PanelUploadSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPanelUploadSourceFilter<$PrismaModel>
    _max?: NestedEnumPanelUploadSourceFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumMeasurementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MeasurementStatus | EnumMeasurementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MeasurementStatus[] | ListEnumMeasurementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeasurementStatus[] | ListEnumMeasurementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMeasurementStatusFilter<$PrismaModel> | $Enums.MeasurementStatus
  }

  export type NestedEnumMeasurementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MeasurementStatus | EnumMeasurementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MeasurementStatus[] | ListEnumMeasurementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeasurementStatus[] | ListEnumMeasurementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMeasurementStatusWithAggregatesFilter<$PrismaModel> | $Enums.MeasurementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMeasurementStatusFilter<$PrismaModel>
    _max?: NestedEnumMeasurementStatusFilter<$PrismaModel>
  }

  export type NestedEnumAuthProviderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProviderType | EnumAuthProviderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProviderType[] | ListEnumAuthProviderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProviderType[] | ListEnumAuthProviderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderTypeFilter<$PrismaModel> | $Enums.AuthProviderType
  }

  export type NestedEnumAuthProviderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProviderType | EnumAuthProviderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AuthProviderType[] | ListEnumAuthProviderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthProviderType[] | ListEnumAuthProviderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthProviderTypeWithAggregatesFilter<$PrismaModel> | $Enums.AuthProviderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthProviderTypeFilter<$PrismaModel>
    _max?: NestedEnumAuthProviderTypeFilter<$PrismaModel>
  }

  export type NestedEnumInsightActionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightActionType | EnumInsightActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsightActionType[] | ListEnumInsightActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightActionType[] | ListEnumInsightActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightActionTypeFilter<$PrismaModel> | $Enums.InsightActionType
  }

  export type NestedEnumInsightActionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightActionType | EnumInsightActionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InsightActionType[] | ListEnumInsightActionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightActionType[] | ListEnumInsightActionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightActionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InsightActionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightActionTypeFilter<$PrismaModel>
    _max?: NestedEnumInsightActionTypeFilter<$PrismaModel>
  }

  export type NestedEnumInsightGenerationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightGenerationStatus | EnumInsightGenerationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsightGenerationStatus[] | ListEnumInsightGenerationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightGenerationStatus[] | ListEnumInsightGenerationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightGenerationStatusFilter<$PrismaModel> | $Enums.InsightGenerationStatus
  }

  export type NestedEnumInsightGenerationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InsightGenerationStatus | EnumInsightGenerationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InsightGenerationStatus[] | ListEnumInsightGenerationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InsightGenerationStatus[] | ListEnumInsightGenerationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInsightGenerationStatusWithAggregatesFilter<$PrismaModel> | $Enums.InsightGenerationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInsightGenerationStatusFilter<$PrismaModel>
    _max?: NestedEnumInsightGenerationStatusFilter<$PrismaModel>
  }

  export type NestedEnumLongevityPlanJobStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LongevityPlanJobStatus | EnumLongevityPlanJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LongevityPlanJobStatus[] | ListEnumLongevityPlanJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LongevityPlanJobStatus[] | ListEnumLongevityPlanJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLongevityPlanJobStatusFilter<$PrismaModel> | $Enums.LongevityPlanJobStatus
  }

  export type NestedEnumLongevityPlanJobStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LongevityPlanJobStatus | EnumLongevityPlanJobStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LongevityPlanJobStatus[] | ListEnumLongevityPlanJobStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LongevityPlanJobStatus[] | ListEnumLongevityPlanJobStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLongevityPlanJobStatusWithAggregatesFilter<$PrismaModel> | $Enums.LongevityPlanJobStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLongevityPlanJobStatusFilter<$PrismaModel>
    _max?: NestedEnumLongevityPlanJobStatusFilter<$PrismaModel>
  }

  export type NestedEnumCloudTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CloudTaskStatus | EnumCloudTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CloudTaskStatus[] | ListEnumCloudTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CloudTaskStatus[] | ListEnumCloudTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCloudTaskStatusFilter<$PrismaModel> | $Enums.CloudTaskStatus
  }

  export type NestedEnumCloudTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CloudTaskStatus | EnumCloudTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CloudTaskStatus[] | ListEnumCloudTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.CloudTaskStatus[] | ListEnumCloudTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumCloudTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.CloudTaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCloudTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumCloudTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumWhoopSyncStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.WhoopSyncStatus | EnumWhoopSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhoopSyncStatus[] | ListEnumWhoopSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhoopSyncStatus[] | ListEnumWhoopSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhoopSyncStatusFilter<$PrismaModel> | $Enums.WhoopSyncStatus
  }

  export type NestedEnumWhoopSyncStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.WhoopSyncStatus | EnumWhoopSyncStatusFieldRefInput<$PrismaModel>
    in?: $Enums.WhoopSyncStatus[] | ListEnumWhoopSyncStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.WhoopSyncStatus[] | ListEnumWhoopSyncStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumWhoopSyncStatusWithAggregatesFilter<$PrismaModel> | $Enums.WhoopSyncStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumWhoopSyncStatusFilter<$PrismaModel>
    _max?: NestedEnumWhoopSyncStatusFilter<$PrismaModel>
  }

  export type NestedEnumPostVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityFilter<$PrismaModel> | $Enums.PostVisibility
  }

  export type NestedEnumPostVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PostVisibility | EnumPostVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.PostVisibility[] | ListEnumPostVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumPostVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.PostVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPostVisibilityFilter<$PrismaModel>
    _max?: NestedEnumPostVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumReactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeFilter<$PrismaModel> | $Enums.ReactionType
  }

  export type NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumEngagementEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementEventType | EnumEngagementEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EngagementEventType[] | ListEnumEngagementEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EngagementEventType[] | ListEnumEngagementEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEngagementEventTypeFilter<$PrismaModel> | $Enums.EngagementEventType
  }

  export type NestedEnumReactionTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReactionTypeNullableFilter<$PrismaModel> | $Enums.ReactionType | null
  }

  export type NestedEnumEngagementEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementEventType | EnumEngagementEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EngagementEventType[] | ListEnumEngagementEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EngagementEventType[] | ListEnumEngagementEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEngagementEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.EngagementEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEngagementEventTypeFilter<$PrismaModel>
    _max?: NestedEnumEngagementEventTypeFilter<$PrismaModel>
  }

  export type NestedEnumReactionTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReactionTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumFlagTargetTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FlagTargetType | EnumFlagTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FlagTargetType[] | ListEnumFlagTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlagTargetType[] | ListEnumFlagTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFlagTargetTypeFilter<$PrismaModel> | $Enums.FlagTargetType
  }

  export type NestedEnumFlagStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.FlagStatus | EnumFlagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlagStatusFilter<$PrismaModel> | $Enums.FlagStatus
  }

  export type NestedEnumFlagTargetTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlagTargetType | EnumFlagTargetTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FlagTargetType[] | ListEnumFlagTargetTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlagTargetType[] | ListEnumFlagTargetTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFlagTargetTypeWithAggregatesFilter<$PrismaModel> | $Enums.FlagTargetType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlagTargetTypeFilter<$PrismaModel>
    _max?: NestedEnumFlagTargetTypeFilter<$PrismaModel>
  }

  export type NestedEnumFlagStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FlagStatus | EnumFlagStatusFieldRefInput<$PrismaModel>
    in?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.FlagStatus[] | ListEnumFlagStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumFlagStatusWithAggregatesFilter<$PrismaModel> | $Enums.FlagStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFlagStatusFilter<$PrismaModel>
    _max?: NestedEnumFlagStatusFilter<$PrismaModel>
  }

  export type NestedEnumRoomStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomStatus | EnumRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomStatusFilter<$PrismaModel> | $Enums.RoomStatus
  }

  export type NestedEnumRoomStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomStatus | EnumRoomStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomStatus[] | ListEnumRoomStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomStatusWithAggregatesFilter<$PrismaModel> | $Enums.RoomStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomStatusFilter<$PrismaModel>
    _max?: NestedEnumRoomStatusFilter<$PrismaModel>
  }

  export type NestedEnumRoomMembershipRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomMembershipRole | EnumRoomMembershipRoleFieldRefInput<$PrismaModel>
    in?: $Enums.RoomMembershipRole[] | ListEnumRoomMembershipRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomMembershipRole[] | ListEnumRoomMembershipRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomMembershipRoleFilter<$PrismaModel> | $Enums.RoomMembershipRole
  }

  export type NestedEnumRoomMembershipStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomMembershipStatus | EnumRoomMembershipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomMembershipStatus[] | ListEnumRoomMembershipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomMembershipStatus[] | ListEnumRoomMembershipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomMembershipStatusFilter<$PrismaModel> | $Enums.RoomMembershipStatus
  }

  export type NestedEnumRoomMembershipRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomMembershipRole | EnumRoomMembershipRoleFieldRefInput<$PrismaModel>
    in?: $Enums.RoomMembershipRole[] | ListEnumRoomMembershipRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomMembershipRole[] | ListEnumRoomMembershipRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomMembershipRoleWithAggregatesFilter<$PrismaModel> | $Enums.RoomMembershipRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomMembershipRoleFilter<$PrismaModel>
    _max?: NestedEnumRoomMembershipRoleFilter<$PrismaModel>
  }

  export type NestedEnumRoomMembershipStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomMembershipStatus | EnumRoomMembershipStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RoomMembershipStatus[] | ListEnumRoomMembershipStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomMembershipStatus[] | ListEnumRoomMembershipStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomMembershipStatusWithAggregatesFilter<$PrismaModel> | $Enums.RoomMembershipStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomMembershipStatusFilter<$PrismaModel>
    _max?: NestedEnumRoomMembershipStatusFilter<$PrismaModel>
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    displayName: string
    timezone: string
    baselineSurvey?: NullableJsonNullValueInput | InputJsonValue
    consents?: NullableJsonNullValueInput | InputJsonValue
    onboardingCompletedAt?: Date | string | null
    deleteRequested?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    displayName: string
    timezone: string
    baselineSurvey?: NullableJsonNullValueInput | InputJsonValue
    consents?: NullableJsonNullValueInput | InputJsonValue
    onboardingCompletedAt?: Date | string | null
    deleteRequested?: boolean
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type AuthProviderCreateWithoutUserInput = {
    id?: string
    type: $Enums.AuthProviderType
    providerUserId?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    scopes?: AuthProviderCreatescopesInput | string[]
    expiresAt?: Date | string | null
    linkedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthProviderUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.AuthProviderType
    providerUserId?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    scopes?: AuthProviderCreatescopesInput | string[]
    expiresAt?: Date | string | null
    linkedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuthProviderCreateOrConnectWithoutUserInput = {
    where: AuthProviderWhereUniqueInput
    create: XOR<AuthProviderCreateWithoutUserInput, AuthProviderUncheckedCreateWithoutUserInput>
  }

  export type AuthProviderCreateManyUserInputEnvelope = {
    data: AuthProviderCreateManyUserInput | AuthProviderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type WhoopIntegrationCreateWithoutUserInput = {
    id?: string
    whoopUserId?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    scope?: WhoopIntegrationCreatescopeInput | string[]
    tokenKeyId?: string | null
    tokenRotatedAt?: Date | string | null
    syncStatus?: $Enums.WhoopSyncStatus
    lastSyncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhoopIntegrationUncheckedCreateWithoutUserInput = {
    id?: string
    whoopUserId?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    expiresAt?: Date | string | null
    scope?: WhoopIntegrationCreatescopeInput | string[]
    tokenKeyId?: string | null
    tokenRotatedAt?: Date | string | null
    syncStatus?: $Enums.WhoopSyncStatus
    lastSyncedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhoopIntegrationCreateOrConnectWithoutUserInput = {
    where: WhoopIntegrationWhereUniqueInput
    create: XOR<WhoopIntegrationCreateWithoutUserInput, WhoopIntegrationUncheckedCreateWithoutUserInput>
  }

  export type WhoopLinkSessionCreateWithoutUserInput = {
    id?: string
    state: string
    redirectUri: string
    scope?: WhoopLinkSessionCreatescopeInput | string[]
    expiresAt: Date | string
    createdAt?: Date | string
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type WhoopLinkSessionUncheckedCreateWithoutUserInput = {
    id?: string
    state: string
    redirectUri: string
    scope?: WhoopLinkSessionCreatescopeInput | string[]
    expiresAt: Date | string
    createdAt?: Date | string
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type WhoopLinkSessionCreateOrConnectWithoutUserInput = {
    where: WhoopLinkSessionWhereUniqueInput
    create: XOR<WhoopLinkSessionCreateWithoutUserInput, WhoopLinkSessionUncheckedCreateWithoutUserInput>
  }

  export type WhoopLinkSessionCreateManyUserInputEnvelope = {
    data: WhoopLinkSessionCreateManyUserInput | WhoopLinkSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InsightCreateWithoutUserInput = {
    id?: string
    title: string
    summary: string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InsightStatus
    generatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: InsightActionCreateNestedManyWithoutInsightInput
    generationJobs?: InsightGenerationJobCreateNestedManyWithoutInsightInput
    flags?: FlagCreateNestedManyWithoutInsightInput
  }

  export type InsightUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    summary: string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InsightStatus
    generatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: InsightActionUncheckedCreateNestedManyWithoutInsightInput
    generationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutInsightInput
    flags?: FlagUncheckedCreateNestedManyWithoutInsightInput
  }

  export type InsightCreateOrConnectWithoutUserInput = {
    where: InsightWhereUniqueInput
    create: XOR<InsightCreateWithoutUserInput, InsightUncheckedCreateWithoutUserInput>
  }

  export type InsightCreateManyUserInputEnvelope = {
    data: InsightCreateManyUserInput | InsightCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type InsightActionCreateWithoutActorInput = {
    id?: string
    actionType: $Enums.InsightActionType
    notes?: string | null
    createdAt?: Date | string
    insight: InsightCreateNestedOneWithoutActionsInput
  }

  export type InsightActionUncheckedCreateWithoutActorInput = {
    id?: string
    insightId: string
    actionType: $Enums.InsightActionType
    notes?: string | null
    createdAt?: Date | string
  }

  export type InsightActionCreateOrConnectWithoutActorInput = {
    where: InsightActionWhereUniqueInput
    create: XOR<InsightActionCreateWithoutActorInput, InsightActionUncheckedCreateWithoutActorInput>
  }

  export type InsightActionCreateManyActorInputEnvelope = {
    data: InsightActionCreateManyActorInput | InsightActionCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type InsightGenerationJobCreateWithoutRequestedByInput = {
    id?: string
    status: $Enums.InsightGenerationStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    insight?: InsightCreateNestedOneWithoutGenerationJobsInput
    cloudTask?: CloudTaskMetadataCreateNestedOneWithoutJobInput
  }

  export type InsightGenerationJobUncheckedCreateWithoutRequestedByInput = {
    id?: string
    insightId?: string | null
    status: $Enums.InsightGenerationStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cloudTask?: CloudTaskMetadataUncheckedCreateNestedOneWithoutJobInput
  }

  export type InsightGenerationJobCreateOrConnectWithoutRequestedByInput = {
    where: InsightGenerationJobWhereUniqueInput
    create: XOR<InsightGenerationJobCreateWithoutRequestedByInput, InsightGenerationJobUncheckedCreateWithoutRequestedByInput>
  }

  export type InsightGenerationJobCreateManyRequestedByInputEnvelope = {
    data: InsightGenerationJobCreateManyRequestedByInput | InsightGenerationJobCreateManyRequestedByInput[]
    skipDuplicates?: boolean
  }

  export type BiomarkerLogCreateWithoutUserInput = {
    id?: string
    value: Decimal | DecimalJsLike | number | string
    unit?: string | null
    source?: $Enums.BiomarkerSource
    capturedAt: Date | string
    accepted?: boolean
    flagged?: boolean
    notes?: string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    biomarker: BiomarkerCreateNestedOneWithoutLogsInput
    flags?: FlagCreateNestedManyWithoutBiomarkerLogInput
  }

  export type BiomarkerLogUncheckedCreateWithoutUserInput = {
    id?: string
    biomarkerId: string
    value: Decimal | DecimalJsLike | number | string
    unit?: string | null
    source?: $Enums.BiomarkerSource
    capturedAt: Date | string
    accepted?: boolean
    flagged?: boolean
    notes?: string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    flags?: FlagUncheckedCreateNestedManyWithoutBiomarkerLogInput
  }

  export type BiomarkerLogCreateOrConnectWithoutUserInput = {
    where: BiomarkerLogWhereUniqueInput
    create: XOR<BiomarkerLogCreateWithoutUserInput, BiomarkerLogUncheckedCreateWithoutUserInput>
  }

  export type BiomarkerLogCreateManyUserInputEnvelope = {
    data: BiomarkerLogCreateManyUserInput | BiomarkerLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PanelUploadCreateWithoutUserInput = {
    id?: string
    status?: $Enums.PanelUploadStatus
    source?: $Enums.PanelUploadSource
    storageKey: string
    contentType?: string | null
    pageCount?: number | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    normalizedPayload?: NullableJsonNullValueInput | InputJsonValue
    measurementCount?: number
    processedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    measurements?: BiomarkerMeasurementCreateNestedManyWithoutPanelUploadInput
  }

  export type PanelUploadUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.PanelUploadStatus
    source?: $Enums.PanelUploadSource
    storageKey: string
    contentType?: string | null
    pageCount?: number | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    normalizedPayload?: NullableJsonNullValueInput | InputJsonValue
    measurementCount?: number
    processedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    measurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutPanelUploadInput
  }

  export type PanelUploadCreateOrConnectWithoutUserInput = {
    where: PanelUploadWhereUniqueInput
    create: XOR<PanelUploadCreateWithoutUserInput, PanelUploadUncheckedCreateWithoutUserInput>
  }

  export type PanelUploadCreateManyUserInputEnvelope = {
    data: PanelUploadCreateManyUserInput | PanelUploadCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BiomarkerMeasurementCreateWithoutUserInput = {
    id?: string
    markerName: string
    value?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    capturedAt?: Date | string | null
    status?: $Enums.MeasurementStatus
    source?: $Enums.BiomarkerSource
    confidence?: Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    biomarker?: BiomarkerCreateNestedOneWithoutMeasurementsInput
    panelUpload?: PanelUploadCreateNestedOneWithoutMeasurementsInput
  }

  export type BiomarkerMeasurementUncheckedCreateWithoutUserInput = {
    id?: string
    biomarkerId?: string | null
    panelUploadId?: string | null
    markerName: string
    value?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    capturedAt?: Date | string | null
    status?: $Enums.MeasurementStatus
    source?: $Enums.BiomarkerSource
    confidence?: Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiomarkerMeasurementCreateOrConnectWithoutUserInput = {
    where: BiomarkerMeasurementWhereUniqueInput
    create: XOR<BiomarkerMeasurementCreateWithoutUserInput, BiomarkerMeasurementUncheckedCreateWithoutUserInput>
  }

  export type BiomarkerMeasurementCreateManyUserInputEnvelope = {
    data: BiomarkerMeasurementCreateManyUserInput | BiomarkerMeasurementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FeedPostCreateWithoutAuthorInput = {
    id?: string
    body: string
    tags?: FeedPostCreatetagsInput | string[]
    visibility?: $Enums.PostVisibility
    flagged?: boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    flags?: FlagCreateNestedManyWithoutPostInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutPostInput
  }

  export type FeedPostUncheckedCreateWithoutAuthorInput = {
    id?: string
    body: string
    tags?: FeedPostCreatetagsInput | string[]
    visibility?: $Enums.PostVisibility
    flagged?: boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    flags?: FlagUncheckedCreateNestedManyWithoutPostInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutPostInput
  }

  export type FeedPostCreateOrConnectWithoutAuthorInput = {
    where: FeedPostWhereUniqueInput
    create: XOR<FeedPostCreateWithoutAuthorInput, FeedPostUncheckedCreateWithoutAuthorInput>
  }

  export type FeedPostCreateManyAuthorInputEnvelope = {
    data: FeedPostCreateManyAuthorInput | FeedPostCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type CommentCreateWithoutAuthorInput = {
    id?: string
    body: string
    flagged?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    post: FeedPostCreateNestedOneWithoutCommentsInput
    reactions?: ReactionCreateNestedManyWithoutCommentInput
    flags?: FlagCreateNestedManyWithoutCommentInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutAuthorInput = {
    id?: string
    postId: string
    body: string
    flagged?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ReactionUncheckedCreateNestedManyWithoutCommentInput
    flags?: FlagUncheckedCreateNestedManyWithoutCommentInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentCreateManyAuthorInputEnvelope = {
    data: CommentCreateManyAuthorInput | CommentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type ReactionCreateWithoutUserInput = {
    id?: string
    type: $Enums.ReactionType
    createdAt?: Date | string
    post?: FeedPostCreateNestedOneWithoutReactionsInput
    comment?: CommentCreateNestedOneWithoutReactionsInput
  }

  export type ReactionUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.ReactionType
    postId?: string | null
    commentId?: string | null
    createdAt?: Date | string
  }

  export type ReactionCreateOrConnectWithoutUserInput = {
    where: ReactionWhereUniqueInput
    create: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput>
  }

  export type ReactionCreateManyUserInputEnvelope = {
    data: ReactionCreateManyUserInput | ReactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EngagementEventCreateWithoutUserInput = {
    id?: string
    type: $Enums.EngagementEventType
    reactionType?: $Enums.ReactionType | null
    occurredAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    post?: FeedPostCreateNestedOneWithoutEngagementEventsInput
    comment?: CommentCreateNestedOneWithoutEngagementEventsInput
  }

  export type EngagementEventUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.EngagementEventType
    postId?: string | null
    commentId?: string | null
    reactionType?: $Enums.ReactionType | null
    occurredAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EngagementEventCreateOrConnectWithoutUserInput = {
    where: EngagementEventWhereUniqueInput
    create: XOR<EngagementEventCreateWithoutUserInput, EngagementEventUncheckedCreateWithoutUserInput>
  }

  export type EngagementEventCreateManyUserInputEnvelope = {
    data: EngagementEventCreateManyUserInput | EngagementEventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoomCreateWithoutHostInput = {
    id?: string
    name?: string | null
    inviteCode: string
    status?: $Enums.RoomStatus
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: RoomMembershipCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutHostInput = {
    id?: string
    name?: string | null
    inviteCode: string
    status?: $Enums.RoomStatus
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    memberships?: RoomMembershipUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutHostInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutHostInput, RoomUncheckedCreateWithoutHostInput>
  }

  export type RoomCreateManyHostInputEnvelope = {
    data: RoomCreateManyHostInput | RoomCreateManyHostInput[]
    skipDuplicates?: boolean
  }

  export type RoomMembershipCreateWithoutUserInput = {
    id?: string
    role?: $Enums.RoomMembershipRole
    status?: $Enums.RoomMembershipStatus
    joinedAt?: Date | string
    leftAt?: Date | string | null
    lastSeenAt?: Date | string | null
    reconnectToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    room: RoomCreateNestedOneWithoutMembershipsInput
  }

  export type RoomMembershipUncheckedCreateWithoutUserInput = {
    id?: string
    roomId: string
    role?: $Enums.RoomMembershipRole
    status?: $Enums.RoomMembershipStatus
    joinedAt?: Date | string
    leftAt?: Date | string | null
    lastSeenAt?: Date | string | null
    reconnectToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomMembershipCreateOrConnectWithoutUserInput = {
    where: RoomMembershipWhereUniqueInput
    create: XOR<RoomMembershipCreateWithoutUserInput, RoomMembershipUncheckedCreateWithoutUserInput>
  }

  export type RoomMembershipCreateManyUserInputEnvelope = {
    data: RoomMembershipCreateManyUserInput | RoomMembershipCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FlagCreateWithoutOpenedByInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: FeedPostCreateNestedOneWithoutFlagsInput
    comment?: CommentCreateNestedOneWithoutFlagsInput
    insight?: InsightCreateNestedOneWithoutFlagsInput
    biomarkerLog?: BiomarkerLogCreateNestedOneWithoutFlagsInput
    resolvedBy?: UserCreateNestedOneWithoutFlagsResolvedInput
  }

  export type FlagUncheckedCreateWithoutOpenedByInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    postId?: string | null
    commentId?: string | null
    insightId?: string | null
    biomarkerLogId?: string | null
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlagCreateOrConnectWithoutOpenedByInput = {
    where: FlagWhereUniqueInput
    create: XOR<FlagCreateWithoutOpenedByInput, FlagUncheckedCreateWithoutOpenedByInput>
  }

  export type FlagCreateManyOpenedByInputEnvelope = {
    data: FlagCreateManyOpenedByInput | FlagCreateManyOpenedByInput[]
    skipDuplicates?: boolean
  }

  export type FlagCreateWithoutResolvedByInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: FeedPostCreateNestedOneWithoutFlagsInput
    comment?: CommentCreateNestedOneWithoutFlagsInput
    insight?: InsightCreateNestedOneWithoutFlagsInput
    biomarkerLog?: BiomarkerLogCreateNestedOneWithoutFlagsInput
    openedBy: UserCreateNestedOneWithoutFlagsOpenedInput
  }

  export type FlagUncheckedCreateWithoutResolvedByInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    postId?: string | null
    commentId?: string | null
    insightId?: string | null
    biomarkerLogId?: string | null
    openedById: string
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlagCreateOrConnectWithoutResolvedByInput = {
    where: FlagWhereUniqueInput
    create: XOR<FlagCreateWithoutResolvedByInput, FlagUncheckedCreateWithoutResolvedByInput>
  }

  export type FlagCreateManyResolvedByInputEnvelope = {
    data: FlagCreateManyResolvedByInput | FlagCreateManyResolvedByInput[]
    skipDuplicates?: boolean
  }

  export type AdminAuditLogCreateWithoutActorInput = {
    id?: string
    action: string
    targetType: string
    targetId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AdminAuditLogUncheckedCreateWithoutActorInput = {
    id?: string
    action: string
    targetType: string
    targetId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AdminAuditLogCreateOrConnectWithoutActorInput = {
    where: AdminAuditLogWhereUniqueInput
    create: XOR<AdminAuditLogCreateWithoutActorInput, AdminAuditLogUncheckedCreateWithoutActorInput>
  }

  export type AdminAuditLogCreateManyActorInputEnvelope = {
    data: AdminAuditLogCreateManyActorInput | AdminAuditLogCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type LongevityPlanCreateWithoutUserInput = {
    id?: string
    status?: $Enums.LongevityPlanStatus
    title: string
    summary?: string | null
    focusAreas?: LongevityPlanCreatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: string | null
    validatedAt?: Date | string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: LongevityPlanJobCreateNestedManyWithoutPlanInput
    audits?: AiResponseAuditCreateNestedManyWithoutPlanInput
  }

  export type LongevityPlanUncheckedCreateWithoutUserInput = {
    id?: string
    status?: $Enums.LongevityPlanStatus
    title: string
    summary?: string | null
    focusAreas?: LongevityPlanCreatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: string | null
    validatedAt?: Date | string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutPlanInput
    audits?: AiResponseAuditUncheckedCreateNestedManyWithoutPlanInput
  }

  export type LongevityPlanCreateOrConnectWithoutUserInput = {
    where: LongevityPlanWhereUniqueInput
    create: XOR<LongevityPlanCreateWithoutUserInput, LongevityPlanUncheckedCreateWithoutUserInput>
  }

  export type LongevityPlanCreateManyUserInputEnvelope = {
    data: LongevityPlanCreateManyUserInput | LongevityPlanCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LongevityPlanJobCreateWithoutRequestedByInput = {
    id?: string
    status?: $Enums.LongevityPlanJobStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: LongevityPlanCreateNestedOneWithoutJobsInput
    cloudTask?: CloudTaskMetadataCreateNestedOneWithoutPlanJobInput
  }

  export type LongevityPlanJobUncheckedCreateWithoutRequestedByInput = {
    id?: string
    planId?: string | null
    status?: $Enums.LongevityPlanJobStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cloudTask?: CloudTaskMetadataUncheckedCreateNestedOneWithoutPlanJobInput
  }

  export type LongevityPlanJobCreateOrConnectWithoutRequestedByInput = {
    where: LongevityPlanJobWhereUniqueInput
    create: XOR<LongevityPlanJobCreateWithoutRequestedByInput, LongevityPlanJobUncheckedCreateWithoutRequestedByInput>
  }

  export type LongevityPlanJobCreateManyRequestedByInputEnvelope = {
    data: LongevityPlanJobCreateManyRequestedByInput | LongevityPlanJobCreateManyRequestedByInput[]
    skipDuplicates?: boolean
  }

  export type AiResponseAuditCreateWithoutUserInput = {
    id?: string
    provider: string
    model?: string | null
    role?: string | null
    prompt?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    plan?: LongevityPlanCreateNestedOneWithoutAuditsInput
  }

  export type AiResponseAuditUncheckedCreateWithoutUserInput = {
    id?: string
    planId?: string | null
    provider: string
    model?: string | null
    role?: string | null
    prompt?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AiResponseAuditCreateOrConnectWithoutUserInput = {
    where: AiResponseAuditWhereUniqueInput
    create: XOR<AiResponseAuditCreateWithoutUserInput, AiResponseAuditUncheckedCreateWithoutUserInput>
  }

  export type AiResponseAuditCreateManyUserInputEnvelope = {
    data: AiResponseAuditCreateManyUserInput | AiResponseAuditCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LoginAuditCreateWithoutUserInput = {
    id?: string
    email: string
    provider: $Enums.AuthProviderType
    success: boolean
    ipAddress?: string | null
    userAgent?: string | null
    failureReason?: string | null
    createdAt?: Date | string
  }

  export type LoginAuditUncheckedCreateWithoutUserInput = {
    id?: string
    email: string
    provider: $Enums.AuthProviderType
    success: boolean
    ipAddress?: string | null
    userAgent?: string | null
    failureReason?: string | null
    createdAt?: Date | string
  }

  export type LoginAuditCreateOrConnectWithoutUserInput = {
    where: LoginAuditWhereUniqueInput
    create: XOR<LoginAuditCreateWithoutUserInput, LoginAuditUncheckedCreateWithoutUserInput>
  }

  export type LoginAuditCreateManyUserInputEnvelope = {
    data: LoginAuditCreateManyUserInput | LoginAuditCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    baselineSurvey?: NullableJsonNullValueInput | InputJsonValue
    consents?: NullableJsonNullValueInput | InputJsonValue
    onboardingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleteRequested?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    timezone?: StringFieldUpdateOperationsInput | string
    baselineSurvey?: NullableJsonNullValueInput | InputJsonValue
    consents?: NullableJsonNullValueInput | InputJsonValue
    onboardingCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deleteRequested?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthProviderUpsertWithWhereUniqueWithoutUserInput = {
    where: AuthProviderWhereUniqueInput
    update: XOR<AuthProviderUpdateWithoutUserInput, AuthProviderUncheckedUpdateWithoutUserInput>
    create: XOR<AuthProviderCreateWithoutUserInput, AuthProviderUncheckedCreateWithoutUserInput>
  }

  export type AuthProviderUpdateWithWhereUniqueWithoutUserInput = {
    where: AuthProviderWhereUniqueInput
    data: XOR<AuthProviderUpdateWithoutUserInput, AuthProviderUncheckedUpdateWithoutUserInput>
  }

  export type AuthProviderUpdateManyWithWhereWithoutUserInput = {
    where: AuthProviderScalarWhereInput
    data: XOR<AuthProviderUpdateManyMutationInput, AuthProviderUncheckedUpdateManyWithoutUserInput>
  }

  export type AuthProviderScalarWhereInput = {
    AND?: AuthProviderScalarWhereInput | AuthProviderScalarWhereInput[]
    OR?: AuthProviderScalarWhereInput[]
    NOT?: AuthProviderScalarWhereInput | AuthProviderScalarWhereInput[]
    id?: StringFilter<"AuthProvider"> | string
    userId?: StringFilter<"AuthProvider"> | string
    type?: EnumAuthProviderTypeFilter<"AuthProvider"> | $Enums.AuthProviderType
    providerUserId?: StringNullableFilter<"AuthProvider"> | string | null
    accessToken?: StringNullableFilter<"AuthProvider"> | string | null
    refreshToken?: StringNullableFilter<"AuthProvider"> | string | null
    scopes?: StringNullableListFilter<"AuthProvider">
    expiresAt?: DateTimeNullableFilter<"AuthProvider"> | Date | string | null
    linkedAt?: DateTimeFilter<"AuthProvider"> | Date | string
    createdAt?: DateTimeFilter<"AuthProvider"> | Date | string
    updatedAt?: DateTimeFilter<"AuthProvider"> | Date | string
  }

  export type WhoopIntegrationUpsertWithoutUserInput = {
    update: XOR<WhoopIntegrationUpdateWithoutUserInput, WhoopIntegrationUncheckedUpdateWithoutUserInput>
    create: XOR<WhoopIntegrationCreateWithoutUserInput, WhoopIntegrationUncheckedCreateWithoutUserInput>
    where?: WhoopIntegrationWhereInput
  }

  export type WhoopIntegrationUpdateToOneWithWhereWithoutUserInput = {
    where?: WhoopIntegrationWhereInput
    data: XOR<WhoopIntegrationUpdateWithoutUserInput, WhoopIntegrationUncheckedUpdateWithoutUserInput>
  }

  export type WhoopIntegrationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    whoopUserId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: WhoopIntegrationUpdatescopeInput | string[]
    tokenKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenRotatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: EnumWhoopSyncStatusFieldUpdateOperationsInput | $Enums.WhoopSyncStatus
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhoopIntegrationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    whoopUserId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    scope?: WhoopIntegrationUpdatescopeInput | string[]
    tokenKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    tokenRotatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: EnumWhoopSyncStatusFieldUpdateOperationsInput | $Enums.WhoopSyncStatus
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhoopLinkSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: WhoopLinkSessionWhereUniqueInput
    update: XOR<WhoopLinkSessionUpdateWithoutUserInput, WhoopLinkSessionUncheckedUpdateWithoutUserInput>
    create: XOR<WhoopLinkSessionCreateWithoutUserInput, WhoopLinkSessionUncheckedCreateWithoutUserInput>
  }

  export type WhoopLinkSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: WhoopLinkSessionWhereUniqueInput
    data: XOR<WhoopLinkSessionUpdateWithoutUserInput, WhoopLinkSessionUncheckedUpdateWithoutUserInput>
  }

  export type WhoopLinkSessionUpdateManyWithWhereWithoutUserInput = {
    where: WhoopLinkSessionScalarWhereInput
    data: XOR<WhoopLinkSessionUpdateManyMutationInput, WhoopLinkSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type WhoopLinkSessionScalarWhereInput = {
    AND?: WhoopLinkSessionScalarWhereInput | WhoopLinkSessionScalarWhereInput[]
    OR?: WhoopLinkSessionScalarWhereInput[]
    NOT?: WhoopLinkSessionScalarWhereInput | WhoopLinkSessionScalarWhereInput[]
    id?: StringFilter<"WhoopLinkSession"> | string
    userId?: StringFilter<"WhoopLinkSession"> | string
    state?: StringFilter<"WhoopLinkSession"> | string
    redirectUri?: StringFilter<"WhoopLinkSession"> | string
    scope?: StringNullableListFilter<"WhoopLinkSession">
    expiresAt?: DateTimeFilter<"WhoopLinkSession"> | Date | string
    createdAt?: DateTimeFilter<"WhoopLinkSession"> | Date | string
    completedAt?: DateTimeNullableFilter<"WhoopLinkSession"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"WhoopLinkSession"> | Date | string | null
  }

  export type InsightUpsertWithWhereUniqueWithoutUserInput = {
    where: InsightWhereUniqueInput
    update: XOR<InsightUpdateWithoutUserInput, InsightUncheckedUpdateWithoutUserInput>
    create: XOR<InsightCreateWithoutUserInput, InsightUncheckedCreateWithoutUserInput>
  }

  export type InsightUpdateWithWhereUniqueWithoutUserInput = {
    where: InsightWhereUniqueInput
    data: XOR<InsightUpdateWithoutUserInput, InsightUncheckedUpdateWithoutUserInput>
  }

  export type InsightUpdateManyWithWhereWithoutUserInput = {
    where: InsightScalarWhereInput
    data: XOR<InsightUpdateManyMutationInput, InsightUncheckedUpdateManyWithoutUserInput>
  }

  export type InsightScalarWhereInput = {
    AND?: InsightScalarWhereInput | InsightScalarWhereInput[]
    OR?: InsightScalarWhereInput[]
    NOT?: InsightScalarWhereInput | InsightScalarWhereInput[]
    id?: StringFilter<"Insight"> | string
    userId?: StringFilter<"Insight"> | string
    title?: StringFilter<"Insight"> | string
    summary?: StringFilter<"Insight"> | string
    body?: JsonNullableFilter<"Insight">
    modelUsed?: StringNullableFilter<"Insight"> | string | null
    promptMetadata?: JsonNullableFilter<"Insight">
    status?: EnumInsightStatusFilter<"Insight"> | $Enums.InsightStatus
    generatedAt?: DateTimeFilter<"Insight"> | Date | string
    createdAt?: DateTimeFilter<"Insight"> | Date | string
    updatedAt?: DateTimeFilter<"Insight"> | Date | string
  }

  export type InsightActionUpsertWithWhereUniqueWithoutActorInput = {
    where: InsightActionWhereUniqueInput
    update: XOR<InsightActionUpdateWithoutActorInput, InsightActionUncheckedUpdateWithoutActorInput>
    create: XOR<InsightActionCreateWithoutActorInput, InsightActionUncheckedCreateWithoutActorInput>
  }

  export type InsightActionUpdateWithWhereUniqueWithoutActorInput = {
    where: InsightActionWhereUniqueInput
    data: XOR<InsightActionUpdateWithoutActorInput, InsightActionUncheckedUpdateWithoutActorInput>
  }

  export type InsightActionUpdateManyWithWhereWithoutActorInput = {
    where: InsightActionScalarWhereInput
    data: XOR<InsightActionUpdateManyMutationInput, InsightActionUncheckedUpdateManyWithoutActorInput>
  }

  export type InsightActionScalarWhereInput = {
    AND?: InsightActionScalarWhereInput | InsightActionScalarWhereInput[]
    OR?: InsightActionScalarWhereInput[]
    NOT?: InsightActionScalarWhereInput | InsightActionScalarWhereInput[]
    id?: StringFilter<"InsightAction"> | string
    insightId?: StringFilter<"InsightAction"> | string
    actorId?: StringNullableFilter<"InsightAction"> | string | null
    actionType?: EnumInsightActionTypeFilter<"InsightAction"> | $Enums.InsightActionType
    notes?: StringNullableFilter<"InsightAction"> | string | null
    createdAt?: DateTimeFilter<"InsightAction"> | Date | string
  }

  export type InsightGenerationJobUpsertWithWhereUniqueWithoutRequestedByInput = {
    where: InsightGenerationJobWhereUniqueInput
    update: XOR<InsightGenerationJobUpdateWithoutRequestedByInput, InsightGenerationJobUncheckedUpdateWithoutRequestedByInput>
    create: XOR<InsightGenerationJobCreateWithoutRequestedByInput, InsightGenerationJobUncheckedCreateWithoutRequestedByInput>
  }

  export type InsightGenerationJobUpdateWithWhereUniqueWithoutRequestedByInput = {
    where: InsightGenerationJobWhereUniqueInput
    data: XOR<InsightGenerationJobUpdateWithoutRequestedByInput, InsightGenerationJobUncheckedUpdateWithoutRequestedByInput>
  }

  export type InsightGenerationJobUpdateManyWithWhereWithoutRequestedByInput = {
    where: InsightGenerationJobScalarWhereInput
    data: XOR<InsightGenerationJobUpdateManyMutationInput, InsightGenerationJobUncheckedUpdateManyWithoutRequestedByInput>
  }

  export type InsightGenerationJobScalarWhereInput = {
    AND?: InsightGenerationJobScalarWhereInput | InsightGenerationJobScalarWhereInput[]
    OR?: InsightGenerationJobScalarWhereInput[]
    NOT?: InsightGenerationJobScalarWhereInput | InsightGenerationJobScalarWhereInput[]
    id?: StringFilter<"InsightGenerationJob"> | string
    insightId?: StringNullableFilter<"InsightGenerationJob"> | string | null
    requestedById?: StringNullableFilter<"InsightGenerationJob"> | string | null
    status?: EnumInsightGenerationStatusFilter<"InsightGenerationJob"> | $Enums.InsightGenerationStatus
    cloudTaskName?: StringNullableFilter<"InsightGenerationJob"> | string | null
    queue?: StringNullableFilter<"InsightGenerationJob"> | string | null
    payload?: JsonNullableFilter<"InsightGenerationJob">
    scheduledAt?: DateTimeNullableFilter<"InsightGenerationJob"> | Date | string | null
    dispatchedAt?: DateTimeNullableFilter<"InsightGenerationJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"InsightGenerationJob"> | Date | string | null
    errorCode?: StringNullableFilter<"InsightGenerationJob"> | string | null
    errorMessage?: StringNullableFilter<"InsightGenerationJob"> | string | null
    createdAt?: DateTimeFilter<"InsightGenerationJob"> | Date | string
    updatedAt?: DateTimeFilter<"InsightGenerationJob"> | Date | string
  }

  export type BiomarkerLogUpsertWithWhereUniqueWithoutUserInput = {
    where: BiomarkerLogWhereUniqueInput
    update: XOR<BiomarkerLogUpdateWithoutUserInput, BiomarkerLogUncheckedUpdateWithoutUserInput>
    create: XOR<BiomarkerLogCreateWithoutUserInput, BiomarkerLogUncheckedCreateWithoutUserInput>
  }

  export type BiomarkerLogUpdateWithWhereUniqueWithoutUserInput = {
    where: BiomarkerLogWhereUniqueInput
    data: XOR<BiomarkerLogUpdateWithoutUserInput, BiomarkerLogUncheckedUpdateWithoutUserInput>
  }

  export type BiomarkerLogUpdateManyWithWhereWithoutUserInput = {
    where: BiomarkerLogScalarWhereInput
    data: XOR<BiomarkerLogUpdateManyMutationInput, BiomarkerLogUncheckedUpdateManyWithoutUserInput>
  }

  export type BiomarkerLogScalarWhereInput = {
    AND?: BiomarkerLogScalarWhereInput | BiomarkerLogScalarWhereInput[]
    OR?: BiomarkerLogScalarWhereInput[]
    NOT?: BiomarkerLogScalarWhereInput | BiomarkerLogScalarWhereInput[]
    id?: StringFilter<"BiomarkerLog"> | string
    userId?: StringFilter<"BiomarkerLog"> | string
    biomarkerId?: StringFilter<"BiomarkerLog"> | string
    value?: DecimalFilter<"BiomarkerLog"> | Decimal | DecimalJsLike | number | string
    unit?: StringNullableFilter<"BiomarkerLog"> | string | null
    source?: EnumBiomarkerSourceFilter<"BiomarkerLog"> | $Enums.BiomarkerSource
    capturedAt?: DateTimeFilter<"BiomarkerLog"> | Date | string
    accepted?: BoolFilter<"BiomarkerLog"> | boolean
    flagged?: BoolFilter<"BiomarkerLog"> | boolean
    notes?: StringNullableFilter<"BiomarkerLog"> | string | null
    rawPayload?: JsonNullableFilter<"BiomarkerLog">
    createdAt?: DateTimeFilter<"BiomarkerLog"> | Date | string
    updatedAt?: DateTimeFilter<"BiomarkerLog"> | Date | string
  }

  export type PanelUploadUpsertWithWhereUniqueWithoutUserInput = {
    where: PanelUploadWhereUniqueInput
    update: XOR<PanelUploadUpdateWithoutUserInput, PanelUploadUncheckedUpdateWithoutUserInput>
    create: XOR<PanelUploadCreateWithoutUserInput, PanelUploadUncheckedCreateWithoutUserInput>
  }

  export type PanelUploadUpdateWithWhereUniqueWithoutUserInput = {
    where: PanelUploadWhereUniqueInput
    data: XOR<PanelUploadUpdateWithoutUserInput, PanelUploadUncheckedUpdateWithoutUserInput>
  }

  export type PanelUploadUpdateManyWithWhereWithoutUserInput = {
    where: PanelUploadScalarWhereInput
    data: XOR<PanelUploadUpdateManyMutationInput, PanelUploadUncheckedUpdateManyWithoutUserInput>
  }

  export type PanelUploadScalarWhereInput = {
    AND?: PanelUploadScalarWhereInput | PanelUploadScalarWhereInput[]
    OR?: PanelUploadScalarWhereInput[]
    NOT?: PanelUploadScalarWhereInput | PanelUploadScalarWhereInput[]
    id?: StringFilter<"PanelUpload"> | string
    userId?: StringFilter<"PanelUpload"> | string
    status?: EnumPanelUploadStatusFilter<"PanelUpload"> | $Enums.PanelUploadStatus
    source?: EnumPanelUploadSourceFilter<"PanelUpload"> | $Enums.PanelUploadSource
    storageKey?: StringFilter<"PanelUpload"> | string
    contentType?: StringNullableFilter<"PanelUpload"> | string | null
    pageCount?: IntNullableFilter<"PanelUpload"> | number | null
    rawMetadata?: JsonNullableFilter<"PanelUpload">
    normalizedPayload?: JsonNullableFilter<"PanelUpload">
    measurementCount?: IntFilter<"PanelUpload"> | number
    processedAt?: DateTimeNullableFilter<"PanelUpload"> | Date | string | null
    errorCode?: StringNullableFilter<"PanelUpload"> | string | null
    errorMessage?: StringNullableFilter<"PanelUpload"> | string | null
    createdAt?: DateTimeFilter<"PanelUpload"> | Date | string
    updatedAt?: DateTimeFilter<"PanelUpload"> | Date | string
  }

  export type BiomarkerMeasurementUpsertWithWhereUniqueWithoutUserInput = {
    where: BiomarkerMeasurementWhereUniqueInput
    update: XOR<BiomarkerMeasurementUpdateWithoutUserInput, BiomarkerMeasurementUncheckedUpdateWithoutUserInput>
    create: XOR<BiomarkerMeasurementCreateWithoutUserInput, BiomarkerMeasurementUncheckedCreateWithoutUserInput>
  }

  export type BiomarkerMeasurementUpdateWithWhereUniqueWithoutUserInput = {
    where: BiomarkerMeasurementWhereUniqueInput
    data: XOR<BiomarkerMeasurementUpdateWithoutUserInput, BiomarkerMeasurementUncheckedUpdateWithoutUserInput>
  }

  export type BiomarkerMeasurementUpdateManyWithWhereWithoutUserInput = {
    where: BiomarkerMeasurementScalarWhereInput
    data: XOR<BiomarkerMeasurementUpdateManyMutationInput, BiomarkerMeasurementUncheckedUpdateManyWithoutUserInput>
  }

  export type BiomarkerMeasurementScalarWhereInput = {
    AND?: BiomarkerMeasurementScalarWhereInput | BiomarkerMeasurementScalarWhereInput[]
    OR?: BiomarkerMeasurementScalarWhereInput[]
    NOT?: BiomarkerMeasurementScalarWhereInput | BiomarkerMeasurementScalarWhereInput[]
    id?: StringFilter<"BiomarkerMeasurement"> | string
    userId?: StringFilter<"BiomarkerMeasurement"> | string
    biomarkerId?: StringNullableFilter<"BiomarkerMeasurement"> | string | null
    panelUploadId?: StringNullableFilter<"BiomarkerMeasurement"> | string | null
    markerName?: StringFilter<"BiomarkerMeasurement"> | string
    value?: DecimalNullableFilter<"BiomarkerMeasurement"> | Decimal | DecimalJsLike | number | string | null
    unit?: StringNullableFilter<"BiomarkerMeasurement"> | string | null
    referenceLow?: DecimalNullableFilter<"BiomarkerMeasurement"> | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: DecimalNullableFilter<"BiomarkerMeasurement"> | Decimal | DecimalJsLike | number | string | null
    capturedAt?: DateTimeNullableFilter<"BiomarkerMeasurement"> | Date | string | null
    status?: EnumMeasurementStatusFilter<"BiomarkerMeasurement"> | $Enums.MeasurementStatus
    source?: EnumBiomarkerSourceFilter<"BiomarkerMeasurement"> | $Enums.BiomarkerSource
    confidence?: DecimalNullableFilter<"BiomarkerMeasurement"> | Decimal | DecimalJsLike | number | string | null
    flags?: JsonNullableFilter<"BiomarkerMeasurement">
    createdAt?: DateTimeFilter<"BiomarkerMeasurement"> | Date | string
    updatedAt?: DateTimeFilter<"BiomarkerMeasurement"> | Date | string
  }

  export type FeedPostUpsertWithWhereUniqueWithoutAuthorInput = {
    where: FeedPostWhereUniqueInput
    update: XOR<FeedPostUpdateWithoutAuthorInput, FeedPostUncheckedUpdateWithoutAuthorInput>
    create: XOR<FeedPostCreateWithoutAuthorInput, FeedPostUncheckedCreateWithoutAuthorInput>
  }

  export type FeedPostUpdateWithWhereUniqueWithoutAuthorInput = {
    where: FeedPostWhereUniqueInput
    data: XOR<FeedPostUpdateWithoutAuthorInput, FeedPostUncheckedUpdateWithoutAuthorInput>
  }

  export type FeedPostUpdateManyWithWhereWithoutAuthorInput = {
    where: FeedPostScalarWhereInput
    data: XOR<FeedPostUpdateManyMutationInput, FeedPostUncheckedUpdateManyWithoutAuthorInput>
  }

  export type FeedPostScalarWhereInput = {
    AND?: FeedPostScalarWhereInput | FeedPostScalarWhereInput[]
    OR?: FeedPostScalarWhereInput[]
    NOT?: FeedPostScalarWhereInput | FeedPostScalarWhereInput[]
    id?: StringFilter<"FeedPost"> | string
    authorId?: StringFilter<"FeedPost"> | string
    body?: StringFilter<"FeedPost"> | string
    tags?: StringNullableListFilter<"FeedPost">
    visibility?: EnumPostVisibilityFilter<"FeedPost"> | $Enums.PostVisibility
    flagged?: BoolFilter<"FeedPost"> | boolean
    reactionSummary?: JsonNullableFilter<"FeedPost">
    commentCount?: IntFilter<"FeedPost"> | number
    createdAt?: DateTimeFilter<"FeedPost"> | Date | string
    updatedAt?: DateTimeFilter<"FeedPost"> | Date | string
  }

  export type CommentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
    create: XOR<CommentCreateWithoutAuthorInput, CommentUncheckedCreateWithoutAuthorInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutAuthorInput, CommentUncheckedUpdateWithoutAuthorInput>
  }

  export type CommentUpdateManyWithWhereWithoutAuthorInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type CommentScalarWhereInput = {
    AND?: CommentScalarWhereInput | CommentScalarWhereInput[]
    OR?: CommentScalarWhereInput[]
    NOT?: CommentScalarWhereInput | CommentScalarWhereInput[]
    id?: StringFilter<"Comment"> | string
    postId?: StringFilter<"Comment"> | string
    authorId?: StringFilter<"Comment"> | string
    body?: StringFilter<"Comment"> | string
    flagged?: BoolFilter<"Comment"> | boolean
    createdAt?: DateTimeFilter<"Comment"> | Date | string
    updatedAt?: DateTimeFilter<"Comment"> | Date | string
  }

  export type ReactionUpsertWithWhereUniqueWithoutUserInput = {
    where: ReactionWhereUniqueInput
    update: XOR<ReactionUpdateWithoutUserInput, ReactionUncheckedUpdateWithoutUserInput>
    create: XOR<ReactionCreateWithoutUserInput, ReactionUncheckedCreateWithoutUserInput>
  }

  export type ReactionUpdateWithWhereUniqueWithoutUserInput = {
    where: ReactionWhereUniqueInput
    data: XOR<ReactionUpdateWithoutUserInput, ReactionUncheckedUpdateWithoutUserInput>
  }

  export type ReactionUpdateManyWithWhereWithoutUserInput = {
    where: ReactionScalarWhereInput
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyWithoutUserInput>
  }

  export type ReactionScalarWhereInput = {
    AND?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
    OR?: ReactionScalarWhereInput[]
    NOT?: ReactionScalarWhereInput | ReactionScalarWhereInput[]
    id?: StringFilter<"Reaction"> | string
    type?: EnumReactionTypeFilter<"Reaction"> | $Enums.ReactionType
    postId?: StringNullableFilter<"Reaction"> | string | null
    commentId?: StringNullableFilter<"Reaction"> | string | null
    userId?: StringFilter<"Reaction"> | string
    createdAt?: DateTimeFilter<"Reaction"> | Date | string
  }

  export type EngagementEventUpsertWithWhereUniqueWithoutUserInput = {
    where: EngagementEventWhereUniqueInput
    update: XOR<EngagementEventUpdateWithoutUserInput, EngagementEventUncheckedUpdateWithoutUserInput>
    create: XOR<EngagementEventCreateWithoutUserInput, EngagementEventUncheckedCreateWithoutUserInput>
  }

  export type EngagementEventUpdateWithWhereUniqueWithoutUserInput = {
    where: EngagementEventWhereUniqueInput
    data: XOR<EngagementEventUpdateWithoutUserInput, EngagementEventUncheckedUpdateWithoutUserInput>
  }

  export type EngagementEventUpdateManyWithWhereWithoutUserInput = {
    where: EngagementEventScalarWhereInput
    data: XOR<EngagementEventUpdateManyMutationInput, EngagementEventUncheckedUpdateManyWithoutUserInput>
  }

  export type EngagementEventScalarWhereInput = {
    AND?: EngagementEventScalarWhereInput | EngagementEventScalarWhereInput[]
    OR?: EngagementEventScalarWhereInput[]
    NOT?: EngagementEventScalarWhereInput | EngagementEventScalarWhereInput[]
    id?: StringFilter<"EngagementEvent"> | string
    type?: EnumEngagementEventTypeFilter<"EngagementEvent"> | $Enums.EngagementEventType
    userId?: StringFilter<"EngagementEvent"> | string
    postId?: StringNullableFilter<"EngagementEvent"> | string | null
    commentId?: StringNullableFilter<"EngagementEvent"> | string | null
    reactionType?: EnumReactionTypeNullableFilter<"EngagementEvent"> | $Enums.ReactionType | null
    occurredAt?: DateTimeFilter<"EngagementEvent"> | Date | string
    metadata?: JsonNullableFilter<"EngagementEvent">
  }

  export type RoomUpsertWithWhereUniqueWithoutHostInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutHostInput, RoomUncheckedUpdateWithoutHostInput>
    create: XOR<RoomCreateWithoutHostInput, RoomUncheckedCreateWithoutHostInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutHostInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutHostInput, RoomUncheckedUpdateWithoutHostInput>
  }

  export type RoomUpdateManyWithWhereWithoutHostInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutHostInput>
  }

  export type RoomScalarWhereInput = {
    AND?: RoomScalarWhereInput | RoomScalarWhereInput[]
    OR?: RoomScalarWhereInput[]
    NOT?: RoomScalarWhereInput | RoomScalarWhereInput[]
    id?: StringFilter<"Room"> | string
    name?: StringNullableFilter<"Room"> | string | null
    inviteCode?: StringFilter<"Room"> | string
    status?: EnumRoomStatusFilter<"Room"> | $Enums.RoomStatus
    capacity?: IntFilter<"Room"> | number
    hostId?: StringFilter<"Room"> | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
  }

  export type RoomMembershipUpsertWithWhereUniqueWithoutUserInput = {
    where: RoomMembershipWhereUniqueInput
    update: XOR<RoomMembershipUpdateWithoutUserInput, RoomMembershipUncheckedUpdateWithoutUserInput>
    create: XOR<RoomMembershipCreateWithoutUserInput, RoomMembershipUncheckedCreateWithoutUserInput>
  }

  export type RoomMembershipUpdateWithWhereUniqueWithoutUserInput = {
    where: RoomMembershipWhereUniqueInput
    data: XOR<RoomMembershipUpdateWithoutUserInput, RoomMembershipUncheckedUpdateWithoutUserInput>
  }

  export type RoomMembershipUpdateManyWithWhereWithoutUserInput = {
    where: RoomMembershipScalarWhereInput
    data: XOR<RoomMembershipUpdateManyMutationInput, RoomMembershipUncheckedUpdateManyWithoutUserInput>
  }

  export type RoomMembershipScalarWhereInput = {
    AND?: RoomMembershipScalarWhereInput | RoomMembershipScalarWhereInput[]
    OR?: RoomMembershipScalarWhereInput[]
    NOT?: RoomMembershipScalarWhereInput | RoomMembershipScalarWhereInput[]
    id?: StringFilter<"RoomMembership"> | string
    roomId?: StringFilter<"RoomMembership"> | string
    userId?: StringFilter<"RoomMembership"> | string
    role?: EnumRoomMembershipRoleFilter<"RoomMembership"> | $Enums.RoomMembershipRole
    status?: EnumRoomMembershipStatusFilter<"RoomMembership"> | $Enums.RoomMembershipStatus
    joinedAt?: DateTimeFilter<"RoomMembership"> | Date | string
    leftAt?: DateTimeNullableFilter<"RoomMembership"> | Date | string | null
    lastSeenAt?: DateTimeNullableFilter<"RoomMembership"> | Date | string | null
    reconnectToken?: StringNullableFilter<"RoomMembership"> | string | null
    createdAt?: DateTimeFilter<"RoomMembership"> | Date | string
    updatedAt?: DateTimeFilter<"RoomMembership"> | Date | string
  }

  export type FlagUpsertWithWhereUniqueWithoutOpenedByInput = {
    where: FlagWhereUniqueInput
    update: XOR<FlagUpdateWithoutOpenedByInput, FlagUncheckedUpdateWithoutOpenedByInput>
    create: XOR<FlagCreateWithoutOpenedByInput, FlagUncheckedCreateWithoutOpenedByInput>
  }

  export type FlagUpdateWithWhereUniqueWithoutOpenedByInput = {
    where: FlagWhereUniqueInput
    data: XOR<FlagUpdateWithoutOpenedByInput, FlagUncheckedUpdateWithoutOpenedByInput>
  }

  export type FlagUpdateManyWithWhereWithoutOpenedByInput = {
    where: FlagScalarWhereInput
    data: XOR<FlagUpdateManyMutationInput, FlagUncheckedUpdateManyWithoutOpenedByInput>
  }

  export type FlagScalarWhereInput = {
    AND?: FlagScalarWhereInput | FlagScalarWhereInput[]
    OR?: FlagScalarWhereInput[]
    NOT?: FlagScalarWhereInput | FlagScalarWhereInput[]
    id?: StringFilter<"Flag"> | string
    targetType?: EnumFlagTargetTypeFilter<"Flag"> | $Enums.FlagTargetType
    status?: EnumFlagStatusFilter<"Flag"> | $Enums.FlagStatus
    reason?: StringFilter<"Flag"> | string
    postId?: StringNullableFilter<"Flag"> | string | null
    commentId?: StringNullableFilter<"Flag"> | string | null
    insightId?: StringNullableFilter<"Flag"> | string | null
    biomarkerLogId?: StringNullableFilter<"Flag"> | string | null
    openedById?: StringFilter<"Flag"> | string
    resolvedById?: StringNullableFilter<"Flag"> | string | null
    resolvedAt?: DateTimeNullableFilter<"Flag"> | Date | string | null
    auditTrail?: JsonNullableFilter<"Flag">
    createdAt?: DateTimeFilter<"Flag"> | Date | string
    updatedAt?: DateTimeFilter<"Flag"> | Date | string
  }

  export type FlagUpsertWithWhereUniqueWithoutResolvedByInput = {
    where: FlagWhereUniqueInput
    update: XOR<FlagUpdateWithoutResolvedByInput, FlagUncheckedUpdateWithoutResolvedByInput>
    create: XOR<FlagCreateWithoutResolvedByInput, FlagUncheckedCreateWithoutResolvedByInput>
  }

  export type FlagUpdateWithWhereUniqueWithoutResolvedByInput = {
    where: FlagWhereUniqueInput
    data: XOR<FlagUpdateWithoutResolvedByInput, FlagUncheckedUpdateWithoutResolvedByInput>
  }

  export type FlagUpdateManyWithWhereWithoutResolvedByInput = {
    where: FlagScalarWhereInput
    data: XOR<FlagUpdateManyMutationInput, FlagUncheckedUpdateManyWithoutResolvedByInput>
  }

  export type AdminAuditLogUpsertWithWhereUniqueWithoutActorInput = {
    where: AdminAuditLogWhereUniqueInput
    update: XOR<AdminAuditLogUpdateWithoutActorInput, AdminAuditLogUncheckedUpdateWithoutActorInput>
    create: XOR<AdminAuditLogCreateWithoutActorInput, AdminAuditLogUncheckedCreateWithoutActorInput>
  }

  export type AdminAuditLogUpdateWithWhereUniqueWithoutActorInput = {
    where: AdminAuditLogWhereUniqueInput
    data: XOR<AdminAuditLogUpdateWithoutActorInput, AdminAuditLogUncheckedUpdateWithoutActorInput>
  }

  export type AdminAuditLogUpdateManyWithWhereWithoutActorInput = {
    where: AdminAuditLogScalarWhereInput
    data: XOR<AdminAuditLogUpdateManyMutationInput, AdminAuditLogUncheckedUpdateManyWithoutActorInput>
  }

  export type AdminAuditLogScalarWhereInput = {
    AND?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
    OR?: AdminAuditLogScalarWhereInput[]
    NOT?: AdminAuditLogScalarWhereInput | AdminAuditLogScalarWhereInput[]
    id?: StringFilter<"AdminAuditLog"> | string
    actorId?: StringFilter<"AdminAuditLog"> | string
    action?: StringFilter<"AdminAuditLog"> | string
    targetType?: StringFilter<"AdminAuditLog"> | string
    targetId?: StringNullableFilter<"AdminAuditLog"> | string | null
    metadata?: JsonNullableFilter<"AdminAuditLog">
    createdAt?: DateTimeFilter<"AdminAuditLog"> | Date | string
  }

  export type LongevityPlanUpsertWithWhereUniqueWithoutUserInput = {
    where: LongevityPlanWhereUniqueInput
    update: XOR<LongevityPlanUpdateWithoutUserInput, LongevityPlanUncheckedUpdateWithoutUserInput>
    create: XOR<LongevityPlanCreateWithoutUserInput, LongevityPlanUncheckedCreateWithoutUserInput>
  }

  export type LongevityPlanUpdateWithWhereUniqueWithoutUserInput = {
    where: LongevityPlanWhereUniqueInput
    data: XOR<LongevityPlanUpdateWithoutUserInput, LongevityPlanUncheckedUpdateWithoutUserInput>
  }

  export type LongevityPlanUpdateManyWithWhereWithoutUserInput = {
    where: LongevityPlanScalarWhereInput
    data: XOR<LongevityPlanUpdateManyMutationInput, LongevityPlanUncheckedUpdateManyWithoutUserInput>
  }

  export type LongevityPlanScalarWhereInput = {
    AND?: LongevityPlanScalarWhereInput | LongevityPlanScalarWhereInput[]
    OR?: LongevityPlanScalarWhereInput[]
    NOT?: LongevityPlanScalarWhereInput | LongevityPlanScalarWhereInput[]
    id?: StringFilter<"LongevityPlan"> | string
    userId?: StringFilter<"LongevityPlan"> | string
    status?: EnumLongevityPlanStatusFilter<"LongevityPlan"> | $Enums.LongevityPlanStatus
    title?: StringFilter<"LongevityPlan"> | string
    summary?: StringNullableFilter<"LongevityPlan"> | string | null
    focusAreas?: StringNullableListFilter<"LongevityPlan">
    sections?: JsonNullableFilter<"LongevityPlan">
    evidence?: JsonNullableFilter<"LongevityPlan">
    safetyState?: JsonNullableFilter<"LongevityPlan">
    validatedBy?: StringNullableFilter<"LongevityPlan"> | string | null
    validatedAt?: DateTimeNullableFilter<"LongevityPlan"> | Date | string | null
    requestedAt?: DateTimeFilter<"LongevityPlan"> | Date | string
    completedAt?: DateTimeNullableFilter<"LongevityPlan"> | Date | string | null
    errorCode?: StringNullableFilter<"LongevityPlan"> | string | null
    errorMessage?: StringNullableFilter<"LongevityPlan"> | string | null
    createdAt?: DateTimeFilter<"LongevityPlan"> | Date | string
    updatedAt?: DateTimeFilter<"LongevityPlan"> | Date | string
  }

  export type LongevityPlanJobUpsertWithWhereUniqueWithoutRequestedByInput = {
    where: LongevityPlanJobWhereUniqueInput
    update: XOR<LongevityPlanJobUpdateWithoutRequestedByInput, LongevityPlanJobUncheckedUpdateWithoutRequestedByInput>
    create: XOR<LongevityPlanJobCreateWithoutRequestedByInput, LongevityPlanJobUncheckedCreateWithoutRequestedByInput>
  }

  export type LongevityPlanJobUpdateWithWhereUniqueWithoutRequestedByInput = {
    where: LongevityPlanJobWhereUniqueInput
    data: XOR<LongevityPlanJobUpdateWithoutRequestedByInput, LongevityPlanJobUncheckedUpdateWithoutRequestedByInput>
  }

  export type LongevityPlanJobUpdateManyWithWhereWithoutRequestedByInput = {
    where: LongevityPlanJobScalarWhereInput
    data: XOR<LongevityPlanJobUpdateManyMutationInput, LongevityPlanJobUncheckedUpdateManyWithoutRequestedByInput>
  }

  export type LongevityPlanJobScalarWhereInput = {
    AND?: LongevityPlanJobScalarWhereInput | LongevityPlanJobScalarWhereInput[]
    OR?: LongevityPlanJobScalarWhereInput[]
    NOT?: LongevityPlanJobScalarWhereInput | LongevityPlanJobScalarWhereInput[]
    id?: StringFilter<"LongevityPlanJob"> | string
    planId?: StringNullableFilter<"LongevityPlanJob"> | string | null
    requestedById?: StringNullableFilter<"LongevityPlanJob"> | string | null
    status?: EnumLongevityPlanJobStatusFilter<"LongevityPlanJob"> | $Enums.LongevityPlanJobStatus
    cloudTaskName?: StringNullableFilter<"LongevityPlanJob"> | string | null
    queue?: StringNullableFilter<"LongevityPlanJob"> | string | null
    payload?: JsonNullableFilter<"LongevityPlanJob">
    scheduledAt?: DateTimeNullableFilter<"LongevityPlanJob"> | Date | string | null
    dispatchedAt?: DateTimeNullableFilter<"LongevityPlanJob"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"LongevityPlanJob"> | Date | string | null
    errorCode?: StringNullableFilter<"LongevityPlanJob"> | string | null
    errorMessage?: StringNullableFilter<"LongevityPlanJob"> | string | null
    createdAt?: DateTimeFilter<"LongevityPlanJob"> | Date | string
    updatedAt?: DateTimeFilter<"LongevityPlanJob"> | Date | string
  }

  export type AiResponseAuditUpsertWithWhereUniqueWithoutUserInput = {
    where: AiResponseAuditWhereUniqueInput
    update: XOR<AiResponseAuditUpdateWithoutUserInput, AiResponseAuditUncheckedUpdateWithoutUserInput>
    create: XOR<AiResponseAuditCreateWithoutUserInput, AiResponseAuditUncheckedCreateWithoutUserInput>
  }

  export type AiResponseAuditUpdateWithWhereUniqueWithoutUserInput = {
    where: AiResponseAuditWhereUniqueInput
    data: XOR<AiResponseAuditUpdateWithoutUserInput, AiResponseAuditUncheckedUpdateWithoutUserInput>
  }

  export type AiResponseAuditUpdateManyWithWhereWithoutUserInput = {
    where: AiResponseAuditScalarWhereInput
    data: XOR<AiResponseAuditUpdateManyMutationInput, AiResponseAuditUncheckedUpdateManyWithoutUserInput>
  }

  export type AiResponseAuditScalarWhereInput = {
    AND?: AiResponseAuditScalarWhereInput | AiResponseAuditScalarWhereInput[]
    OR?: AiResponseAuditScalarWhereInput[]
    NOT?: AiResponseAuditScalarWhereInput | AiResponseAuditScalarWhereInput[]
    id?: StringFilter<"AiResponseAudit"> | string
    planId?: StringNullableFilter<"AiResponseAudit"> | string | null
    userId?: StringNullableFilter<"AiResponseAudit"> | string | null
    provider?: StringFilter<"AiResponseAudit"> | string
    model?: StringNullableFilter<"AiResponseAudit"> | string | null
    role?: StringNullableFilter<"AiResponseAudit"> | string | null
    prompt?: JsonNullableFilter<"AiResponseAudit">
    response?: JsonNullableFilter<"AiResponseAudit">
    createdAt?: DateTimeFilter<"AiResponseAudit"> | Date | string
  }

  export type LoginAuditUpsertWithWhereUniqueWithoutUserInput = {
    where: LoginAuditWhereUniqueInput
    update: XOR<LoginAuditUpdateWithoutUserInput, LoginAuditUncheckedUpdateWithoutUserInput>
    create: XOR<LoginAuditCreateWithoutUserInput, LoginAuditUncheckedCreateWithoutUserInput>
  }

  export type LoginAuditUpdateWithWhereUniqueWithoutUserInput = {
    where: LoginAuditWhereUniqueInput
    data: XOR<LoginAuditUpdateWithoutUserInput, LoginAuditUncheckedUpdateWithoutUserInput>
  }

  export type LoginAuditUpdateManyWithWhereWithoutUserInput = {
    where: LoginAuditScalarWhereInput
    data: XOR<LoginAuditUpdateManyMutationInput, LoginAuditUncheckedUpdateManyWithoutUserInput>
  }

  export type LoginAuditScalarWhereInput = {
    AND?: LoginAuditScalarWhereInput | LoginAuditScalarWhereInput[]
    OR?: LoginAuditScalarWhereInput[]
    NOT?: LoginAuditScalarWhereInput | LoginAuditScalarWhereInput[]
    id?: StringFilter<"LoginAudit"> | string
    userId?: StringNullableFilter<"LoginAudit"> | string | null
    email?: StringFilter<"LoginAudit"> | string
    provider?: EnumAuthProviderTypeFilter<"LoginAudit"> | $Enums.AuthProviderType
    success?: BoolFilter<"LoginAudit"> | boolean
    ipAddress?: StringNullableFilter<"LoginAudit"> | string | null
    userAgent?: StringNullableFilter<"LoginAudit"> | string | null
    failureReason?: StringNullableFilter<"LoginAudit"> | string | null
    createdAt?: DateTimeFilter<"LoginAudit"> | Date | string
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutInsightsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInsightsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInsightsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInsightsInput, UserUncheckedCreateWithoutInsightsInput>
  }

  export type InsightActionCreateWithoutInsightInput = {
    id?: string
    actionType: $Enums.InsightActionType
    notes?: string | null
    createdAt?: Date | string
    actor?: UserCreateNestedOneWithoutInsightActionsInput
  }

  export type InsightActionUncheckedCreateWithoutInsightInput = {
    id?: string
    actorId?: string | null
    actionType: $Enums.InsightActionType
    notes?: string | null
    createdAt?: Date | string
  }

  export type InsightActionCreateOrConnectWithoutInsightInput = {
    where: InsightActionWhereUniqueInput
    create: XOR<InsightActionCreateWithoutInsightInput, InsightActionUncheckedCreateWithoutInsightInput>
  }

  export type InsightActionCreateManyInsightInputEnvelope = {
    data: InsightActionCreateManyInsightInput | InsightActionCreateManyInsightInput[]
    skipDuplicates?: boolean
  }

  export type InsightGenerationJobCreateWithoutInsightInput = {
    id?: string
    status: $Enums.InsightGenerationStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requestedBy?: UserCreateNestedOneWithoutInsightGenerationJobsInput
    cloudTask?: CloudTaskMetadataCreateNestedOneWithoutJobInput
  }

  export type InsightGenerationJobUncheckedCreateWithoutInsightInput = {
    id?: string
    requestedById?: string | null
    status: $Enums.InsightGenerationStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cloudTask?: CloudTaskMetadataUncheckedCreateNestedOneWithoutJobInput
  }

  export type InsightGenerationJobCreateOrConnectWithoutInsightInput = {
    where: InsightGenerationJobWhereUniqueInput
    create: XOR<InsightGenerationJobCreateWithoutInsightInput, InsightGenerationJobUncheckedCreateWithoutInsightInput>
  }

  export type InsightGenerationJobCreateManyInsightInputEnvelope = {
    data: InsightGenerationJobCreateManyInsightInput | InsightGenerationJobCreateManyInsightInput[]
    skipDuplicates?: boolean
  }

  export type FlagCreateWithoutInsightInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: FeedPostCreateNestedOneWithoutFlagsInput
    comment?: CommentCreateNestedOneWithoutFlagsInput
    biomarkerLog?: BiomarkerLogCreateNestedOneWithoutFlagsInput
    openedBy: UserCreateNestedOneWithoutFlagsOpenedInput
    resolvedBy?: UserCreateNestedOneWithoutFlagsResolvedInput
  }

  export type FlagUncheckedCreateWithoutInsightInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    postId?: string | null
    commentId?: string | null
    biomarkerLogId?: string | null
    openedById: string
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlagCreateOrConnectWithoutInsightInput = {
    where: FlagWhereUniqueInput
    create: XOR<FlagCreateWithoutInsightInput, FlagUncheckedCreateWithoutInsightInput>
  }

  export type FlagCreateManyInsightInputEnvelope = {
    data: FlagCreateManyInsightInput | FlagCreateManyInsightInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutInsightsInput = {
    update: XOR<UserUpdateWithoutInsightsInput, UserUncheckedUpdateWithoutInsightsInput>
    create: XOR<UserCreateWithoutInsightsInput, UserUncheckedCreateWithoutInsightsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInsightsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInsightsInput, UserUncheckedUpdateWithoutInsightsInput>
  }

  export type UserUpdateWithoutInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInsightsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InsightActionUpsertWithWhereUniqueWithoutInsightInput = {
    where: InsightActionWhereUniqueInput
    update: XOR<InsightActionUpdateWithoutInsightInput, InsightActionUncheckedUpdateWithoutInsightInput>
    create: XOR<InsightActionCreateWithoutInsightInput, InsightActionUncheckedCreateWithoutInsightInput>
  }

  export type InsightActionUpdateWithWhereUniqueWithoutInsightInput = {
    where: InsightActionWhereUniqueInput
    data: XOR<InsightActionUpdateWithoutInsightInput, InsightActionUncheckedUpdateWithoutInsightInput>
  }

  export type InsightActionUpdateManyWithWhereWithoutInsightInput = {
    where: InsightActionScalarWhereInput
    data: XOR<InsightActionUpdateManyMutationInput, InsightActionUncheckedUpdateManyWithoutInsightInput>
  }

  export type InsightGenerationJobUpsertWithWhereUniqueWithoutInsightInput = {
    where: InsightGenerationJobWhereUniqueInput
    update: XOR<InsightGenerationJobUpdateWithoutInsightInput, InsightGenerationJobUncheckedUpdateWithoutInsightInput>
    create: XOR<InsightGenerationJobCreateWithoutInsightInput, InsightGenerationJobUncheckedCreateWithoutInsightInput>
  }

  export type InsightGenerationJobUpdateWithWhereUniqueWithoutInsightInput = {
    where: InsightGenerationJobWhereUniqueInput
    data: XOR<InsightGenerationJobUpdateWithoutInsightInput, InsightGenerationJobUncheckedUpdateWithoutInsightInput>
  }

  export type InsightGenerationJobUpdateManyWithWhereWithoutInsightInput = {
    where: InsightGenerationJobScalarWhereInput
    data: XOR<InsightGenerationJobUpdateManyMutationInput, InsightGenerationJobUncheckedUpdateManyWithoutInsightInput>
  }

  export type FlagUpsertWithWhereUniqueWithoutInsightInput = {
    where: FlagWhereUniqueInput
    update: XOR<FlagUpdateWithoutInsightInput, FlagUncheckedUpdateWithoutInsightInput>
    create: XOR<FlagCreateWithoutInsightInput, FlagUncheckedCreateWithoutInsightInput>
  }

  export type FlagUpdateWithWhereUniqueWithoutInsightInput = {
    where: FlagWhereUniqueInput
    data: XOR<FlagUpdateWithoutInsightInput, FlagUncheckedUpdateWithoutInsightInput>
  }

  export type FlagUpdateManyWithWhereWithoutInsightInput = {
    where: FlagScalarWhereInput
    data: XOR<FlagUpdateManyMutationInput, FlagUncheckedUpdateManyWithoutInsightInput>
  }

  export type UserCreateWithoutLongevityPlansInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLongevityPlansInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLongevityPlansInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLongevityPlansInput, UserUncheckedCreateWithoutLongevityPlansInput>
  }

  export type LongevityPlanJobCreateWithoutPlanInput = {
    id?: string
    status?: $Enums.LongevityPlanJobStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    requestedBy?: UserCreateNestedOneWithoutLongevityPlanJobsInput
    cloudTask?: CloudTaskMetadataCreateNestedOneWithoutPlanJobInput
  }

  export type LongevityPlanJobUncheckedCreateWithoutPlanInput = {
    id?: string
    requestedById?: string | null
    status?: $Enums.LongevityPlanJobStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    cloudTask?: CloudTaskMetadataUncheckedCreateNestedOneWithoutPlanJobInput
  }

  export type LongevityPlanJobCreateOrConnectWithoutPlanInput = {
    where: LongevityPlanJobWhereUniqueInput
    create: XOR<LongevityPlanJobCreateWithoutPlanInput, LongevityPlanJobUncheckedCreateWithoutPlanInput>
  }

  export type LongevityPlanJobCreateManyPlanInputEnvelope = {
    data: LongevityPlanJobCreateManyPlanInput | LongevityPlanJobCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type AiResponseAuditCreateWithoutPlanInput = {
    id?: string
    provider: string
    model?: string | null
    role?: string | null
    prompt?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAiResponseAuditsInput
  }

  export type AiResponseAuditUncheckedCreateWithoutPlanInput = {
    id?: string
    userId?: string | null
    provider: string
    model?: string | null
    role?: string | null
    prompt?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AiResponseAuditCreateOrConnectWithoutPlanInput = {
    where: AiResponseAuditWhereUniqueInput
    create: XOR<AiResponseAuditCreateWithoutPlanInput, AiResponseAuditUncheckedCreateWithoutPlanInput>
  }

  export type AiResponseAuditCreateManyPlanInputEnvelope = {
    data: AiResponseAuditCreateManyPlanInput | AiResponseAuditCreateManyPlanInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLongevityPlansInput = {
    update: XOR<UserUpdateWithoutLongevityPlansInput, UserUncheckedUpdateWithoutLongevityPlansInput>
    create: XOR<UserCreateWithoutLongevityPlansInput, UserUncheckedCreateWithoutLongevityPlansInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLongevityPlansInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLongevityPlansInput, UserUncheckedUpdateWithoutLongevityPlansInput>
  }

  export type UserUpdateWithoutLongevityPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLongevityPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LongevityPlanJobUpsertWithWhereUniqueWithoutPlanInput = {
    where: LongevityPlanJobWhereUniqueInput
    update: XOR<LongevityPlanJobUpdateWithoutPlanInput, LongevityPlanJobUncheckedUpdateWithoutPlanInput>
    create: XOR<LongevityPlanJobCreateWithoutPlanInput, LongevityPlanJobUncheckedCreateWithoutPlanInput>
  }

  export type LongevityPlanJobUpdateWithWhereUniqueWithoutPlanInput = {
    where: LongevityPlanJobWhereUniqueInput
    data: XOR<LongevityPlanJobUpdateWithoutPlanInput, LongevityPlanJobUncheckedUpdateWithoutPlanInput>
  }

  export type LongevityPlanJobUpdateManyWithWhereWithoutPlanInput = {
    where: LongevityPlanJobScalarWhereInput
    data: XOR<LongevityPlanJobUpdateManyMutationInput, LongevityPlanJobUncheckedUpdateManyWithoutPlanInput>
  }

  export type AiResponseAuditUpsertWithWhereUniqueWithoutPlanInput = {
    where: AiResponseAuditWhereUniqueInput
    update: XOR<AiResponseAuditUpdateWithoutPlanInput, AiResponseAuditUncheckedUpdateWithoutPlanInput>
    create: XOR<AiResponseAuditCreateWithoutPlanInput, AiResponseAuditUncheckedCreateWithoutPlanInput>
  }

  export type AiResponseAuditUpdateWithWhereUniqueWithoutPlanInput = {
    where: AiResponseAuditWhereUniqueInput
    data: XOR<AiResponseAuditUpdateWithoutPlanInput, AiResponseAuditUncheckedUpdateWithoutPlanInput>
  }

  export type AiResponseAuditUpdateManyWithWhereWithoutPlanInput = {
    where: AiResponseAuditScalarWhereInput
    data: XOR<AiResponseAuditUpdateManyMutationInput, AiResponseAuditUncheckedUpdateManyWithoutPlanInput>
  }

  export type BiomarkerLogCreateWithoutBiomarkerInput = {
    id?: string
    value: Decimal | DecimalJsLike | number | string
    unit?: string | null
    source?: $Enums.BiomarkerSource
    capturedAt: Date | string
    accepted?: boolean
    flagged?: boolean
    notes?: string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBiomarkerLogsInput
    flags?: FlagCreateNestedManyWithoutBiomarkerLogInput
  }

  export type BiomarkerLogUncheckedCreateWithoutBiomarkerInput = {
    id?: string
    userId: string
    value: Decimal | DecimalJsLike | number | string
    unit?: string | null
    source?: $Enums.BiomarkerSource
    capturedAt: Date | string
    accepted?: boolean
    flagged?: boolean
    notes?: string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    flags?: FlagUncheckedCreateNestedManyWithoutBiomarkerLogInput
  }

  export type BiomarkerLogCreateOrConnectWithoutBiomarkerInput = {
    where: BiomarkerLogWhereUniqueInput
    create: XOR<BiomarkerLogCreateWithoutBiomarkerInput, BiomarkerLogUncheckedCreateWithoutBiomarkerInput>
  }

  export type BiomarkerLogCreateManyBiomarkerInputEnvelope = {
    data: BiomarkerLogCreateManyBiomarkerInput | BiomarkerLogCreateManyBiomarkerInput[]
    skipDuplicates?: boolean
  }

  export type BiomarkerMeasurementCreateWithoutBiomarkerInput = {
    id?: string
    markerName: string
    value?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    capturedAt?: Date | string | null
    status?: $Enums.MeasurementStatus
    source?: $Enums.BiomarkerSource
    confidence?: Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBiomarkerMeasurementsInput
    panelUpload?: PanelUploadCreateNestedOneWithoutMeasurementsInput
  }

  export type BiomarkerMeasurementUncheckedCreateWithoutBiomarkerInput = {
    id?: string
    userId: string
    panelUploadId?: string | null
    markerName: string
    value?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    capturedAt?: Date | string | null
    status?: $Enums.MeasurementStatus
    source?: $Enums.BiomarkerSource
    confidence?: Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiomarkerMeasurementCreateOrConnectWithoutBiomarkerInput = {
    where: BiomarkerMeasurementWhereUniqueInput
    create: XOR<BiomarkerMeasurementCreateWithoutBiomarkerInput, BiomarkerMeasurementUncheckedCreateWithoutBiomarkerInput>
  }

  export type BiomarkerMeasurementCreateManyBiomarkerInputEnvelope = {
    data: BiomarkerMeasurementCreateManyBiomarkerInput | BiomarkerMeasurementCreateManyBiomarkerInput[]
    skipDuplicates?: boolean
  }

  export type BiomarkerLogUpsertWithWhereUniqueWithoutBiomarkerInput = {
    where: BiomarkerLogWhereUniqueInput
    update: XOR<BiomarkerLogUpdateWithoutBiomarkerInput, BiomarkerLogUncheckedUpdateWithoutBiomarkerInput>
    create: XOR<BiomarkerLogCreateWithoutBiomarkerInput, BiomarkerLogUncheckedCreateWithoutBiomarkerInput>
  }

  export type BiomarkerLogUpdateWithWhereUniqueWithoutBiomarkerInput = {
    where: BiomarkerLogWhereUniqueInput
    data: XOR<BiomarkerLogUpdateWithoutBiomarkerInput, BiomarkerLogUncheckedUpdateWithoutBiomarkerInput>
  }

  export type BiomarkerLogUpdateManyWithWhereWithoutBiomarkerInput = {
    where: BiomarkerLogScalarWhereInput
    data: XOR<BiomarkerLogUpdateManyMutationInput, BiomarkerLogUncheckedUpdateManyWithoutBiomarkerInput>
  }

  export type BiomarkerMeasurementUpsertWithWhereUniqueWithoutBiomarkerInput = {
    where: BiomarkerMeasurementWhereUniqueInput
    update: XOR<BiomarkerMeasurementUpdateWithoutBiomarkerInput, BiomarkerMeasurementUncheckedUpdateWithoutBiomarkerInput>
    create: XOR<BiomarkerMeasurementCreateWithoutBiomarkerInput, BiomarkerMeasurementUncheckedCreateWithoutBiomarkerInput>
  }

  export type BiomarkerMeasurementUpdateWithWhereUniqueWithoutBiomarkerInput = {
    where: BiomarkerMeasurementWhereUniqueInput
    data: XOR<BiomarkerMeasurementUpdateWithoutBiomarkerInput, BiomarkerMeasurementUncheckedUpdateWithoutBiomarkerInput>
  }

  export type BiomarkerMeasurementUpdateManyWithWhereWithoutBiomarkerInput = {
    where: BiomarkerMeasurementScalarWhereInput
    data: XOR<BiomarkerMeasurementUpdateManyMutationInput, BiomarkerMeasurementUncheckedUpdateManyWithoutBiomarkerInput>
  }

  export type UserCreateWithoutBiomarkerLogsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBiomarkerLogsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBiomarkerLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBiomarkerLogsInput, UserUncheckedCreateWithoutBiomarkerLogsInput>
  }

  export type BiomarkerCreateWithoutLogsInput = {
    id?: string
    slug: string
    name: string
    unit: string
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    source: $Enums.BiomarkerSource
    createdAt?: Date | string
    updatedAt?: Date | string
    measurements?: BiomarkerMeasurementCreateNestedManyWithoutBiomarkerInput
  }

  export type BiomarkerUncheckedCreateWithoutLogsInput = {
    id?: string
    slug: string
    name: string
    unit: string
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    source: $Enums.BiomarkerSource
    createdAt?: Date | string
    updatedAt?: Date | string
    measurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutBiomarkerInput
  }

  export type BiomarkerCreateOrConnectWithoutLogsInput = {
    where: BiomarkerWhereUniqueInput
    create: XOR<BiomarkerCreateWithoutLogsInput, BiomarkerUncheckedCreateWithoutLogsInput>
  }

  export type FlagCreateWithoutBiomarkerLogInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: FeedPostCreateNestedOneWithoutFlagsInput
    comment?: CommentCreateNestedOneWithoutFlagsInput
    insight?: InsightCreateNestedOneWithoutFlagsInput
    openedBy: UserCreateNestedOneWithoutFlagsOpenedInput
    resolvedBy?: UserCreateNestedOneWithoutFlagsResolvedInput
  }

  export type FlagUncheckedCreateWithoutBiomarkerLogInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    postId?: string | null
    commentId?: string | null
    insightId?: string | null
    openedById: string
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlagCreateOrConnectWithoutBiomarkerLogInput = {
    where: FlagWhereUniqueInput
    create: XOR<FlagCreateWithoutBiomarkerLogInput, FlagUncheckedCreateWithoutBiomarkerLogInput>
  }

  export type FlagCreateManyBiomarkerLogInputEnvelope = {
    data: FlagCreateManyBiomarkerLogInput | FlagCreateManyBiomarkerLogInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutBiomarkerLogsInput = {
    update: XOR<UserUpdateWithoutBiomarkerLogsInput, UserUncheckedUpdateWithoutBiomarkerLogsInput>
    create: XOR<UserCreateWithoutBiomarkerLogsInput, UserUncheckedCreateWithoutBiomarkerLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBiomarkerLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBiomarkerLogsInput, UserUncheckedUpdateWithoutBiomarkerLogsInput>
  }

  export type UserUpdateWithoutBiomarkerLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBiomarkerLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BiomarkerUpsertWithoutLogsInput = {
    update: XOR<BiomarkerUpdateWithoutLogsInput, BiomarkerUncheckedUpdateWithoutLogsInput>
    create: XOR<BiomarkerCreateWithoutLogsInput, BiomarkerUncheckedCreateWithoutLogsInput>
    where?: BiomarkerWhereInput
  }

  export type BiomarkerUpdateToOneWithWhereWithoutLogsInput = {
    where?: BiomarkerWhereInput
    data: XOR<BiomarkerUpdateWithoutLogsInput, BiomarkerUncheckedUpdateWithoutLogsInput>
  }

  export type BiomarkerUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    measurements?: BiomarkerMeasurementUpdateManyWithoutBiomarkerNestedInput
  }

  export type BiomarkerUncheckedUpdateWithoutLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    measurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutBiomarkerNestedInput
  }

  export type FlagUpsertWithWhereUniqueWithoutBiomarkerLogInput = {
    where: FlagWhereUniqueInput
    update: XOR<FlagUpdateWithoutBiomarkerLogInput, FlagUncheckedUpdateWithoutBiomarkerLogInput>
    create: XOR<FlagCreateWithoutBiomarkerLogInput, FlagUncheckedCreateWithoutBiomarkerLogInput>
  }

  export type FlagUpdateWithWhereUniqueWithoutBiomarkerLogInput = {
    where: FlagWhereUniqueInput
    data: XOR<FlagUpdateWithoutBiomarkerLogInput, FlagUncheckedUpdateWithoutBiomarkerLogInput>
  }

  export type FlagUpdateManyWithWhereWithoutBiomarkerLogInput = {
    where: FlagScalarWhereInput
    data: XOR<FlagUpdateManyMutationInput, FlagUncheckedUpdateManyWithoutBiomarkerLogInput>
  }

  export type UserCreateWithoutPanelUploadsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPanelUploadsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPanelUploadsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPanelUploadsInput, UserUncheckedCreateWithoutPanelUploadsInput>
  }

  export type BiomarkerMeasurementCreateWithoutPanelUploadInput = {
    id?: string
    markerName: string
    value?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    capturedAt?: Date | string | null
    status?: $Enums.MeasurementStatus
    source?: $Enums.BiomarkerSource
    confidence?: Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBiomarkerMeasurementsInput
    biomarker?: BiomarkerCreateNestedOneWithoutMeasurementsInput
  }

  export type BiomarkerMeasurementUncheckedCreateWithoutPanelUploadInput = {
    id?: string
    userId: string
    biomarkerId?: string | null
    markerName: string
    value?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    capturedAt?: Date | string | null
    status?: $Enums.MeasurementStatus
    source?: $Enums.BiomarkerSource
    confidence?: Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiomarkerMeasurementCreateOrConnectWithoutPanelUploadInput = {
    where: BiomarkerMeasurementWhereUniqueInput
    create: XOR<BiomarkerMeasurementCreateWithoutPanelUploadInput, BiomarkerMeasurementUncheckedCreateWithoutPanelUploadInput>
  }

  export type BiomarkerMeasurementCreateManyPanelUploadInputEnvelope = {
    data: BiomarkerMeasurementCreateManyPanelUploadInput | BiomarkerMeasurementCreateManyPanelUploadInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPanelUploadsInput = {
    update: XOR<UserUpdateWithoutPanelUploadsInput, UserUncheckedUpdateWithoutPanelUploadsInput>
    create: XOR<UserCreateWithoutPanelUploadsInput, UserUncheckedCreateWithoutPanelUploadsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPanelUploadsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPanelUploadsInput, UserUncheckedUpdateWithoutPanelUploadsInput>
  }

  export type UserUpdateWithoutPanelUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPanelUploadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BiomarkerMeasurementUpsertWithWhereUniqueWithoutPanelUploadInput = {
    where: BiomarkerMeasurementWhereUniqueInput
    update: XOR<BiomarkerMeasurementUpdateWithoutPanelUploadInput, BiomarkerMeasurementUncheckedUpdateWithoutPanelUploadInput>
    create: XOR<BiomarkerMeasurementCreateWithoutPanelUploadInput, BiomarkerMeasurementUncheckedCreateWithoutPanelUploadInput>
  }

  export type BiomarkerMeasurementUpdateWithWhereUniqueWithoutPanelUploadInput = {
    where: BiomarkerMeasurementWhereUniqueInput
    data: XOR<BiomarkerMeasurementUpdateWithoutPanelUploadInput, BiomarkerMeasurementUncheckedUpdateWithoutPanelUploadInput>
  }

  export type BiomarkerMeasurementUpdateManyWithWhereWithoutPanelUploadInput = {
    where: BiomarkerMeasurementScalarWhereInput
    data: XOR<BiomarkerMeasurementUpdateManyMutationInput, BiomarkerMeasurementUncheckedUpdateManyWithoutPanelUploadInput>
  }

  export type UserCreateWithoutBiomarkerMeasurementsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutBiomarkerMeasurementsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutBiomarkerMeasurementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBiomarkerMeasurementsInput, UserUncheckedCreateWithoutBiomarkerMeasurementsInput>
  }

  export type BiomarkerCreateWithoutMeasurementsInput = {
    id?: string
    slug: string
    name: string
    unit: string
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    source: $Enums.BiomarkerSource
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: BiomarkerLogCreateNestedManyWithoutBiomarkerInput
  }

  export type BiomarkerUncheckedCreateWithoutMeasurementsInput = {
    id?: string
    slug: string
    name: string
    unit: string
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    source: $Enums.BiomarkerSource
    createdAt?: Date | string
    updatedAt?: Date | string
    logs?: BiomarkerLogUncheckedCreateNestedManyWithoutBiomarkerInput
  }

  export type BiomarkerCreateOrConnectWithoutMeasurementsInput = {
    where: BiomarkerWhereUniqueInput
    create: XOR<BiomarkerCreateWithoutMeasurementsInput, BiomarkerUncheckedCreateWithoutMeasurementsInput>
  }

  export type PanelUploadCreateWithoutMeasurementsInput = {
    id?: string
    status?: $Enums.PanelUploadStatus
    source?: $Enums.PanelUploadSource
    storageKey: string
    contentType?: string | null
    pageCount?: number | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    normalizedPayload?: NullableJsonNullValueInput | InputJsonValue
    measurementCount?: number
    processedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPanelUploadsInput
  }

  export type PanelUploadUncheckedCreateWithoutMeasurementsInput = {
    id?: string
    userId: string
    status?: $Enums.PanelUploadStatus
    source?: $Enums.PanelUploadSource
    storageKey: string
    contentType?: string | null
    pageCount?: number | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    normalizedPayload?: NullableJsonNullValueInput | InputJsonValue
    measurementCount?: number
    processedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PanelUploadCreateOrConnectWithoutMeasurementsInput = {
    where: PanelUploadWhereUniqueInput
    create: XOR<PanelUploadCreateWithoutMeasurementsInput, PanelUploadUncheckedCreateWithoutMeasurementsInput>
  }

  export type UserUpsertWithoutBiomarkerMeasurementsInput = {
    update: XOR<UserUpdateWithoutBiomarkerMeasurementsInput, UserUncheckedUpdateWithoutBiomarkerMeasurementsInput>
    create: XOR<UserCreateWithoutBiomarkerMeasurementsInput, UserUncheckedCreateWithoutBiomarkerMeasurementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBiomarkerMeasurementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBiomarkerMeasurementsInput, UserUncheckedUpdateWithoutBiomarkerMeasurementsInput>
  }

  export type UserUpdateWithoutBiomarkerMeasurementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutBiomarkerMeasurementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BiomarkerUpsertWithoutMeasurementsInput = {
    update: XOR<BiomarkerUpdateWithoutMeasurementsInput, BiomarkerUncheckedUpdateWithoutMeasurementsInput>
    create: XOR<BiomarkerCreateWithoutMeasurementsInput, BiomarkerUncheckedCreateWithoutMeasurementsInput>
    where?: BiomarkerWhereInput
  }

  export type BiomarkerUpdateToOneWithWhereWithoutMeasurementsInput = {
    where?: BiomarkerWhereInput
    data: XOR<BiomarkerUpdateWithoutMeasurementsInput, BiomarkerUncheckedUpdateWithoutMeasurementsInput>
  }

  export type BiomarkerUpdateWithoutMeasurementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: BiomarkerLogUpdateManyWithoutBiomarkerNestedInput
  }

  export type BiomarkerUncheckedUpdateWithoutMeasurementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    logs?: BiomarkerLogUncheckedUpdateManyWithoutBiomarkerNestedInput
  }

  export type PanelUploadUpsertWithoutMeasurementsInput = {
    update: XOR<PanelUploadUpdateWithoutMeasurementsInput, PanelUploadUncheckedUpdateWithoutMeasurementsInput>
    create: XOR<PanelUploadCreateWithoutMeasurementsInput, PanelUploadUncheckedCreateWithoutMeasurementsInput>
    where?: PanelUploadWhereInput
  }

  export type PanelUploadUpdateToOneWithWhereWithoutMeasurementsInput = {
    where?: PanelUploadWhereInput
    data: XOR<PanelUploadUpdateWithoutMeasurementsInput, PanelUploadUncheckedUpdateWithoutMeasurementsInput>
  }

  export type PanelUploadUpdateWithoutMeasurementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPanelUploadStatusFieldUpdateOperationsInput | $Enums.PanelUploadStatus
    source?: EnumPanelUploadSourceFieldUpdateOperationsInput | $Enums.PanelUploadSource
    storageKey?: StringFieldUpdateOperationsInput | string
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    normalizedPayload?: NullableJsonNullValueInput | InputJsonValue
    measurementCount?: IntFieldUpdateOperationsInput | number
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPanelUploadsNestedInput
  }

  export type PanelUploadUncheckedUpdateWithoutMeasurementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumPanelUploadStatusFieldUpdateOperationsInput | $Enums.PanelUploadStatus
    source?: EnumPanelUploadSourceFieldUpdateOperationsInput | $Enums.PanelUploadSource
    storageKey?: StringFieldUpdateOperationsInput | string
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    normalizedPayload?: NullableJsonNullValueInput | InputJsonValue
    measurementCount?: IntFieldUpdateOperationsInput | number
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutAuthProvidersInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuthProvidersInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuthProvidersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuthProvidersInput, UserUncheckedCreateWithoutAuthProvidersInput>
  }

  export type UserUpsertWithoutAuthProvidersInput = {
    update: XOR<UserUpdateWithoutAuthProvidersInput, UserUncheckedUpdateWithoutAuthProvidersInput>
    create: XOR<UserCreateWithoutAuthProvidersInput, UserUncheckedCreateWithoutAuthProvidersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuthProvidersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuthProvidersInput, UserUncheckedUpdateWithoutAuthProvidersInput>
  }

  export type UserUpdateWithoutAuthProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuthProvidersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLoginAuditsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLoginAuditsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLoginAuditsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLoginAuditsInput, UserUncheckedCreateWithoutLoginAuditsInput>
  }

  export type UserUpsertWithoutLoginAuditsInput = {
    update: XOR<UserUpdateWithoutLoginAuditsInput, UserUncheckedUpdateWithoutLoginAuditsInput>
    create: XOR<UserCreateWithoutLoginAuditsInput, UserUncheckedCreateWithoutLoginAuditsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLoginAuditsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLoginAuditsInput, UserUncheckedUpdateWithoutLoginAuditsInput>
  }

  export type UserUpdateWithoutLoginAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLoginAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InsightCreateWithoutActionsInput = {
    id?: string
    title: string
    summary: string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InsightStatus
    generatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInsightsInput
    generationJobs?: InsightGenerationJobCreateNestedManyWithoutInsightInput
    flags?: FlagCreateNestedManyWithoutInsightInput
  }

  export type InsightUncheckedCreateWithoutActionsInput = {
    id?: string
    userId: string
    title: string
    summary: string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InsightStatus
    generatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    generationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutInsightInput
    flags?: FlagUncheckedCreateNestedManyWithoutInsightInput
  }

  export type InsightCreateOrConnectWithoutActionsInput = {
    where: InsightWhereUniqueInput
    create: XOR<InsightCreateWithoutActionsInput, InsightUncheckedCreateWithoutActionsInput>
  }

  export type UserCreateWithoutInsightActionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInsightActionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInsightActionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInsightActionsInput, UserUncheckedCreateWithoutInsightActionsInput>
  }

  export type InsightUpsertWithoutActionsInput = {
    update: XOR<InsightUpdateWithoutActionsInput, InsightUncheckedUpdateWithoutActionsInput>
    create: XOR<InsightCreateWithoutActionsInput, InsightUncheckedCreateWithoutActionsInput>
    where?: InsightWhereInput
  }

  export type InsightUpdateToOneWithWhereWithoutActionsInput = {
    where?: InsightWhereInput
    data: XOR<InsightUpdateWithoutActionsInput, InsightUncheckedUpdateWithoutActionsInput>
  }

  export type InsightUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInsightsNestedInput
    generationJobs?: InsightGenerationJobUpdateManyWithoutInsightNestedInput
    flags?: FlagUpdateManyWithoutInsightNestedInput
  }

  export type InsightUncheckedUpdateWithoutActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    generationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutInsightNestedInput
    flags?: FlagUncheckedUpdateManyWithoutInsightNestedInput
  }

  export type UserUpsertWithoutInsightActionsInput = {
    update: XOR<UserUpdateWithoutInsightActionsInput, UserUncheckedUpdateWithoutInsightActionsInput>
    create: XOR<UserCreateWithoutInsightActionsInput, UserUncheckedCreateWithoutInsightActionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInsightActionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInsightActionsInput, UserUncheckedUpdateWithoutInsightActionsInput>
  }

  export type UserUpdateWithoutInsightActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInsightActionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type InsightCreateWithoutGenerationJobsInput = {
    id?: string
    title: string
    summary: string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InsightStatus
    generatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInsightsInput
    actions?: InsightActionCreateNestedManyWithoutInsightInput
    flags?: FlagCreateNestedManyWithoutInsightInput
  }

  export type InsightUncheckedCreateWithoutGenerationJobsInput = {
    id?: string
    userId: string
    title: string
    summary: string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InsightStatus
    generatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: InsightActionUncheckedCreateNestedManyWithoutInsightInput
    flags?: FlagUncheckedCreateNestedManyWithoutInsightInput
  }

  export type InsightCreateOrConnectWithoutGenerationJobsInput = {
    where: InsightWhereUniqueInput
    create: XOR<InsightCreateWithoutGenerationJobsInput, InsightUncheckedCreateWithoutGenerationJobsInput>
  }

  export type UserCreateWithoutInsightGenerationJobsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInsightGenerationJobsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInsightGenerationJobsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInsightGenerationJobsInput, UserUncheckedCreateWithoutInsightGenerationJobsInput>
  }

  export type CloudTaskMetadataCreateWithoutJobInput = {
    id?: string
    taskName: string
    queue: string
    status?: $Enums.CloudTaskStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduleTime?: Date | string | null
    firstAttemptAt?: Date | string | null
    lastAttemptAt?: Date | string | null
    attemptCount?: number
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    planJob?: LongevityPlanJobCreateNestedOneWithoutCloudTaskInput
  }

  export type CloudTaskMetadataUncheckedCreateWithoutJobInput = {
    id?: string
    taskName: string
    queue: string
    status?: $Enums.CloudTaskStatus
    planJobId?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduleTime?: Date | string | null
    firstAttemptAt?: Date | string | null
    lastAttemptAt?: Date | string | null
    attemptCount?: number
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CloudTaskMetadataCreateOrConnectWithoutJobInput = {
    where: CloudTaskMetadataWhereUniqueInput
    create: XOR<CloudTaskMetadataCreateWithoutJobInput, CloudTaskMetadataUncheckedCreateWithoutJobInput>
  }

  export type InsightUpsertWithoutGenerationJobsInput = {
    update: XOR<InsightUpdateWithoutGenerationJobsInput, InsightUncheckedUpdateWithoutGenerationJobsInput>
    create: XOR<InsightCreateWithoutGenerationJobsInput, InsightUncheckedCreateWithoutGenerationJobsInput>
    where?: InsightWhereInput
  }

  export type InsightUpdateToOneWithWhereWithoutGenerationJobsInput = {
    where?: InsightWhereInput
    data: XOR<InsightUpdateWithoutGenerationJobsInput, InsightUncheckedUpdateWithoutGenerationJobsInput>
  }

  export type InsightUpdateWithoutGenerationJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInsightsNestedInput
    actions?: InsightActionUpdateManyWithoutInsightNestedInput
    flags?: FlagUpdateManyWithoutInsightNestedInput
  }

  export type InsightUncheckedUpdateWithoutGenerationJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: InsightActionUncheckedUpdateManyWithoutInsightNestedInput
    flags?: FlagUncheckedUpdateManyWithoutInsightNestedInput
  }

  export type UserUpsertWithoutInsightGenerationJobsInput = {
    update: XOR<UserUpdateWithoutInsightGenerationJobsInput, UserUncheckedUpdateWithoutInsightGenerationJobsInput>
    create: XOR<UserCreateWithoutInsightGenerationJobsInput, UserUncheckedCreateWithoutInsightGenerationJobsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInsightGenerationJobsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInsightGenerationJobsInput, UserUncheckedUpdateWithoutInsightGenerationJobsInput>
  }

  export type UserUpdateWithoutInsightGenerationJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInsightGenerationJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CloudTaskMetadataUpsertWithoutJobInput = {
    update: XOR<CloudTaskMetadataUpdateWithoutJobInput, CloudTaskMetadataUncheckedUpdateWithoutJobInput>
    create: XOR<CloudTaskMetadataCreateWithoutJobInput, CloudTaskMetadataUncheckedCreateWithoutJobInput>
    where?: CloudTaskMetadataWhereInput
  }

  export type CloudTaskMetadataUpdateToOneWithWhereWithoutJobInput = {
    where?: CloudTaskMetadataWhereInput
    data: XOR<CloudTaskMetadataUpdateWithoutJobInput, CloudTaskMetadataUncheckedUpdateWithoutJobInput>
  }

  export type CloudTaskMetadataUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskName?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    status?: EnumCloudTaskStatusFieldUpdateOperationsInput | $Enums.CloudTaskStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduleTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    planJob?: LongevityPlanJobUpdateOneWithoutCloudTaskNestedInput
  }

  export type CloudTaskMetadataUncheckedUpdateWithoutJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskName?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    status?: EnumCloudTaskStatusFieldUpdateOperationsInput | $Enums.CloudTaskStatus
    planJobId?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduleTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LongevityPlanCreateWithoutJobsInput = {
    id?: string
    status?: $Enums.LongevityPlanStatus
    title: string
    summary?: string | null
    focusAreas?: LongevityPlanCreatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: string | null
    validatedAt?: Date | string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLongevityPlansInput
    audits?: AiResponseAuditCreateNestedManyWithoutPlanInput
  }

  export type LongevityPlanUncheckedCreateWithoutJobsInput = {
    id?: string
    userId: string
    status?: $Enums.LongevityPlanStatus
    title: string
    summary?: string | null
    focusAreas?: LongevityPlanCreatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: string | null
    validatedAt?: Date | string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    audits?: AiResponseAuditUncheckedCreateNestedManyWithoutPlanInput
  }

  export type LongevityPlanCreateOrConnectWithoutJobsInput = {
    where: LongevityPlanWhereUniqueInput
    create: XOR<LongevityPlanCreateWithoutJobsInput, LongevityPlanUncheckedCreateWithoutJobsInput>
  }

  export type UserCreateWithoutLongevityPlanJobsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLongevityPlanJobsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLongevityPlanJobsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLongevityPlanJobsInput, UserUncheckedCreateWithoutLongevityPlanJobsInput>
  }

  export type CloudTaskMetadataCreateWithoutPlanJobInput = {
    id?: string
    taskName: string
    queue: string
    status?: $Enums.CloudTaskStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduleTime?: Date | string | null
    firstAttemptAt?: Date | string | null
    lastAttemptAt?: Date | string | null
    attemptCount?: number
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    job?: InsightGenerationJobCreateNestedOneWithoutCloudTaskInput
  }

  export type CloudTaskMetadataUncheckedCreateWithoutPlanJobInput = {
    id?: string
    taskName: string
    queue: string
    status?: $Enums.CloudTaskStatus
    jobId?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduleTime?: Date | string | null
    firstAttemptAt?: Date | string | null
    lastAttemptAt?: Date | string | null
    attemptCount?: number
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CloudTaskMetadataCreateOrConnectWithoutPlanJobInput = {
    where: CloudTaskMetadataWhereUniqueInput
    create: XOR<CloudTaskMetadataCreateWithoutPlanJobInput, CloudTaskMetadataUncheckedCreateWithoutPlanJobInput>
  }

  export type LongevityPlanUpsertWithoutJobsInput = {
    update: XOR<LongevityPlanUpdateWithoutJobsInput, LongevityPlanUncheckedUpdateWithoutJobsInput>
    create: XOR<LongevityPlanCreateWithoutJobsInput, LongevityPlanUncheckedCreateWithoutJobsInput>
    where?: LongevityPlanWhereInput
  }

  export type LongevityPlanUpdateToOneWithWhereWithoutJobsInput = {
    where?: LongevityPlanWhereInput
    data: XOR<LongevityPlanUpdateWithoutJobsInput, LongevityPlanUncheckedUpdateWithoutJobsInput>
  }

  export type LongevityPlanUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLongevityPlanStatusFieldUpdateOperationsInput | $Enums.LongevityPlanStatus
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    focusAreas?: LongevityPlanUpdatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLongevityPlansNestedInput
    audits?: AiResponseAuditUpdateManyWithoutPlanNestedInput
  }

  export type LongevityPlanUncheckedUpdateWithoutJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumLongevityPlanStatusFieldUpdateOperationsInput | $Enums.LongevityPlanStatus
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    focusAreas?: LongevityPlanUpdatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    audits?: AiResponseAuditUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type UserUpsertWithoutLongevityPlanJobsInput = {
    update: XOR<UserUpdateWithoutLongevityPlanJobsInput, UserUncheckedUpdateWithoutLongevityPlanJobsInput>
    create: XOR<UserCreateWithoutLongevityPlanJobsInput, UserUncheckedCreateWithoutLongevityPlanJobsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLongevityPlanJobsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLongevityPlanJobsInput, UserUncheckedUpdateWithoutLongevityPlanJobsInput>
  }

  export type UserUpdateWithoutLongevityPlanJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLongevityPlanJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CloudTaskMetadataUpsertWithoutPlanJobInput = {
    update: XOR<CloudTaskMetadataUpdateWithoutPlanJobInput, CloudTaskMetadataUncheckedUpdateWithoutPlanJobInput>
    create: XOR<CloudTaskMetadataCreateWithoutPlanJobInput, CloudTaskMetadataUncheckedCreateWithoutPlanJobInput>
    where?: CloudTaskMetadataWhereInput
  }

  export type CloudTaskMetadataUpdateToOneWithWhereWithoutPlanJobInput = {
    where?: CloudTaskMetadataWhereInput
    data: XOR<CloudTaskMetadataUpdateWithoutPlanJobInput, CloudTaskMetadataUncheckedUpdateWithoutPlanJobInput>
  }

  export type CloudTaskMetadataUpdateWithoutPlanJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskName?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    status?: EnumCloudTaskStatusFieldUpdateOperationsInput | $Enums.CloudTaskStatus
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduleTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    job?: InsightGenerationJobUpdateOneWithoutCloudTaskNestedInput
  }

  export type CloudTaskMetadataUncheckedUpdateWithoutPlanJobInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskName?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    status?: EnumCloudTaskStatusFieldUpdateOperationsInput | $Enums.CloudTaskStatus
    jobId?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduleTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firstAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastAttemptAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightGenerationJobCreateWithoutCloudTaskInput = {
    id?: string
    status: $Enums.InsightGenerationStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    insight?: InsightCreateNestedOneWithoutGenerationJobsInput
    requestedBy?: UserCreateNestedOneWithoutInsightGenerationJobsInput
  }

  export type InsightGenerationJobUncheckedCreateWithoutCloudTaskInput = {
    id?: string
    insightId?: string | null
    requestedById?: string | null
    status: $Enums.InsightGenerationStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsightGenerationJobCreateOrConnectWithoutCloudTaskInput = {
    where: InsightGenerationJobWhereUniqueInput
    create: XOR<InsightGenerationJobCreateWithoutCloudTaskInput, InsightGenerationJobUncheckedCreateWithoutCloudTaskInput>
  }

  export type LongevityPlanJobCreateWithoutCloudTaskInput = {
    id?: string
    status?: $Enums.LongevityPlanJobStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    plan?: LongevityPlanCreateNestedOneWithoutJobsInput
    requestedBy?: UserCreateNestedOneWithoutLongevityPlanJobsInput
  }

  export type LongevityPlanJobUncheckedCreateWithoutCloudTaskInput = {
    id?: string
    planId?: string | null
    requestedById?: string | null
    status?: $Enums.LongevityPlanJobStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LongevityPlanJobCreateOrConnectWithoutCloudTaskInput = {
    where: LongevityPlanJobWhereUniqueInput
    create: XOR<LongevityPlanJobCreateWithoutCloudTaskInput, LongevityPlanJobUncheckedCreateWithoutCloudTaskInput>
  }

  export type InsightGenerationJobUpsertWithoutCloudTaskInput = {
    update: XOR<InsightGenerationJobUpdateWithoutCloudTaskInput, InsightGenerationJobUncheckedUpdateWithoutCloudTaskInput>
    create: XOR<InsightGenerationJobCreateWithoutCloudTaskInput, InsightGenerationJobUncheckedCreateWithoutCloudTaskInput>
    where?: InsightGenerationJobWhereInput
  }

  export type InsightGenerationJobUpdateToOneWithWhereWithoutCloudTaskInput = {
    where?: InsightGenerationJobWhereInput
    data: XOR<InsightGenerationJobUpdateWithoutCloudTaskInput, InsightGenerationJobUncheckedUpdateWithoutCloudTaskInput>
  }

  export type InsightGenerationJobUpdateWithoutCloudTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInsightGenerationStatusFieldUpdateOperationsInput | $Enums.InsightGenerationStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insight?: InsightUpdateOneWithoutGenerationJobsNestedInput
    requestedBy?: UserUpdateOneWithoutInsightGenerationJobsNestedInput
  }

  export type InsightGenerationJobUncheckedUpdateWithoutCloudTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsightGenerationStatusFieldUpdateOperationsInput | $Enums.InsightGenerationStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LongevityPlanJobUpsertWithoutCloudTaskInput = {
    update: XOR<LongevityPlanJobUpdateWithoutCloudTaskInput, LongevityPlanJobUncheckedUpdateWithoutCloudTaskInput>
    create: XOR<LongevityPlanJobCreateWithoutCloudTaskInput, LongevityPlanJobUncheckedCreateWithoutCloudTaskInput>
    where?: LongevityPlanJobWhereInput
  }

  export type LongevityPlanJobUpdateToOneWithWhereWithoutCloudTaskInput = {
    where?: LongevityPlanJobWhereInput
    data: XOR<LongevityPlanJobUpdateWithoutCloudTaskInput, LongevityPlanJobUncheckedUpdateWithoutCloudTaskInput>
  }

  export type LongevityPlanJobUpdateWithoutCloudTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLongevityPlanJobStatusFieldUpdateOperationsInput | $Enums.LongevityPlanJobStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: LongevityPlanUpdateOneWithoutJobsNestedInput
    requestedBy?: UserUpdateOneWithoutLongevityPlanJobsNestedInput
  }

  export type LongevityPlanJobUncheckedUpdateWithoutCloudTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLongevityPlanJobStatusFieldUpdateOperationsInput | $Enums.LongevityPlanJobStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutWhoopIntegrationInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWhoopIntegrationInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWhoopIntegrationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWhoopIntegrationInput, UserUncheckedCreateWithoutWhoopIntegrationInput>
  }

  export type UserUpsertWithoutWhoopIntegrationInput = {
    update: XOR<UserUpdateWithoutWhoopIntegrationInput, UserUncheckedUpdateWithoutWhoopIntegrationInput>
    create: XOR<UserCreateWithoutWhoopIntegrationInput, UserUncheckedCreateWithoutWhoopIntegrationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWhoopIntegrationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWhoopIntegrationInput, UserUncheckedUpdateWithoutWhoopIntegrationInput>
  }

  export type UserUpdateWithoutWhoopIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWhoopIntegrationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutWhoopLinkSessionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWhoopLinkSessionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWhoopLinkSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWhoopLinkSessionsInput, UserUncheckedCreateWithoutWhoopLinkSessionsInput>
  }

  export type UserUpsertWithoutWhoopLinkSessionsInput = {
    update: XOR<UserUpdateWithoutWhoopLinkSessionsInput, UserUncheckedUpdateWithoutWhoopLinkSessionsInput>
    create: XOR<UserCreateWithoutWhoopLinkSessionsInput, UserUncheckedCreateWithoutWhoopLinkSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWhoopLinkSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWhoopLinkSessionsInput, UserUncheckedUpdateWithoutWhoopLinkSessionsInput>
  }

  export type UserUpdateWithoutWhoopLinkSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWhoopLinkSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutFeedPostsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFeedPostsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFeedPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFeedPostsInput, UserUncheckedCreateWithoutFeedPostsInput>
  }

  export type CommentCreateWithoutPostInput = {
    id?: string
    body: string
    flagged?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutCommentsInput
    reactions?: ReactionCreateNestedManyWithoutCommentInput
    flags?: FlagCreateNestedManyWithoutCommentInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutPostInput = {
    id?: string
    authorId: string
    body: string
    flagged?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ReactionUncheckedCreateNestedManyWithoutCommentInput
    flags?: FlagUncheckedCreateNestedManyWithoutCommentInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutPostInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentCreateManyPostInputEnvelope = {
    data: CommentCreateManyPostInput | CommentCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type ReactionCreateWithoutPostInput = {
    id?: string
    type: $Enums.ReactionType
    createdAt?: Date | string
    comment?: CommentCreateNestedOneWithoutReactionsInput
    user: UserCreateNestedOneWithoutReactionsInput
  }

  export type ReactionUncheckedCreateWithoutPostInput = {
    id?: string
    type: $Enums.ReactionType
    commentId?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type ReactionCreateOrConnectWithoutPostInput = {
    where: ReactionWhereUniqueInput
    create: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput>
  }

  export type ReactionCreateManyPostInputEnvelope = {
    data: ReactionCreateManyPostInput | ReactionCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type FlagCreateWithoutPostInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    comment?: CommentCreateNestedOneWithoutFlagsInput
    insight?: InsightCreateNestedOneWithoutFlagsInput
    biomarkerLog?: BiomarkerLogCreateNestedOneWithoutFlagsInput
    openedBy: UserCreateNestedOneWithoutFlagsOpenedInput
    resolvedBy?: UserCreateNestedOneWithoutFlagsResolvedInput
  }

  export type FlagUncheckedCreateWithoutPostInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    commentId?: string | null
    insightId?: string | null
    biomarkerLogId?: string | null
    openedById: string
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlagCreateOrConnectWithoutPostInput = {
    where: FlagWhereUniqueInput
    create: XOR<FlagCreateWithoutPostInput, FlagUncheckedCreateWithoutPostInput>
  }

  export type FlagCreateManyPostInputEnvelope = {
    data: FlagCreateManyPostInput | FlagCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type EngagementEventCreateWithoutPostInput = {
    id?: string
    type: $Enums.EngagementEventType
    reactionType?: $Enums.ReactionType | null
    occurredAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutEngagementEventsInput
    comment?: CommentCreateNestedOneWithoutEngagementEventsInput
  }

  export type EngagementEventUncheckedCreateWithoutPostInput = {
    id?: string
    type: $Enums.EngagementEventType
    userId: string
    commentId?: string | null
    reactionType?: $Enums.ReactionType | null
    occurredAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EngagementEventCreateOrConnectWithoutPostInput = {
    where: EngagementEventWhereUniqueInput
    create: XOR<EngagementEventCreateWithoutPostInput, EngagementEventUncheckedCreateWithoutPostInput>
  }

  export type EngagementEventCreateManyPostInputEnvelope = {
    data: EngagementEventCreateManyPostInput | EngagementEventCreateManyPostInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutFeedPostsInput = {
    update: XOR<UserUpdateWithoutFeedPostsInput, UserUncheckedUpdateWithoutFeedPostsInput>
    create: XOR<UserCreateWithoutFeedPostsInput, UserUncheckedCreateWithoutFeedPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFeedPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFeedPostsInput, UserUncheckedUpdateWithoutFeedPostsInput>
  }

  export type UserUpdateWithoutFeedPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFeedPostsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CommentUpsertWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    update: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
    create: XOR<CommentCreateWithoutPostInput, CommentUncheckedCreateWithoutPostInput>
  }

  export type CommentUpdateWithWhereUniqueWithoutPostInput = {
    where: CommentWhereUniqueInput
    data: XOR<CommentUpdateWithoutPostInput, CommentUncheckedUpdateWithoutPostInput>
  }

  export type CommentUpdateManyWithWhereWithoutPostInput = {
    where: CommentScalarWhereInput
    data: XOR<CommentUpdateManyMutationInput, CommentUncheckedUpdateManyWithoutPostInput>
  }

  export type ReactionUpsertWithWhereUniqueWithoutPostInput = {
    where: ReactionWhereUniqueInput
    update: XOR<ReactionUpdateWithoutPostInput, ReactionUncheckedUpdateWithoutPostInput>
    create: XOR<ReactionCreateWithoutPostInput, ReactionUncheckedCreateWithoutPostInput>
  }

  export type ReactionUpdateWithWhereUniqueWithoutPostInput = {
    where: ReactionWhereUniqueInput
    data: XOR<ReactionUpdateWithoutPostInput, ReactionUncheckedUpdateWithoutPostInput>
  }

  export type ReactionUpdateManyWithWhereWithoutPostInput = {
    where: ReactionScalarWhereInput
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyWithoutPostInput>
  }

  export type FlagUpsertWithWhereUniqueWithoutPostInput = {
    where: FlagWhereUniqueInput
    update: XOR<FlagUpdateWithoutPostInput, FlagUncheckedUpdateWithoutPostInput>
    create: XOR<FlagCreateWithoutPostInput, FlagUncheckedCreateWithoutPostInput>
  }

  export type FlagUpdateWithWhereUniqueWithoutPostInput = {
    where: FlagWhereUniqueInput
    data: XOR<FlagUpdateWithoutPostInput, FlagUncheckedUpdateWithoutPostInput>
  }

  export type FlagUpdateManyWithWhereWithoutPostInput = {
    where: FlagScalarWhereInput
    data: XOR<FlagUpdateManyMutationInput, FlagUncheckedUpdateManyWithoutPostInput>
  }

  export type EngagementEventUpsertWithWhereUniqueWithoutPostInput = {
    where: EngagementEventWhereUniqueInput
    update: XOR<EngagementEventUpdateWithoutPostInput, EngagementEventUncheckedUpdateWithoutPostInput>
    create: XOR<EngagementEventCreateWithoutPostInput, EngagementEventUncheckedCreateWithoutPostInput>
  }

  export type EngagementEventUpdateWithWhereUniqueWithoutPostInput = {
    where: EngagementEventWhereUniqueInput
    data: XOR<EngagementEventUpdateWithoutPostInput, EngagementEventUncheckedUpdateWithoutPostInput>
  }

  export type EngagementEventUpdateManyWithWhereWithoutPostInput = {
    where: EngagementEventScalarWhereInput
    data: XOR<EngagementEventUpdateManyMutationInput, EngagementEventUncheckedUpdateManyWithoutPostInput>
  }

  export type FeedPostCreateWithoutCommentsInput = {
    id?: string
    body: string
    tags?: FeedPostCreatetagsInput | string[]
    visibility?: $Enums.PostVisibility
    flagged?: boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutFeedPostsInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    flags?: FlagCreateNestedManyWithoutPostInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutPostInput
  }

  export type FeedPostUncheckedCreateWithoutCommentsInput = {
    id?: string
    authorId: string
    body: string
    tags?: FeedPostCreatetagsInput | string[]
    visibility?: $Enums.PostVisibility
    flagged?: boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    flags?: FlagUncheckedCreateNestedManyWithoutPostInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutPostInput
  }

  export type FeedPostCreateOrConnectWithoutCommentsInput = {
    where: FeedPostWhereUniqueInput
    create: XOR<FeedPostCreateWithoutCommentsInput, FeedPostUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutCommentsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
  }

  export type ReactionCreateWithoutCommentInput = {
    id?: string
    type: $Enums.ReactionType
    createdAt?: Date | string
    post?: FeedPostCreateNestedOneWithoutReactionsInput
    user: UserCreateNestedOneWithoutReactionsInput
  }

  export type ReactionUncheckedCreateWithoutCommentInput = {
    id?: string
    type: $Enums.ReactionType
    postId?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type ReactionCreateOrConnectWithoutCommentInput = {
    where: ReactionWhereUniqueInput
    create: XOR<ReactionCreateWithoutCommentInput, ReactionUncheckedCreateWithoutCommentInput>
  }

  export type ReactionCreateManyCommentInputEnvelope = {
    data: ReactionCreateManyCommentInput | ReactionCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type FlagCreateWithoutCommentInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    post?: FeedPostCreateNestedOneWithoutFlagsInput
    insight?: InsightCreateNestedOneWithoutFlagsInput
    biomarkerLog?: BiomarkerLogCreateNestedOneWithoutFlagsInput
    openedBy: UserCreateNestedOneWithoutFlagsOpenedInput
    resolvedBy?: UserCreateNestedOneWithoutFlagsResolvedInput
  }

  export type FlagUncheckedCreateWithoutCommentInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    postId?: string | null
    insightId?: string | null
    biomarkerLogId?: string | null
    openedById: string
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlagCreateOrConnectWithoutCommentInput = {
    where: FlagWhereUniqueInput
    create: XOR<FlagCreateWithoutCommentInput, FlagUncheckedCreateWithoutCommentInput>
  }

  export type FlagCreateManyCommentInputEnvelope = {
    data: FlagCreateManyCommentInput | FlagCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type EngagementEventCreateWithoutCommentInput = {
    id?: string
    type: $Enums.EngagementEventType
    reactionType?: $Enums.ReactionType | null
    occurredAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutEngagementEventsInput
    post?: FeedPostCreateNestedOneWithoutEngagementEventsInput
  }

  export type EngagementEventUncheckedCreateWithoutCommentInput = {
    id?: string
    type: $Enums.EngagementEventType
    userId: string
    postId?: string | null
    reactionType?: $Enums.ReactionType | null
    occurredAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EngagementEventCreateOrConnectWithoutCommentInput = {
    where: EngagementEventWhereUniqueInput
    create: XOR<EngagementEventCreateWithoutCommentInput, EngagementEventUncheckedCreateWithoutCommentInput>
  }

  export type EngagementEventCreateManyCommentInputEnvelope = {
    data: EngagementEventCreateManyCommentInput | EngagementEventCreateManyCommentInput[]
    skipDuplicates?: boolean
  }

  export type FeedPostUpsertWithoutCommentsInput = {
    update: XOR<FeedPostUpdateWithoutCommentsInput, FeedPostUncheckedUpdateWithoutCommentsInput>
    create: XOR<FeedPostCreateWithoutCommentsInput, FeedPostUncheckedCreateWithoutCommentsInput>
    where?: FeedPostWhereInput
  }

  export type FeedPostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: FeedPostWhereInput
    data: XOR<FeedPostUpdateWithoutCommentsInput, FeedPostUncheckedUpdateWithoutCommentsInput>
  }

  export type FeedPostUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    tags?: FeedPostUpdatetagsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutFeedPostsNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    flags?: FlagUpdateManyWithoutPostNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutPostNestedInput
  }

  export type FeedPostUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    tags?: FeedPostUpdatetagsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    flags?: FlagUncheckedUpdateManyWithoutPostNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutCommentsInput = {
    update: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
    create: XOR<UserCreateWithoutCommentsInput, UserUncheckedCreateWithoutCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentsInput, UserUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReactionUpsertWithWhereUniqueWithoutCommentInput = {
    where: ReactionWhereUniqueInput
    update: XOR<ReactionUpdateWithoutCommentInput, ReactionUncheckedUpdateWithoutCommentInput>
    create: XOR<ReactionCreateWithoutCommentInput, ReactionUncheckedCreateWithoutCommentInput>
  }

  export type ReactionUpdateWithWhereUniqueWithoutCommentInput = {
    where: ReactionWhereUniqueInput
    data: XOR<ReactionUpdateWithoutCommentInput, ReactionUncheckedUpdateWithoutCommentInput>
  }

  export type ReactionUpdateManyWithWhereWithoutCommentInput = {
    where: ReactionScalarWhereInput
    data: XOR<ReactionUpdateManyMutationInput, ReactionUncheckedUpdateManyWithoutCommentInput>
  }

  export type FlagUpsertWithWhereUniqueWithoutCommentInput = {
    where: FlagWhereUniqueInput
    update: XOR<FlagUpdateWithoutCommentInput, FlagUncheckedUpdateWithoutCommentInput>
    create: XOR<FlagCreateWithoutCommentInput, FlagUncheckedCreateWithoutCommentInput>
  }

  export type FlagUpdateWithWhereUniqueWithoutCommentInput = {
    where: FlagWhereUniqueInput
    data: XOR<FlagUpdateWithoutCommentInput, FlagUncheckedUpdateWithoutCommentInput>
  }

  export type FlagUpdateManyWithWhereWithoutCommentInput = {
    where: FlagScalarWhereInput
    data: XOR<FlagUpdateManyMutationInput, FlagUncheckedUpdateManyWithoutCommentInput>
  }

  export type EngagementEventUpsertWithWhereUniqueWithoutCommentInput = {
    where: EngagementEventWhereUniqueInput
    update: XOR<EngagementEventUpdateWithoutCommentInput, EngagementEventUncheckedUpdateWithoutCommentInput>
    create: XOR<EngagementEventCreateWithoutCommentInput, EngagementEventUncheckedCreateWithoutCommentInput>
  }

  export type EngagementEventUpdateWithWhereUniqueWithoutCommentInput = {
    where: EngagementEventWhereUniqueInput
    data: XOR<EngagementEventUpdateWithoutCommentInput, EngagementEventUncheckedUpdateWithoutCommentInput>
  }

  export type EngagementEventUpdateManyWithWhereWithoutCommentInput = {
    where: EngagementEventScalarWhereInput
    data: XOR<EngagementEventUpdateManyMutationInput, EngagementEventUncheckedUpdateManyWithoutCommentInput>
  }

  export type FeedPostCreateWithoutReactionsInput = {
    id?: string
    body: string
    tags?: FeedPostCreatetagsInput | string[]
    visibility?: $Enums.PostVisibility
    flagged?: boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutFeedPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    flags?: FlagCreateNestedManyWithoutPostInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutPostInput
  }

  export type FeedPostUncheckedCreateWithoutReactionsInput = {
    id?: string
    authorId: string
    body: string
    tags?: FeedPostCreatetagsInput | string[]
    visibility?: $Enums.PostVisibility
    flagged?: boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    flags?: FlagUncheckedCreateNestedManyWithoutPostInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutPostInput
  }

  export type FeedPostCreateOrConnectWithoutReactionsInput = {
    where: FeedPostWhereUniqueInput
    create: XOR<FeedPostCreateWithoutReactionsInput, FeedPostUncheckedCreateWithoutReactionsInput>
  }

  export type CommentCreateWithoutReactionsInput = {
    id?: string
    body: string
    flagged?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    post: FeedPostCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
    flags?: FlagCreateNestedManyWithoutCommentInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutReactionsInput = {
    id?: string
    postId: string
    authorId: string
    body: string
    flagged?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    flags?: FlagUncheckedCreateNestedManyWithoutCommentInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutReactionsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutReactionsInput, CommentUncheckedCreateWithoutReactionsInput>
  }

  export type UserCreateWithoutReactionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReactionsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReactionsInput, UserUncheckedCreateWithoutReactionsInput>
  }

  export type FeedPostUpsertWithoutReactionsInput = {
    update: XOR<FeedPostUpdateWithoutReactionsInput, FeedPostUncheckedUpdateWithoutReactionsInput>
    create: XOR<FeedPostCreateWithoutReactionsInput, FeedPostUncheckedCreateWithoutReactionsInput>
    where?: FeedPostWhereInput
  }

  export type FeedPostUpdateToOneWithWhereWithoutReactionsInput = {
    where?: FeedPostWhereInput
    data: XOR<FeedPostUpdateWithoutReactionsInput, FeedPostUncheckedUpdateWithoutReactionsInput>
  }

  export type FeedPostUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    tags?: FeedPostUpdatetagsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutFeedPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    flags?: FlagUpdateManyWithoutPostNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutPostNestedInput
  }

  export type FeedPostUncheckedUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    tags?: FeedPostUpdatetagsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    flags?: FlagUncheckedUpdateManyWithoutPostNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CommentUpsertWithoutReactionsInput = {
    update: XOR<CommentUpdateWithoutReactionsInput, CommentUncheckedUpdateWithoutReactionsInput>
    create: XOR<CommentCreateWithoutReactionsInput, CommentUncheckedCreateWithoutReactionsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutReactionsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutReactionsInput, CommentUncheckedUpdateWithoutReactionsInput>
  }

  export type CommentUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: FeedPostUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    flags?: FlagUpdateManyWithoutCommentNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flags?: FlagUncheckedUpdateManyWithoutCommentNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type UserUpsertWithoutReactionsInput = {
    update: XOR<UserUpdateWithoutReactionsInput, UserUncheckedUpdateWithoutReactionsInput>
    create: XOR<UserCreateWithoutReactionsInput, UserUncheckedCreateWithoutReactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReactionsInput, UserUncheckedUpdateWithoutReactionsInput>
  }

  export type UserUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutEngagementEventsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEngagementEventsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEngagementEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEngagementEventsInput, UserUncheckedCreateWithoutEngagementEventsInput>
  }

  export type FeedPostCreateWithoutEngagementEventsInput = {
    id?: string
    body: string
    tags?: FeedPostCreatetagsInput | string[]
    visibility?: $Enums.PostVisibility
    flagged?: boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutFeedPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    flags?: FlagCreateNestedManyWithoutPostInput
  }

  export type FeedPostUncheckedCreateWithoutEngagementEventsInput = {
    id?: string
    authorId: string
    body: string
    tags?: FeedPostCreatetagsInput | string[]
    visibility?: $Enums.PostVisibility
    flagged?: boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    flags?: FlagUncheckedCreateNestedManyWithoutPostInput
  }

  export type FeedPostCreateOrConnectWithoutEngagementEventsInput = {
    where: FeedPostWhereUniqueInput
    create: XOR<FeedPostCreateWithoutEngagementEventsInput, FeedPostUncheckedCreateWithoutEngagementEventsInput>
  }

  export type CommentCreateWithoutEngagementEventsInput = {
    id?: string
    body: string
    flagged?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    post: FeedPostCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
    reactions?: ReactionCreateNestedManyWithoutCommentInput
    flags?: FlagCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutEngagementEventsInput = {
    id?: string
    postId: string
    authorId: string
    body: string
    flagged?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ReactionUncheckedCreateNestedManyWithoutCommentInput
    flags?: FlagUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutEngagementEventsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutEngagementEventsInput, CommentUncheckedCreateWithoutEngagementEventsInput>
  }

  export type UserUpsertWithoutEngagementEventsInput = {
    update: XOR<UserUpdateWithoutEngagementEventsInput, UserUncheckedUpdateWithoutEngagementEventsInput>
    create: XOR<UserCreateWithoutEngagementEventsInput, UserUncheckedCreateWithoutEngagementEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEngagementEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEngagementEventsInput, UserUncheckedUpdateWithoutEngagementEventsInput>
  }

  export type UserUpdateWithoutEngagementEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEngagementEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FeedPostUpsertWithoutEngagementEventsInput = {
    update: XOR<FeedPostUpdateWithoutEngagementEventsInput, FeedPostUncheckedUpdateWithoutEngagementEventsInput>
    create: XOR<FeedPostCreateWithoutEngagementEventsInput, FeedPostUncheckedCreateWithoutEngagementEventsInput>
    where?: FeedPostWhereInput
  }

  export type FeedPostUpdateToOneWithWhereWithoutEngagementEventsInput = {
    where?: FeedPostWhereInput
    data: XOR<FeedPostUpdateWithoutEngagementEventsInput, FeedPostUncheckedUpdateWithoutEngagementEventsInput>
  }

  export type FeedPostUpdateWithoutEngagementEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    tags?: FeedPostUpdatetagsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutFeedPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    flags?: FlagUpdateManyWithoutPostNestedInput
  }

  export type FeedPostUncheckedUpdateWithoutEngagementEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    tags?: FeedPostUpdatetagsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    flags?: FlagUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CommentUpsertWithoutEngagementEventsInput = {
    update: XOR<CommentUpdateWithoutEngagementEventsInput, CommentUncheckedUpdateWithoutEngagementEventsInput>
    create: XOR<CommentCreateWithoutEngagementEventsInput, CommentUncheckedCreateWithoutEngagementEventsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutEngagementEventsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutEngagementEventsInput, CommentUncheckedUpdateWithoutEngagementEventsInput>
  }

  export type CommentUpdateWithoutEngagementEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: FeedPostUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    reactions?: ReactionUpdateManyWithoutCommentNestedInput
    flags?: FlagUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutEngagementEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ReactionUncheckedUpdateManyWithoutCommentNestedInput
    flags?: FlagUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type FeedPostCreateWithoutFlagsInput = {
    id?: string
    body: string
    tags?: FeedPostCreatetagsInput | string[]
    visibility?: $Enums.PostVisibility
    flagged?: boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutFeedPostsInput
    comments?: CommentCreateNestedManyWithoutPostInput
    reactions?: ReactionCreateNestedManyWithoutPostInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutPostInput
  }

  export type FeedPostUncheckedCreateWithoutFlagsInput = {
    id?: string
    authorId: string
    body: string
    tags?: FeedPostCreatetagsInput | string[]
    visibility?: $Enums.PostVisibility
    flagged?: boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: CommentUncheckedCreateNestedManyWithoutPostInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutPostInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutPostInput
  }

  export type FeedPostCreateOrConnectWithoutFlagsInput = {
    where: FeedPostWhereUniqueInput
    create: XOR<FeedPostCreateWithoutFlagsInput, FeedPostUncheckedCreateWithoutFlagsInput>
  }

  export type CommentCreateWithoutFlagsInput = {
    id?: string
    body: string
    flagged?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    post: FeedPostCreateNestedOneWithoutCommentsInput
    author: UserCreateNestedOneWithoutCommentsInput
    reactions?: ReactionCreateNestedManyWithoutCommentInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutCommentInput
  }

  export type CommentUncheckedCreateWithoutFlagsInput = {
    id?: string
    postId: string
    authorId: string
    body: string
    flagged?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reactions?: ReactionUncheckedCreateNestedManyWithoutCommentInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutCommentInput
  }

  export type CommentCreateOrConnectWithoutFlagsInput = {
    where: CommentWhereUniqueInput
    create: XOR<CommentCreateWithoutFlagsInput, CommentUncheckedCreateWithoutFlagsInput>
  }

  export type InsightCreateWithoutFlagsInput = {
    id?: string
    title: string
    summary: string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InsightStatus
    generatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutInsightsInput
    actions?: InsightActionCreateNestedManyWithoutInsightInput
    generationJobs?: InsightGenerationJobCreateNestedManyWithoutInsightInput
  }

  export type InsightUncheckedCreateWithoutFlagsInput = {
    id?: string
    userId: string
    title: string
    summary: string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InsightStatus
    generatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    actions?: InsightActionUncheckedCreateNestedManyWithoutInsightInput
    generationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutInsightInput
  }

  export type InsightCreateOrConnectWithoutFlagsInput = {
    where: InsightWhereUniqueInput
    create: XOR<InsightCreateWithoutFlagsInput, InsightUncheckedCreateWithoutFlagsInput>
  }

  export type BiomarkerLogCreateWithoutFlagsInput = {
    id?: string
    value: Decimal | DecimalJsLike | number | string
    unit?: string | null
    source?: $Enums.BiomarkerSource
    capturedAt: Date | string
    accepted?: boolean
    flagged?: boolean
    notes?: string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutBiomarkerLogsInput
    biomarker: BiomarkerCreateNestedOneWithoutLogsInput
  }

  export type BiomarkerLogUncheckedCreateWithoutFlagsInput = {
    id?: string
    userId: string
    biomarkerId: string
    value: Decimal | DecimalJsLike | number | string
    unit?: string | null
    source?: $Enums.BiomarkerSource
    capturedAt: Date | string
    accepted?: boolean
    flagged?: boolean
    notes?: string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiomarkerLogCreateOrConnectWithoutFlagsInput = {
    where: BiomarkerLogWhereUniqueInput
    create: XOR<BiomarkerLogCreateWithoutFlagsInput, BiomarkerLogUncheckedCreateWithoutFlagsInput>
  }

  export type UserCreateWithoutFlagsOpenedInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFlagsOpenedInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFlagsOpenedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFlagsOpenedInput, UserUncheckedCreateWithoutFlagsOpenedInput>
  }

  export type UserCreateWithoutFlagsResolvedInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFlagsResolvedInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFlagsResolvedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFlagsResolvedInput, UserUncheckedCreateWithoutFlagsResolvedInput>
  }

  export type FeedPostUpsertWithoutFlagsInput = {
    update: XOR<FeedPostUpdateWithoutFlagsInput, FeedPostUncheckedUpdateWithoutFlagsInput>
    create: XOR<FeedPostCreateWithoutFlagsInput, FeedPostUncheckedCreateWithoutFlagsInput>
    where?: FeedPostWhereInput
  }

  export type FeedPostUpdateToOneWithWhereWithoutFlagsInput = {
    where?: FeedPostWhereInput
    data: XOR<FeedPostUpdateWithoutFlagsInput, FeedPostUncheckedUpdateWithoutFlagsInput>
  }

  export type FeedPostUpdateWithoutFlagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    tags?: FeedPostUpdatetagsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutFeedPostsNestedInput
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutPostNestedInput
  }

  export type FeedPostUncheckedUpdateWithoutFlagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    tags?: FeedPostUpdatetagsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutPostNestedInput
  }

  export type CommentUpsertWithoutFlagsInput = {
    update: XOR<CommentUpdateWithoutFlagsInput, CommentUncheckedUpdateWithoutFlagsInput>
    create: XOR<CommentCreateWithoutFlagsInput, CommentUncheckedCreateWithoutFlagsInput>
    where?: CommentWhereInput
  }

  export type CommentUpdateToOneWithWhereWithoutFlagsInput = {
    where?: CommentWhereInput
    data: XOR<CommentUpdateWithoutFlagsInput, CommentUncheckedUpdateWithoutFlagsInput>
  }

  export type CommentUpdateWithoutFlagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: FeedPostUpdateOneRequiredWithoutCommentsNestedInput
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    reactions?: ReactionUpdateManyWithoutCommentNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutFlagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ReactionUncheckedUpdateManyWithoutCommentNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type InsightUpsertWithoutFlagsInput = {
    update: XOR<InsightUpdateWithoutFlagsInput, InsightUncheckedUpdateWithoutFlagsInput>
    create: XOR<InsightCreateWithoutFlagsInput, InsightUncheckedCreateWithoutFlagsInput>
    where?: InsightWhereInput
  }

  export type InsightUpdateToOneWithWhereWithoutFlagsInput = {
    where?: InsightWhereInput
    data: XOR<InsightUpdateWithoutFlagsInput, InsightUncheckedUpdateWithoutFlagsInput>
  }

  export type InsightUpdateWithoutFlagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutInsightsNestedInput
    actions?: InsightActionUpdateManyWithoutInsightNestedInput
    generationJobs?: InsightGenerationJobUpdateManyWithoutInsightNestedInput
  }

  export type InsightUncheckedUpdateWithoutFlagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: InsightActionUncheckedUpdateManyWithoutInsightNestedInput
    generationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutInsightNestedInput
  }

  export type BiomarkerLogUpsertWithoutFlagsInput = {
    update: XOR<BiomarkerLogUpdateWithoutFlagsInput, BiomarkerLogUncheckedUpdateWithoutFlagsInput>
    create: XOR<BiomarkerLogCreateWithoutFlagsInput, BiomarkerLogUncheckedCreateWithoutFlagsInput>
    where?: BiomarkerLogWhereInput
  }

  export type BiomarkerLogUpdateToOneWithWhereWithoutFlagsInput = {
    where?: BiomarkerLogWhereInput
    data: XOR<BiomarkerLogUpdateWithoutFlagsInput, BiomarkerLogUncheckedUpdateWithoutFlagsInput>
  }

  export type BiomarkerLogUpdateWithoutFlagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    flagged?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBiomarkerLogsNestedInput
    biomarker?: BiomarkerUpdateOneRequiredWithoutLogsNestedInput
  }

  export type BiomarkerLogUncheckedUpdateWithoutFlagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    biomarkerId?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    flagged?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutFlagsOpenedInput = {
    update: XOR<UserUpdateWithoutFlagsOpenedInput, UserUncheckedUpdateWithoutFlagsOpenedInput>
    create: XOR<UserCreateWithoutFlagsOpenedInput, UserUncheckedCreateWithoutFlagsOpenedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFlagsOpenedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFlagsOpenedInput, UserUncheckedUpdateWithoutFlagsOpenedInput>
  }

  export type UserUpdateWithoutFlagsOpenedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFlagsOpenedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutFlagsResolvedInput = {
    update: XOR<UserUpdateWithoutFlagsResolvedInput, UserUncheckedUpdateWithoutFlagsResolvedInput>
    create: XOR<UserCreateWithoutFlagsResolvedInput, UserUncheckedCreateWithoutFlagsResolvedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFlagsResolvedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFlagsResolvedInput, UserUncheckedUpdateWithoutFlagsResolvedInput>
  }

  export type UserUpdateWithoutFlagsResolvedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFlagsResolvedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LongevityPlanCreateWithoutAuditsInput = {
    id?: string
    status?: $Enums.LongevityPlanStatus
    title: string
    summary?: string | null
    focusAreas?: LongevityPlanCreatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: string | null
    validatedAt?: Date | string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLongevityPlansInput
    jobs?: LongevityPlanJobCreateNestedManyWithoutPlanInput
  }

  export type LongevityPlanUncheckedCreateWithoutAuditsInput = {
    id?: string
    userId: string
    status?: $Enums.LongevityPlanStatus
    title: string
    summary?: string | null
    focusAreas?: LongevityPlanCreatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: string | null
    validatedAt?: Date | string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    jobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutPlanInput
  }

  export type LongevityPlanCreateOrConnectWithoutAuditsInput = {
    where: LongevityPlanWhereUniqueInput
    create: XOR<LongevityPlanCreateWithoutAuditsInput, LongevityPlanUncheckedCreateWithoutAuditsInput>
  }

  export type UserCreateWithoutAiResponseAuditsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAiResponseAuditsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAiResponseAuditsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAiResponseAuditsInput, UserUncheckedCreateWithoutAiResponseAuditsInput>
  }

  export type LongevityPlanUpsertWithoutAuditsInput = {
    update: XOR<LongevityPlanUpdateWithoutAuditsInput, LongevityPlanUncheckedUpdateWithoutAuditsInput>
    create: XOR<LongevityPlanCreateWithoutAuditsInput, LongevityPlanUncheckedCreateWithoutAuditsInput>
    where?: LongevityPlanWhereInput
  }

  export type LongevityPlanUpdateToOneWithWhereWithoutAuditsInput = {
    where?: LongevityPlanWhereInput
    data: XOR<LongevityPlanUpdateWithoutAuditsInput, LongevityPlanUncheckedUpdateWithoutAuditsInput>
  }

  export type LongevityPlanUpdateWithoutAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLongevityPlanStatusFieldUpdateOperationsInput | $Enums.LongevityPlanStatus
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    focusAreas?: LongevityPlanUpdatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLongevityPlansNestedInput
    jobs?: LongevityPlanJobUpdateManyWithoutPlanNestedInput
  }

  export type LongevityPlanUncheckedUpdateWithoutAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumLongevityPlanStatusFieldUpdateOperationsInput | $Enums.LongevityPlanStatus
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    focusAreas?: LongevityPlanUpdatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: LongevityPlanJobUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type UserUpsertWithoutAiResponseAuditsInput = {
    update: XOR<UserUpdateWithoutAiResponseAuditsInput, UserUncheckedUpdateWithoutAiResponseAuditsInput>
    create: XOR<UserCreateWithoutAiResponseAuditsInput, UserUncheckedCreateWithoutAiResponseAuditsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAiResponseAuditsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAiResponseAuditsInput, UserUncheckedUpdateWithoutAiResponseAuditsInput>
  }

  export type UserUpdateWithoutAiResponseAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAiResponseAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutRoomsHostedInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomMemberships?: RoomMembershipCreateNestedManyWithoutUserInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoomsHostedInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomMemberships?: RoomMembershipUncheckedCreateNestedManyWithoutUserInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoomsHostedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoomsHostedInput, UserUncheckedCreateWithoutRoomsHostedInput>
  }

  export type RoomMembershipCreateWithoutRoomInput = {
    id?: string
    role?: $Enums.RoomMembershipRole
    status?: $Enums.RoomMembershipStatus
    joinedAt?: Date | string
    leftAt?: Date | string | null
    lastSeenAt?: Date | string | null
    reconnectToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRoomMembershipsInput
  }

  export type RoomMembershipUncheckedCreateWithoutRoomInput = {
    id?: string
    userId: string
    role?: $Enums.RoomMembershipRole
    status?: $Enums.RoomMembershipStatus
    joinedAt?: Date | string
    leftAt?: Date | string | null
    lastSeenAt?: Date | string | null
    reconnectToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomMembershipCreateOrConnectWithoutRoomInput = {
    where: RoomMembershipWhereUniqueInput
    create: XOR<RoomMembershipCreateWithoutRoomInput, RoomMembershipUncheckedCreateWithoutRoomInput>
  }

  export type RoomMembershipCreateManyRoomInputEnvelope = {
    data: RoomMembershipCreateManyRoomInput | RoomMembershipCreateManyRoomInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutRoomsHostedInput = {
    update: XOR<UserUpdateWithoutRoomsHostedInput, UserUncheckedUpdateWithoutRoomsHostedInput>
    create: XOR<UserCreateWithoutRoomsHostedInput, UserUncheckedCreateWithoutRoomsHostedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRoomsHostedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRoomsHostedInput, UserUncheckedUpdateWithoutRoomsHostedInput>
  }

  export type UserUpdateWithoutRoomsHostedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomMemberships?: RoomMembershipUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoomsHostedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomMemberships?: RoomMembershipUncheckedUpdateManyWithoutUserNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type RoomMembershipUpsertWithWhereUniqueWithoutRoomInput = {
    where: RoomMembershipWhereUniqueInput
    update: XOR<RoomMembershipUpdateWithoutRoomInput, RoomMembershipUncheckedUpdateWithoutRoomInput>
    create: XOR<RoomMembershipCreateWithoutRoomInput, RoomMembershipUncheckedCreateWithoutRoomInput>
  }

  export type RoomMembershipUpdateWithWhereUniqueWithoutRoomInput = {
    where: RoomMembershipWhereUniqueInput
    data: XOR<RoomMembershipUpdateWithoutRoomInput, RoomMembershipUncheckedUpdateWithoutRoomInput>
  }

  export type RoomMembershipUpdateManyWithWhereWithoutRoomInput = {
    where: RoomMembershipScalarWhereInput
    data: XOR<RoomMembershipUpdateManyMutationInput, RoomMembershipUncheckedUpdateManyWithoutRoomInput>
  }

  export type RoomCreateWithoutMembershipsInput = {
    id?: string
    name?: string | null
    inviteCode: string
    status?: $Enums.RoomStatus
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    host: UserCreateNestedOneWithoutRoomsHostedInput
  }

  export type RoomUncheckedCreateWithoutMembershipsInput = {
    id?: string
    name?: string | null
    inviteCode: string
    status?: $Enums.RoomStatus
    capacity: number
    hostId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomCreateOrConnectWithoutMembershipsInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutMembershipsInput, RoomUncheckedCreateWithoutMembershipsInput>
  }

  export type UserCreateWithoutRoomMembershipsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionCreateNestedManyWithoutUserInput
    insights?: InsightCreateNestedManyWithoutUserInput
    insightActions?: InsightActionCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostCreateNestedManyWithoutAuthorInput
    comments?: CommentCreateNestedManyWithoutAuthorInput
    reactions?: ReactionCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventCreateNestedManyWithoutUserInput
    roomsHosted?: RoomCreateNestedManyWithoutHostInput
    flagsOpened?: FlagCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoomMembershipsInput = {
    id?: string
    email: string
    passwordHash?: string | null
    fullName?: string | null
    role?: $Enums.Role
    status?: $Enums.UserStatus
    whoopMemberId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    authProviders?: AuthProviderUncheckedCreateNestedManyWithoutUserInput
    whoopIntegration?: WhoopIntegrationUncheckedCreateNestedOneWithoutUserInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedCreateNestedManyWithoutUserInput
    insights?: InsightUncheckedCreateNestedManyWithoutUserInput
    insightActions?: InsightActionUncheckedCreateNestedManyWithoutActorInput
    insightGenerationJobs?: InsightGenerationJobUncheckedCreateNestedManyWithoutRequestedByInput
    biomarkerLogs?: BiomarkerLogUncheckedCreateNestedManyWithoutUserInput
    panelUploads?: PanelUploadUncheckedCreateNestedManyWithoutUserInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedCreateNestedManyWithoutUserInput
    feedPosts?: FeedPostUncheckedCreateNestedManyWithoutAuthorInput
    comments?: CommentUncheckedCreateNestedManyWithoutAuthorInput
    reactions?: ReactionUncheckedCreateNestedManyWithoutUserInput
    engagementEvents?: EngagementEventUncheckedCreateNestedManyWithoutUserInput
    roomsHosted?: RoomUncheckedCreateNestedManyWithoutHostInput
    flagsOpened?: FlagUncheckedCreateNestedManyWithoutOpenedByInput
    flagsResolved?: FlagUncheckedCreateNestedManyWithoutResolvedByInput
    auditLogs?: AdminAuditLogUncheckedCreateNestedManyWithoutActorInput
    longevityPlans?: LongevityPlanUncheckedCreateNestedManyWithoutUserInput
    longevityPlanJobs?: LongevityPlanJobUncheckedCreateNestedManyWithoutRequestedByInput
    aiResponseAudits?: AiResponseAuditUncheckedCreateNestedManyWithoutUserInput
    loginAudits?: LoginAuditUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoomMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoomMembershipsInput, UserUncheckedCreateWithoutRoomMembershipsInput>
  }

  export type RoomUpsertWithoutMembershipsInput = {
    update: XOR<RoomUpdateWithoutMembershipsInput, RoomUncheckedUpdateWithoutMembershipsInput>
    create: XOR<RoomCreateWithoutMembershipsInput, RoomUncheckedCreateWithoutMembershipsInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutMembershipsInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutMembershipsInput, RoomUncheckedUpdateWithoutMembershipsInput>
  }

  export type RoomUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    host?: UserUpdateOneRequiredWithoutRoomsHostedNestedInput
  }

  export type RoomUncheckedUpdateWithoutMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    capacity?: IntFieldUpdateOperationsInput | number
    hostId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutRoomMembershipsInput = {
    update: XOR<UserUpdateWithoutRoomMembershipsInput, UserUncheckedUpdateWithoutRoomMembershipsInput>
    create: XOR<UserCreateWithoutRoomMembershipsInput, UserUncheckedCreateWithoutRoomMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRoomMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRoomMembershipsInput, UserUncheckedUpdateWithoutRoomMembershipsInput>
  }

  export type UserUpdateWithoutRoomMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUpdateManyWithoutUserNestedInput
    insights?: InsightUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUpdateManyWithoutAuthorNestedInput
    comments?: CommentUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUpdateManyWithoutHostNestedInput
    flagsOpened?: FlagUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoomMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus
    whoopMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    authProviders?: AuthProviderUncheckedUpdateManyWithoutUserNestedInput
    whoopIntegration?: WhoopIntegrationUncheckedUpdateOneWithoutUserNestedInput
    whoopLinkSessions?: WhoopLinkSessionUncheckedUpdateManyWithoutUserNestedInput
    insights?: InsightUncheckedUpdateManyWithoutUserNestedInput
    insightActions?: InsightActionUncheckedUpdateManyWithoutActorNestedInput
    insightGenerationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutRequestedByNestedInput
    biomarkerLogs?: BiomarkerLogUncheckedUpdateManyWithoutUserNestedInput
    panelUploads?: PanelUploadUncheckedUpdateManyWithoutUserNestedInput
    biomarkerMeasurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutUserNestedInput
    feedPosts?: FeedPostUncheckedUpdateManyWithoutAuthorNestedInput
    comments?: CommentUncheckedUpdateManyWithoutAuthorNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutUserNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutUserNestedInput
    roomsHosted?: RoomUncheckedUpdateManyWithoutHostNestedInput
    flagsOpened?: FlagUncheckedUpdateManyWithoutOpenedByNestedInput
    flagsResolved?: FlagUncheckedUpdateManyWithoutResolvedByNestedInput
    auditLogs?: AdminAuditLogUncheckedUpdateManyWithoutActorNestedInput
    longevityPlans?: LongevityPlanUncheckedUpdateManyWithoutUserNestedInput
    longevityPlanJobs?: LongevityPlanJobUncheckedUpdateManyWithoutRequestedByNestedInput
    aiResponseAudits?: AiResponseAuditUncheckedUpdateManyWithoutUserNestedInput
    loginAudits?: LoginAuditUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AuthProviderCreateManyUserInput = {
    id?: string
    type: $Enums.AuthProviderType
    providerUserId?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    scopes?: AuthProviderCreatescopesInput | string[]
    expiresAt?: Date | string | null
    linkedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type WhoopLinkSessionCreateManyUserInput = {
    id?: string
    state: string
    redirectUri: string
    scope?: WhoopLinkSessionCreatescopeInput | string[]
    expiresAt: Date | string
    createdAt?: Date | string
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
  }

  export type InsightCreateManyUserInput = {
    id?: string
    title: string
    summary: string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.InsightStatus
    generatedAt?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsightActionCreateManyActorInput = {
    id?: string
    insightId: string
    actionType: $Enums.InsightActionType
    notes?: string | null
    createdAt?: Date | string
  }

  export type InsightGenerationJobCreateManyRequestedByInput = {
    id?: string
    insightId?: string | null
    status: $Enums.InsightGenerationStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiomarkerLogCreateManyUserInput = {
    id?: string
    biomarkerId: string
    value: Decimal | DecimalJsLike | number | string
    unit?: string | null
    source?: $Enums.BiomarkerSource
    capturedAt: Date | string
    accepted?: boolean
    flagged?: boolean
    notes?: string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PanelUploadCreateManyUserInput = {
    id?: string
    status?: $Enums.PanelUploadStatus
    source?: $Enums.PanelUploadSource
    storageKey: string
    contentType?: string | null
    pageCount?: number | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    normalizedPayload?: NullableJsonNullValueInput | InputJsonValue
    measurementCount?: number
    processedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiomarkerMeasurementCreateManyUserInput = {
    id?: string
    biomarkerId?: string | null
    panelUploadId?: string | null
    markerName: string
    value?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    capturedAt?: Date | string | null
    status?: $Enums.MeasurementStatus
    source?: $Enums.BiomarkerSource
    confidence?: Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FeedPostCreateManyAuthorInput = {
    id?: string
    body: string
    tags?: FeedPostCreatetagsInput | string[]
    visibility?: $Enums.PostVisibility
    flagged?: boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentCreateManyAuthorInput = {
    id?: string
    postId: string
    body: string
    flagged?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReactionCreateManyUserInput = {
    id?: string
    type: $Enums.ReactionType
    postId?: string | null
    commentId?: string | null
    createdAt?: Date | string
  }

  export type EngagementEventCreateManyUserInput = {
    id?: string
    type: $Enums.EngagementEventType
    postId?: string | null
    commentId?: string | null
    reactionType?: $Enums.ReactionType | null
    occurredAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RoomCreateManyHostInput = {
    id?: string
    name?: string | null
    inviteCode: string
    status?: $Enums.RoomStatus
    capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomMembershipCreateManyUserInput = {
    id?: string
    roomId: string
    role?: $Enums.RoomMembershipRole
    status?: $Enums.RoomMembershipStatus
    joinedAt?: Date | string
    leftAt?: Date | string | null
    lastSeenAt?: Date | string | null
    reconnectToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlagCreateManyOpenedByInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    postId?: string | null
    commentId?: string | null
    insightId?: string | null
    biomarkerLogId?: string | null
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlagCreateManyResolvedByInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    postId?: string | null
    commentId?: string | null
    insightId?: string | null
    biomarkerLogId?: string | null
    openedById: string
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AdminAuditLogCreateManyActorInput = {
    id?: string
    action: string
    targetType: string
    targetId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LongevityPlanCreateManyUserInput = {
    id?: string
    status?: $Enums.LongevityPlanStatus
    title: string
    summary?: string | null
    focusAreas?: LongevityPlanCreatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: string | null
    validatedAt?: Date | string | null
    requestedAt?: Date | string
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LongevityPlanJobCreateManyRequestedByInput = {
    id?: string
    planId?: string | null
    status?: $Enums.LongevityPlanJobStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiResponseAuditCreateManyUserInput = {
    id?: string
    planId?: string | null
    provider: string
    model?: string | null
    role?: string | null
    prompt?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LoginAuditCreateManyUserInput = {
    id?: string
    email: string
    provider: $Enums.AuthProviderType
    success: boolean
    ipAddress?: string | null
    userAgent?: string | null
    failureReason?: string | null
    createdAt?: Date | string
  }

  export type AuthProviderUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAuthProviderTypeFieldUpdateOperationsInput | $Enums.AuthProviderType
    providerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: AuthProviderUpdatescopesInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthProviderUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAuthProviderTypeFieldUpdateOperationsInput | $Enums.AuthProviderType
    providerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: AuthProviderUpdatescopesInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuthProviderUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumAuthProviderTypeFieldUpdateOperationsInput | $Enums.AuthProviderType
    providerUserId?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    scopes?: AuthProviderUpdatescopesInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WhoopLinkSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    redirectUri?: StringFieldUpdateOperationsInput | string
    scope?: WhoopLinkSessionUpdatescopeInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhoopLinkSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    redirectUri?: StringFieldUpdateOperationsInput | string
    scope?: WhoopLinkSessionUpdatescopeInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WhoopLinkSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    state?: StringFieldUpdateOperationsInput | string
    redirectUri?: StringFieldUpdateOperationsInput | string
    scope?: WhoopLinkSessionUpdatescopeInput | string[]
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type InsightUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: InsightActionUpdateManyWithoutInsightNestedInput
    generationJobs?: InsightGenerationJobUpdateManyWithoutInsightNestedInput
    flags?: FlagUpdateManyWithoutInsightNestedInput
  }

  export type InsightUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actions?: InsightActionUncheckedUpdateManyWithoutInsightNestedInput
    generationJobs?: InsightGenerationJobUncheckedUpdateManyWithoutInsightNestedInput
    flags?: FlagUncheckedUpdateManyWithoutInsightNestedInput
  }

  export type InsightUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    summary?: StringFieldUpdateOperationsInput | string
    body?: NullableJsonNullValueInput | InputJsonValue
    modelUsed?: NullableStringFieldUpdateOperationsInput | string | null
    promptMetadata?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumInsightStatusFieldUpdateOperationsInput | $Enums.InsightStatus
    generatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightActionUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumInsightActionTypeFieldUpdateOperationsInput | $Enums.InsightActionType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insight?: InsightUpdateOneRequiredWithoutActionsNestedInput
  }

  export type InsightActionUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumInsightActionTypeFieldUpdateOperationsInput | $Enums.InsightActionType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightActionUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: StringFieldUpdateOperationsInput | string
    actionType?: EnumInsightActionTypeFieldUpdateOperationsInput | $Enums.InsightActionType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightGenerationJobUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInsightGenerationStatusFieldUpdateOperationsInput | $Enums.InsightGenerationStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    insight?: InsightUpdateOneWithoutGenerationJobsNestedInput
    cloudTask?: CloudTaskMetadataUpdateOneWithoutJobNestedInput
  }

  export type InsightGenerationJobUncheckedUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsightGenerationStatusFieldUpdateOperationsInput | $Enums.InsightGenerationStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cloudTask?: CloudTaskMetadataUncheckedUpdateOneWithoutJobNestedInput
  }

  export type InsightGenerationJobUncheckedUpdateManyWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    insightId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsightGenerationStatusFieldUpdateOperationsInput | $Enums.InsightGenerationStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    flagged?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    biomarker?: BiomarkerUpdateOneRequiredWithoutLogsNestedInput
    flags?: FlagUpdateManyWithoutBiomarkerLogNestedInput
  }

  export type BiomarkerLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    biomarkerId?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    flagged?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flags?: FlagUncheckedUpdateManyWithoutBiomarkerLogNestedInput
  }

  export type BiomarkerLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    biomarkerId?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    flagged?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PanelUploadUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPanelUploadStatusFieldUpdateOperationsInput | $Enums.PanelUploadStatus
    source?: EnumPanelUploadSourceFieldUpdateOperationsInput | $Enums.PanelUploadSource
    storageKey?: StringFieldUpdateOperationsInput | string
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    normalizedPayload?: NullableJsonNullValueInput | InputJsonValue
    measurementCount?: IntFieldUpdateOperationsInput | number
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    measurements?: BiomarkerMeasurementUpdateManyWithoutPanelUploadNestedInput
  }

  export type PanelUploadUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPanelUploadStatusFieldUpdateOperationsInput | $Enums.PanelUploadStatus
    source?: EnumPanelUploadSourceFieldUpdateOperationsInput | $Enums.PanelUploadSource
    storageKey?: StringFieldUpdateOperationsInput | string
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    normalizedPayload?: NullableJsonNullValueInput | InputJsonValue
    measurementCount?: IntFieldUpdateOperationsInput | number
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    measurements?: BiomarkerMeasurementUncheckedUpdateManyWithoutPanelUploadNestedInput
  }

  export type PanelUploadUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumPanelUploadStatusFieldUpdateOperationsInput | $Enums.PanelUploadStatus
    source?: EnumPanelUploadSourceFieldUpdateOperationsInput | $Enums.PanelUploadSource
    storageKey?: StringFieldUpdateOperationsInput | string
    contentType?: NullableStringFieldUpdateOperationsInput | string | null
    pageCount?: NullableIntFieldUpdateOperationsInput | number | null
    rawMetadata?: NullableJsonNullValueInput | InputJsonValue
    normalizedPayload?: NullableJsonNullValueInput | InputJsonValue
    measurementCount?: IntFieldUpdateOperationsInput | number
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerMeasurementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    markerName?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMeasurementStatusFieldUpdateOperationsInput | $Enums.MeasurementStatus
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    confidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    biomarker?: BiomarkerUpdateOneWithoutMeasurementsNestedInput
    panelUpload?: PanelUploadUpdateOneWithoutMeasurementsNestedInput
  }

  export type BiomarkerMeasurementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    biomarkerId?: NullableStringFieldUpdateOperationsInput | string | null
    panelUploadId?: NullableStringFieldUpdateOperationsInput | string | null
    markerName?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMeasurementStatusFieldUpdateOperationsInput | $Enums.MeasurementStatus
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    confidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerMeasurementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    biomarkerId?: NullableStringFieldUpdateOperationsInput | string | null
    panelUploadId?: NullableStringFieldUpdateOperationsInput | string | null
    markerName?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMeasurementStatusFieldUpdateOperationsInput | $Enums.MeasurementStatus
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    confidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedPostUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    tags?: FeedPostUpdatetagsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUpdateManyWithoutPostNestedInput
    reactions?: ReactionUpdateManyWithoutPostNestedInput
    flags?: FlagUpdateManyWithoutPostNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutPostNestedInput
  }

  export type FeedPostUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    tags?: FeedPostUpdatetagsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: CommentUncheckedUpdateManyWithoutPostNestedInput
    reactions?: ReactionUncheckedUpdateManyWithoutPostNestedInput
    flags?: FlagUncheckedUpdateManyWithoutPostNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutPostNestedInput
  }

  export type FeedPostUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    tags?: FeedPostUpdatetagsInput | string[]
    visibility?: EnumPostVisibilityFieldUpdateOperationsInput | $Enums.PostVisibility
    flagged?: BoolFieldUpdateOperationsInput | boolean
    reactionSummary?: NullableJsonNullValueInput | InputJsonValue
    commentCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: FeedPostUpdateOneRequiredWithoutCommentsNestedInput
    reactions?: ReactionUpdateManyWithoutCommentNestedInput
    flags?: FlagUpdateManyWithoutCommentNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ReactionUncheckedUpdateManyWithoutCommentNestedInput
    flags?: FlagUncheckedUpdateManyWithoutCommentNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    postId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: FeedPostUpdateOneWithoutReactionsNestedInput
    comment?: CommentUpdateOneWithoutReactionsNestedInput
  }

  export type ReactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementEventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementEventTypeFieldUpdateOperationsInput | $Enums.EngagementEventType
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    post?: FeedPostUpdateOneWithoutEngagementEventsNestedInput
    comment?: CommentUpdateOneWithoutEngagementEventsNestedInput
  }

  export type EngagementEventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementEventTypeFieldUpdateOperationsInput | $Enums.EngagementEventType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EngagementEventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementEventTypeFieldUpdateOperationsInput | $Enums.EngagementEventType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RoomUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RoomMembershipUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    memberships?: RoomMembershipUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutHostInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    inviteCode?: StringFieldUpdateOperationsInput | string
    status?: EnumRoomStatusFieldUpdateOperationsInput | $Enums.RoomStatus
    capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomMembershipUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoomMembershipRoleFieldUpdateOperationsInput | $Enums.RoomMembershipRole
    status?: EnumRoomMembershipStatusFieldUpdateOperationsInput | $Enums.RoomMembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconnectToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutMembershipsNestedInput
  }

  export type RoomMembershipUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoomMembershipRoleFieldUpdateOperationsInput | $Enums.RoomMembershipRole
    status?: EnumRoomMembershipStatusFieldUpdateOperationsInput | $Enums.RoomMembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconnectToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomMembershipUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoomMembershipRoleFieldUpdateOperationsInput | $Enums.RoomMembershipRole
    status?: EnumRoomMembershipStatusFieldUpdateOperationsInput | $Enums.RoomMembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconnectToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlagUpdateWithoutOpenedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: FeedPostUpdateOneWithoutFlagsNestedInput
    comment?: CommentUpdateOneWithoutFlagsNestedInput
    insight?: InsightUpdateOneWithoutFlagsNestedInput
    biomarkerLog?: BiomarkerLogUpdateOneWithoutFlagsNestedInput
    resolvedBy?: UserUpdateOneWithoutFlagsResolvedNestedInput
  }

  export type FlagUncheckedUpdateWithoutOpenedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    insightId?: NullableStringFieldUpdateOperationsInput | string | null
    biomarkerLogId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlagUncheckedUpdateManyWithoutOpenedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    insightId?: NullableStringFieldUpdateOperationsInput | string | null
    biomarkerLogId?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlagUpdateWithoutResolvedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: FeedPostUpdateOneWithoutFlagsNestedInput
    comment?: CommentUpdateOneWithoutFlagsNestedInput
    insight?: InsightUpdateOneWithoutFlagsNestedInput
    biomarkerLog?: BiomarkerLogUpdateOneWithoutFlagsNestedInput
    openedBy?: UserUpdateOneRequiredWithoutFlagsOpenedNestedInput
  }

  export type FlagUncheckedUpdateWithoutResolvedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    insightId?: NullableStringFieldUpdateOperationsInput | string | null
    biomarkerLogId?: NullableStringFieldUpdateOperationsInput | string | null
    openedById?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlagUncheckedUpdateManyWithoutResolvedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    insightId?: NullableStringFieldUpdateOperationsInput | string | null
    biomarkerLogId?: NullableStringFieldUpdateOperationsInput | string | null
    openedById?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AdminAuditLogUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    targetType?: StringFieldUpdateOperationsInput | string
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LongevityPlanUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLongevityPlanStatusFieldUpdateOperationsInput | $Enums.LongevityPlanStatus
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    focusAreas?: LongevityPlanUpdatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: LongevityPlanJobUpdateManyWithoutPlanNestedInput
    audits?: AiResponseAuditUpdateManyWithoutPlanNestedInput
  }

  export type LongevityPlanUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLongevityPlanStatusFieldUpdateOperationsInput | $Enums.LongevityPlanStatus
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    focusAreas?: LongevityPlanUpdatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: LongevityPlanJobUncheckedUpdateManyWithoutPlanNestedInput
    audits?: AiResponseAuditUncheckedUpdateManyWithoutPlanNestedInput
  }

  export type LongevityPlanUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLongevityPlanStatusFieldUpdateOperationsInput | $Enums.LongevityPlanStatus
    title?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    focusAreas?: LongevityPlanUpdatefocusAreasInput | string[]
    sections?: NullableJsonNullValueInput | InputJsonValue
    evidence?: NullableJsonNullValueInput | InputJsonValue
    safetyState?: NullableJsonNullValueInput | InputJsonValue
    validatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    validatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LongevityPlanJobUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLongevityPlanJobStatusFieldUpdateOperationsInput | $Enums.LongevityPlanJobStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: LongevityPlanUpdateOneWithoutJobsNestedInput
    cloudTask?: CloudTaskMetadataUpdateOneWithoutPlanJobNestedInput
  }

  export type LongevityPlanJobUncheckedUpdateWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLongevityPlanJobStatusFieldUpdateOperationsInput | $Enums.LongevityPlanJobStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cloudTask?: CloudTaskMetadataUncheckedUpdateOneWithoutPlanJobNestedInput
  }

  export type LongevityPlanJobUncheckedUpdateManyWithoutRequestedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLongevityPlanJobStatusFieldUpdateOperationsInput | $Enums.LongevityPlanJobStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiResponseAuditUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plan?: LongevityPlanUpdateOneWithoutAuditsNestedInput
  }

  export type AiResponseAuditUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiResponseAuditUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    planId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginAuditUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderTypeFieldUpdateOperationsInput | $Enums.AuthProviderType
    success?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginAuditUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderTypeFieldUpdateOperationsInput | $Enums.AuthProviderType
    success?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LoginAuditUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    provider?: EnumAuthProviderTypeFieldUpdateOperationsInput | $Enums.AuthProviderType
    success?: BoolFieldUpdateOperationsInput | boolean
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightActionCreateManyInsightInput = {
    id?: string
    actorId?: string | null
    actionType: $Enums.InsightActionType
    notes?: string | null
    createdAt?: Date | string
  }

  export type InsightGenerationJobCreateManyInsightInput = {
    id?: string
    requestedById?: string | null
    status: $Enums.InsightGenerationStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlagCreateManyInsightInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    postId?: string | null
    commentId?: string | null
    biomarkerLogId?: string | null
    openedById: string
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InsightActionUpdateWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    actionType?: EnumInsightActionTypeFieldUpdateOperationsInput | $Enums.InsightActionType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: UserUpdateOneWithoutInsightActionsNestedInput
  }

  export type InsightActionUncheckedUpdateWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: EnumInsightActionTypeFieldUpdateOperationsInput | $Enums.InsightActionType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightActionUncheckedUpdateManyWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    actionType?: EnumInsightActionTypeFieldUpdateOperationsInput | $Enums.InsightActionType
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InsightGenerationJobUpdateWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumInsightGenerationStatusFieldUpdateOperationsInput | $Enums.InsightGenerationStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: UserUpdateOneWithoutInsightGenerationJobsNestedInput
    cloudTask?: CloudTaskMetadataUpdateOneWithoutJobNestedInput
  }

  export type InsightGenerationJobUncheckedUpdateWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsightGenerationStatusFieldUpdateOperationsInput | $Enums.InsightGenerationStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cloudTask?: CloudTaskMetadataUncheckedUpdateOneWithoutJobNestedInput
  }

  export type InsightGenerationJobUncheckedUpdateManyWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumInsightGenerationStatusFieldUpdateOperationsInput | $Enums.InsightGenerationStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlagUpdateWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: FeedPostUpdateOneWithoutFlagsNestedInput
    comment?: CommentUpdateOneWithoutFlagsNestedInput
    biomarkerLog?: BiomarkerLogUpdateOneWithoutFlagsNestedInput
    openedBy?: UserUpdateOneRequiredWithoutFlagsOpenedNestedInput
    resolvedBy?: UserUpdateOneWithoutFlagsResolvedNestedInput
  }

  export type FlagUncheckedUpdateWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    biomarkerLogId?: NullableStringFieldUpdateOperationsInput | string | null
    openedById?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlagUncheckedUpdateManyWithoutInsightInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    biomarkerLogId?: NullableStringFieldUpdateOperationsInput | string | null
    openedById?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LongevityPlanJobCreateManyPlanInput = {
    id?: string
    requestedById?: string | null
    status?: $Enums.LongevityPlanJobStatus
    cloudTaskName?: string | null
    queue?: string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    dispatchedAt?: Date | string | null
    completedAt?: Date | string | null
    errorCode?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AiResponseAuditCreateManyPlanInput = {
    id?: string
    userId?: string | null
    provider: string
    model?: string | null
    role?: string | null
    prompt?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type LongevityPlanJobUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumLongevityPlanJobStatusFieldUpdateOperationsInput | $Enums.LongevityPlanJobStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    requestedBy?: UserUpdateOneWithoutLongevityPlanJobsNestedInput
    cloudTask?: CloudTaskMetadataUpdateOneWithoutPlanJobNestedInput
  }

  export type LongevityPlanJobUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLongevityPlanJobStatusFieldUpdateOperationsInput | $Enums.LongevityPlanJobStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cloudTask?: CloudTaskMetadataUncheckedUpdateOneWithoutPlanJobNestedInput
  }

  export type LongevityPlanJobUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumLongevityPlanJobStatusFieldUpdateOperationsInput | $Enums.LongevityPlanJobStatus
    cloudTaskName?: NullableStringFieldUpdateOperationsInput | string | null
    queue?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    dispatchedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorCode?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiResponseAuditUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAiResponseAuditsNestedInput
  }

  export type AiResponseAuditUncheckedUpdateWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AiResponseAuditUncheckedUpdateManyWithoutPlanInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: StringFieldUpdateOperationsInput | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    prompt?: NullableJsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerLogCreateManyBiomarkerInput = {
    id?: string
    userId: string
    value: Decimal | DecimalJsLike | number | string
    unit?: string | null
    source?: $Enums.BiomarkerSource
    capturedAt: Date | string
    accepted?: boolean
    flagged?: boolean
    notes?: string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiomarkerMeasurementCreateManyBiomarkerInput = {
    id?: string
    userId: string
    panelUploadId?: string | null
    markerName: string
    value?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    capturedAt?: Date | string | null
    status?: $Enums.MeasurementStatus
    source?: $Enums.BiomarkerSource
    confidence?: Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiomarkerLogUpdateWithoutBiomarkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    flagged?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBiomarkerLogsNestedInput
    flags?: FlagUpdateManyWithoutBiomarkerLogNestedInput
  }

  export type BiomarkerLogUncheckedUpdateWithoutBiomarkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    flagged?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    flags?: FlagUncheckedUpdateManyWithoutBiomarkerLogNestedInput
  }

  export type BiomarkerLogUncheckedUpdateManyWithoutBiomarkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    value?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    capturedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accepted?: BoolFieldUpdateOperationsInput | boolean
    flagged?: BoolFieldUpdateOperationsInput | boolean
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    rawPayload?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerMeasurementUpdateWithoutBiomarkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    markerName?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMeasurementStatusFieldUpdateOperationsInput | $Enums.MeasurementStatus
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    confidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBiomarkerMeasurementsNestedInput
    panelUpload?: PanelUploadUpdateOneWithoutMeasurementsNestedInput
  }

  export type BiomarkerMeasurementUncheckedUpdateWithoutBiomarkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    panelUploadId?: NullableStringFieldUpdateOperationsInput | string | null
    markerName?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMeasurementStatusFieldUpdateOperationsInput | $Enums.MeasurementStatus
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    confidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerMeasurementUncheckedUpdateManyWithoutBiomarkerInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    panelUploadId?: NullableStringFieldUpdateOperationsInput | string | null
    markerName?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMeasurementStatusFieldUpdateOperationsInput | $Enums.MeasurementStatus
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    confidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlagCreateManyBiomarkerLogInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    postId?: string | null
    commentId?: string | null
    insightId?: string | null
    openedById: string
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FlagUpdateWithoutBiomarkerLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: FeedPostUpdateOneWithoutFlagsNestedInput
    comment?: CommentUpdateOneWithoutFlagsNestedInput
    insight?: InsightUpdateOneWithoutFlagsNestedInput
    openedBy?: UserUpdateOneRequiredWithoutFlagsOpenedNestedInput
    resolvedBy?: UserUpdateOneWithoutFlagsResolvedNestedInput
  }

  export type FlagUncheckedUpdateWithoutBiomarkerLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    insightId?: NullableStringFieldUpdateOperationsInput | string | null
    openedById?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlagUncheckedUpdateManyWithoutBiomarkerLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    insightId?: NullableStringFieldUpdateOperationsInput | string | null
    openedById?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerMeasurementCreateManyPanelUploadInput = {
    id?: string
    userId: string
    biomarkerId?: string | null
    markerName: string
    value?: Decimal | DecimalJsLike | number | string | null
    unit?: string | null
    referenceLow?: Decimal | DecimalJsLike | number | string | null
    referenceHigh?: Decimal | DecimalJsLike | number | string | null
    capturedAt?: Date | string | null
    status?: $Enums.MeasurementStatus
    source?: $Enums.BiomarkerSource
    confidence?: Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BiomarkerMeasurementUpdateWithoutPanelUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    markerName?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMeasurementStatusFieldUpdateOperationsInput | $Enums.MeasurementStatus
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    confidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBiomarkerMeasurementsNestedInput
    biomarker?: BiomarkerUpdateOneWithoutMeasurementsNestedInput
  }

  export type BiomarkerMeasurementUncheckedUpdateWithoutPanelUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    biomarkerId?: NullableStringFieldUpdateOperationsInput | string | null
    markerName?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMeasurementStatusFieldUpdateOperationsInput | $Enums.MeasurementStatus
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    confidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiomarkerMeasurementUncheckedUpdateManyWithoutPanelUploadInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    biomarkerId?: NullableStringFieldUpdateOperationsInput | string | null
    markerName?: StringFieldUpdateOperationsInput | string
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    referenceLow?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    referenceHigh?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    capturedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumMeasurementStatusFieldUpdateOperationsInput | $Enums.MeasurementStatus
    source?: EnumBiomarkerSourceFieldUpdateOperationsInput | $Enums.BiomarkerSource
    confidence?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    flags?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentCreateManyPostInput = {
    id?: string
    authorId: string
    body: string
    flagged?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReactionCreateManyPostInput = {
    id?: string
    type: $Enums.ReactionType
    commentId?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type FlagCreateManyPostInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    commentId?: string | null
    insightId?: string | null
    biomarkerLogId?: string | null
    openedById: string
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EngagementEventCreateManyPostInput = {
    id?: string
    type: $Enums.EngagementEventType
    userId: string
    commentId?: string | null
    reactionType?: $Enums.ReactionType | null
    occurredAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type CommentUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutCommentsNestedInput
    reactions?: ReactionUpdateManyWithoutCommentNestedInput
    flags?: FlagUpdateManyWithoutCommentNestedInput
    engagementEvents?: EngagementEventUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactions?: ReactionUncheckedUpdateManyWithoutCommentNestedInput
    flags?: FlagUncheckedUpdateManyWithoutCommentNestedInput
    engagementEvents?: EngagementEventUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type CommentUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    flagged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneWithoutReactionsNestedInput
    user?: UserUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type ReactionUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlagUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comment?: CommentUpdateOneWithoutFlagsNestedInput
    insight?: InsightUpdateOneWithoutFlagsNestedInput
    biomarkerLog?: BiomarkerLogUpdateOneWithoutFlagsNestedInput
    openedBy?: UserUpdateOneRequiredWithoutFlagsOpenedNestedInput
    resolvedBy?: UserUpdateOneWithoutFlagsResolvedNestedInput
  }

  export type FlagUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    insightId?: NullableStringFieldUpdateOperationsInput | string | null
    biomarkerLogId?: NullableStringFieldUpdateOperationsInput | string | null
    openedById?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlagUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    insightId?: NullableStringFieldUpdateOperationsInput | string | null
    biomarkerLogId?: NullableStringFieldUpdateOperationsInput | string | null
    openedById?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementEventUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementEventTypeFieldUpdateOperationsInput | $Enums.EngagementEventType
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutEngagementEventsNestedInput
    comment?: CommentUpdateOneWithoutEngagementEventsNestedInput
  }

  export type EngagementEventUncheckedUpdateWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementEventTypeFieldUpdateOperationsInput | $Enums.EngagementEventType
    userId?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EngagementEventUncheckedUpdateManyWithoutPostInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementEventTypeFieldUpdateOperationsInput | $Enums.EngagementEventType
    userId?: StringFieldUpdateOperationsInput | string
    commentId?: NullableStringFieldUpdateOperationsInput | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReactionCreateManyCommentInput = {
    id?: string
    type: $Enums.ReactionType
    postId?: string | null
    userId: string
    createdAt?: Date | string
  }

  export type FlagCreateManyCommentInput = {
    id?: string
    targetType: $Enums.FlagTargetType
    status?: $Enums.FlagStatus
    reason: string
    postId?: string | null
    insightId?: string | null
    biomarkerLogId?: string | null
    openedById: string
    resolvedById?: string | null
    resolvedAt?: Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EngagementEventCreateManyCommentInput = {
    id?: string
    type: $Enums.EngagementEventType
    userId: string
    postId?: string | null
    reactionType?: $Enums.ReactionType | null
    occurredAt?: Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type ReactionUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: FeedPostUpdateOneWithoutReactionsNestedInput
    user?: UserUpdateOneRequiredWithoutReactionsNestedInput
  }

  export type ReactionUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReactionUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlagUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: FeedPostUpdateOneWithoutFlagsNestedInput
    insight?: InsightUpdateOneWithoutFlagsNestedInput
    biomarkerLog?: BiomarkerLogUpdateOneWithoutFlagsNestedInput
    openedBy?: UserUpdateOneRequiredWithoutFlagsOpenedNestedInput
    resolvedBy?: UserUpdateOneWithoutFlagsResolvedNestedInput
  }

  export type FlagUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    insightId?: NullableStringFieldUpdateOperationsInput | string | null
    biomarkerLogId?: NullableStringFieldUpdateOperationsInput | string | null
    openedById?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FlagUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    targetType?: EnumFlagTargetTypeFieldUpdateOperationsInput | $Enums.FlagTargetType
    status?: EnumFlagStatusFieldUpdateOperationsInput | $Enums.FlagStatus
    reason?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    insightId?: NullableStringFieldUpdateOperationsInput | string | null
    biomarkerLogId?: NullableStringFieldUpdateOperationsInput | string | null
    openedById?: StringFieldUpdateOperationsInput | string
    resolvedById?: NullableStringFieldUpdateOperationsInput | string | null
    resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditTrail?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementEventUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementEventTypeFieldUpdateOperationsInput | $Enums.EngagementEventType
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutEngagementEventsNestedInput
    post?: FeedPostUpdateOneWithoutEngagementEventsNestedInput
  }

  export type EngagementEventUncheckedUpdateWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementEventTypeFieldUpdateOperationsInput | $Enums.EngagementEventType
    userId?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EngagementEventUncheckedUpdateManyWithoutCommentInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumEngagementEventTypeFieldUpdateOperationsInput | $Enums.EngagementEventType
    userId?: StringFieldUpdateOperationsInput | string
    postId?: NullableStringFieldUpdateOperationsInput | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    occurredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    metadata?: NullableJsonNullValueInput | InputJsonValue
  }

  export type RoomMembershipCreateManyRoomInput = {
    id?: string
    userId: string
    role?: $Enums.RoomMembershipRole
    status?: $Enums.RoomMembershipStatus
    joinedAt?: Date | string
    leftAt?: Date | string | null
    lastSeenAt?: Date | string | null
    reconnectToken?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomMembershipUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: EnumRoomMembershipRoleFieldUpdateOperationsInput | $Enums.RoomMembershipRole
    status?: EnumRoomMembershipStatusFieldUpdateOperationsInput | $Enums.RoomMembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconnectToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRoomMembershipsNestedInput
  }

  export type RoomMembershipUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoomMembershipRoleFieldUpdateOperationsInput | $Enums.RoomMembershipRole
    status?: EnumRoomMembershipStatusFieldUpdateOperationsInput | $Enums.RoomMembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconnectToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomMembershipUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoomMembershipRoleFieldUpdateOperationsInput | $Enums.RoomMembershipRole
    status?: EnumRoomMembershipStatusFieldUpdateOperationsInput | $Enums.RoomMembershipStatus
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastSeenAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reconnectToken?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InsightCountOutputTypeDefaultArgs instead
     */
    export type InsightCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InsightCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LongevityPlanCountOutputTypeDefaultArgs instead
     */
    export type LongevityPlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LongevityPlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BiomarkerCountOutputTypeDefaultArgs instead
     */
    export type BiomarkerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BiomarkerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BiomarkerLogCountOutputTypeDefaultArgs instead
     */
    export type BiomarkerLogCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BiomarkerLogCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PanelUploadCountOutputTypeDefaultArgs instead
     */
    export type PanelUploadCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PanelUploadCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedPostCountOutputTypeDefaultArgs instead
     */
    export type FeedPostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedPostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentCountOutputTypeDefaultArgs instead
     */
    export type CommentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomCountOutputTypeDefaultArgs instead
     */
    export type RoomCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProfileDefaultArgs instead
     */
    export type ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InsightDefaultArgs instead
     */
    export type InsightArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InsightDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LongevityPlanDefaultArgs instead
     */
    export type LongevityPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LongevityPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BiomarkerDefaultArgs instead
     */
    export type BiomarkerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BiomarkerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BiomarkerLogDefaultArgs instead
     */
    export type BiomarkerLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BiomarkerLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PanelUploadDefaultArgs instead
     */
    export type PanelUploadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PanelUploadDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BiomarkerMeasurementDefaultArgs instead
     */
    export type BiomarkerMeasurementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BiomarkerMeasurementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuthProviderDefaultArgs instead
     */
    export type AuthProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuthProviderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LoginAuditDefaultArgs instead
     */
    export type LoginAuditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LoginAuditDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InsightActionDefaultArgs instead
     */
    export type InsightActionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InsightActionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InsightGenerationJobDefaultArgs instead
     */
    export type InsightGenerationJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InsightGenerationJobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LongevityPlanJobDefaultArgs instead
     */
    export type LongevityPlanJobArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LongevityPlanJobDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CloudTaskMetadataDefaultArgs instead
     */
    export type CloudTaskMetadataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CloudTaskMetadataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WhoopIntegrationDefaultArgs instead
     */
    export type WhoopIntegrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WhoopIntegrationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use WhoopLinkSessionDefaultArgs instead
     */
    export type WhoopLinkSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = WhoopLinkSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedPostDefaultArgs instead
     */
    export type FeedPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentDefaultArgs instead
     */
    export type CommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReactionDefaultArgs instead
     */
    export type ReactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EngagementEventDefaultArgs instead
     */
    export type EngagementEventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EngagementEventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FlagDefaultArgs instead
     */
    export type FlagArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FlagDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AdminAuditLogDefaultArgs instead
     */
    export type AdminAuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AdminAuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AiResponseAuditDefaultArgs instead
     */
    export type AiResponseAuditArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AiResponseAuditDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomDefaultArgs instead
     */
    export type RoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomMembershipDefaultArgs instead
     */
    export type RoomMembershipArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomMembershipDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}